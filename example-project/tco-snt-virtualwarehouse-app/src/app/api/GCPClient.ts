//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AwpClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:50852";
    }

    importAwpsRegular(): Observable<ImportAwpsResultDto> {
        let url_ = this.baseUrl + "/api/Awp/import-regular";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportAwpsRegular(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportAwpsRegular(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImportAwpsResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImportAwpsResultDto>;
        }));
    }

    protected processImportAwpsRegular(response: HttpResponseBase): Observable<ImportAwpsResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportAwpsResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportAwpsResultDto>();
    }

    getAll(filter_DateFrom?: Date | null | undefined, filter_DateTo?: Date | null | undefined, filter_RegistrationNumber?: string | null | undefined, filter_SenderTin?: string | null | undefined, filter_RecipientTin?: string | null | undefined, filter_AwpStatus?: AwpStatus | null | undefined, sorting_SortColumn?: string | null | undefined, sorting_SortOrder?: SortingOrder | undefined, paging_CurrentPage?: number | undefined, paging_ItemsPerPage?: number | undefined): Observable<AwpListResponseDto> {
        let url_ = this.baseUrl + "/api/Awp?";
        if (filter_DateFrom !== undefined && filter_DateFrom !== null)
            url_ += "Filter.DateFrom=" + encodeURIComponent(filter_DateFrom ? "" + filter_DateFrom.toYearMonthDateString() : "") + "&";
        if (filter_DateTo !== undefined && filter_DateTo !== null)
            url_ += "Filter.DateTo=" + encodeURIComponent(filter_DateTo ? "" + filter_DateTo.toYearMonthDateString() : "") + "&";
        if (filter_RegistrationNumber !== undefined && filter_RegistrationNumber !== null)
            url_ += "Filter.RegistrationNumber=" + encodeURIComponent("" + filter_RegistrationNumber) + "&";
        if (filter_SenderTin !== undefined && filter_SenderTin !== null)
            url_ += "Filter.SenderTin=" + encodeURIComponent("" + filter_SenderTin) + "&";
        if (filter_RecipientTin !== undefined && filter_RecipientTin !== null)
            url_ += "Filter.RecipientTin=" + encodeURIComponent("" + filter_RecipientTin) + "&";
        if (filter_AwpStatus !== undefined && filter_AwpStatus !== null)
            url_ += "Filter.AwpStatus=" + encodeURIComponent("" + filter_AwpStatus) + "&";
        if (sorting_SortColumn !== undefined && sorting_SortColumn !== null)
            url_ += "Sorting.SortColumn=" + encodeURIComponent("" + sorting_SortColumn) + "&";
        if (sorting_SortOrder === null)
            throw new Error("The parameter 'sorting_SortOrder' cannot be null.");
        else if (sorting_SortOrder !== undefined)
            url_ += "Sorting.SortOrder=" + encodeURIComponent("" + sorting_SortOrder) + "&";
        if (paging_CurrentPage === null)
            throw new Error("The parameter 'paging_CurrentPage' cannot be null.");
        else if (paging_CurrentPage !== undefined)
            url_ += "Paging.CurrentPage=" + encodeURIComponent("" + paging_CurrentPage) + "&";
        if (paging_ItemsPerPage === null)
            throw new Error("The parameter 'paging_ItemsPerPage' cannot be null.");
        else if (paging_ItemsPerPage !== undefined)
            url_ += "Paging.ItemsPerPage=" + encodeURIComponent("" + paging_ItemsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AwpListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AwpListResponseDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AwpListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwpListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwpListResponseDto>();
    }

    getAwpWorksPerformedByAwpId(awpId?: number | undefined): Observable<AwpWorksPerformedDto> {
        let url_ = this.baseUrl + "/api/Awp/get-awpworksperformed-by-awpdId?";
        if (awpId === null)
            throw new Error("The parameter 'awpId' cannot be null.");
        else if (awpId !== undefined)
            url_ += "awpId=" + encodeURIComponent("" + awpId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwpWorksPerformedByAwpId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwpWorksPerformedByAwpId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AwpWorksPerformedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AwpWorksPerformedDto>;
        }));
    }

    protected processGetAwpWorksPerformedByAwpId(response: HttpResponseBase): Observable<AwpWorksPerformedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwpWorksPerformedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwpWorksPerformedDto>();
    }

    getAwpsByEsfNumber(esfNumber?: string | null | undefined): Observable<AwpEsfResponseDto> {
        let url_ = this.baseUrl + "/api/Awp/esf?";
        if (esfNumber !== undefined && esfNumber !== null)
            url_ += "esfNumber=" + encodeURIComponent("" + esfNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwpsByEsfNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwpsByEsfNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AwpEsfResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AwpEsfResponseDto>;
        }));
    }

    protected processGetAwpsByEsfNumber(response: HttpResponseBase): Observable<AwpEsfResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwpEsfResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwpEsfResponseDto>();
    }

    getAwpsByRegistrationNumber(registrationNumber?: string | null | undefined): Observable<AwpConiResponseDto> {
        let url_ = this.baseUrl + "/api/Awp/get-by-reg-number?";
        if (registrationNumber !== undefined && registrationNumber !== null)
            url_ += "registrationNumber=" + encodeURIComponent("" + registrationNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwpsByRegistrationNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwpsByRegistrationNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AwpConiResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AwpConiResponseDto>;
        }));
    }

    protected processGetAwpsByRegistrationNumber(response: HttpResponseBase): Observable<AwpConiResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwpConiResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwpConiResponseDto>();
    }

    getAwpsByFilter(status?: AwpStatus | null | undefined, lastUpdateDate?: Date | null | undefined, senderTin?: string | null | undefined, number?: string | null | undefined): Observable<AwpConiResponseDto[]> {
        let url_ = this.baseUrl + "/api/Awp/get-by-filter?";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (lastUpdateDate !== undefined && lastUpdateDate !== null)
            url_ += "LastUpdateDate=" + encodeURIComponent(lastUpdateDate ? "" + lastUpdateDate.toYearMonthDateString() : "") + "&";
        if (senderTin !== undefined && senderTin !== null)
            url_ += "SenderTin=" + encodeURIComponent("" + senderTin) + "&";
        if (number !== undefined && number !== null)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAwpsByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAwpsByFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AwpConiResponseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AwpConiResponseDto[]>;
        }));
    }

    protected processGetAwpsByFilter(response: HttpResponseBase): Observable<AwpConiResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AwpConiResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwpConiResponseDto[]>();
    }
}

@Injectable()
export class InvoicesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:50852";
    }

    importInvoicesInitial(): Observable<ImportInvoicesInitialResultDto> {
        let url_ = this.baseUrl + "/api/Invoices/import-initial";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportInvoicesInitial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportInvoicesInitial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImportInvoicesInitialResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImportInvoicesInitialResultDto>;
        }));
    }

    protected processImportInvoicesInitial(response: HttpResponseBase): Observable<ImportInvoicesInitialResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportInvoicesInitialResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportInvoicesInitialResultDto>();
    }

    importInvoicesRegular(): Observable<ImportInvoicesRegularResultDto> {
        let url_ = this.baseUrl + "/api/Invoices/import-regular";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportInvoicesRegular(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportInvoicesRegular(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImportInvoicesRegularResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImportInvoicesRegularResultDto>;
        }));
    }

    protected processImportInvoicesRegular(response: HttpResponseBase): Observable<ImportInvoicesRegularResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportInvoicesRegularResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportInvoicesRegularResultDto>();
    }

    getOutboundInvoice(id: number): Observable<InvoiceFullDto> {
        let url_ = this.baseUrl + "/api/Invoices/outbound/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOutboundInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOutboundInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceFullDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceFullDto>;
        }));
    }

    protected processGetOutboundInvoice(response: HttpResponseBase): Observable<InvoiceFullDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceFullDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceFullDto>();
    }

    saveDraft(dto: InvoiceDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Invoices/outbound/save-draft";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDraft(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDraft(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveDraft(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>();
    }

    signingPageForInvoice(dto: SendInvoiceDto): Observable<SigningPageForInvoiceResponseDto> {
        let url_ = this.baseUrl + "/api/Invoices/signing-page-for-invoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSigningPageForInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSigningPageForInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SigningPageForInvoiceResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SigningPageForInvoiceResponseDto>;
        }));
    }

    protected processSigningPageForInvoice(response: HttpResponseBase): Observable<SigningPageForInvoiceResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SigningPageForInvoiceResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationProblemDetails.fromJS(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SigningPageForInvoiceResponseDto>();
    }

    revoke(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Invoices/outbound/{id}/revoke";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevoke(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevoke(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processRevoke(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>();
    }

    getInvoiceByRegNum(registrationNumber: string): Observable<GetInvoiceByRegistrationNumberResponseDto> {
        let url_ = this.baseUrl + "/api/Invoices/inbound/{registrationNumber}";
        if (registrationNumber === undefined || registrationNumber === null)
            throw new Error("The parameter 'registrationNumber' must be defined.");
        url_ = url_.replace("{registrationNumber}", encodeURIComponent("" + registrationNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceByRegNum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceByRegNum(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetInvoiceByRegistrationNumberResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetInvoiceByRegistrationNumberResponseDto>;
        }));
    }

    protected processGetInvoiceByRegNum(response: HttpResponseBase): Observable<GetInvoiceByRegistrationNumberResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInvoiceByRegistrationNumberResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInvoiceByRegistrationNumberResponseDto>();
    }

    getInvoicesForSigning(filter_OwnInvoices?: boolean | undefined, sorting_SortColumn?: string | null | undefined, sorting_SortOrder?: SortingOrder | undefined, paging_CurrentPage?: number | undefined, paging_ItemsPerPage?: number | undefined): Observable<GetInvoicesForSigningResponseDto> {
        let url_ = this.baseUrl + "/api/Invoices/get-invoices-for-signing?";
        if (filter_OwnInvoices === null)
            throw new Error("The parameter 'filter_OwnInvoices' cannot be null.");
        else if (filter_OwnInvoices !== undefined)
            url_ += "Filter.OwnInvoices=" + encodeURIComponent("" + filter_OwnInvoices) + "&";
        if (sorting_SortColumn !== undefined && sorting_SortColumn !== null)
            url_ += "Sorting.SortColumn=" + encodeURIComponent("" + sorting_SortColumn) + "&";
        if (sorting_SortOrder === null)
            throw new Error("The parameter 'sorting_SortOrder' cannot be null.");
        else if (sorting_SortOrder !== undefined)
            url_ += "Sorting.SortOrder=" + encodeURIComponent("" + sorting_SortOrder) + "&";
        if (paging_CurrentPage === null)
            throw new Error("The parameter 'paging_CurrentPage' cannot be null.");
        else if (paging_CurrentPage !== undefined)
            url_ += "Paging.CurrentPage=" + encodeURIComponent("" + paging_CurrentPage) + "&";
        if (paging_ItemsPerPage === null)
            throw new Error("The parameter 'paging_ItemsPerPage' cannot be null.");
        else if (paging_ItemsPerPage !== undefined)
            url_ += "Paging.ItemsPerPage=" + encodeURIComponent("" + paging_ItemsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoicesForSigning(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoicesForSigning(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetInvoicesForSigningResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetInvoicesForSigningResponseDto>;
        }));
    }

    protected processGetInvoicesForSigning(response: HttpResponseBase): Observable<GetInvoicesForSigningResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInvoicesForSigningResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInvoicesForSigningResponseDto>();
    }

    signingPageForInvoices(dto: SendMassInvoicesDto): Observable<SigningPageForMassInvoicesResponseDto> {
        let url_ = this.baseUrl + "/api/Invoices/signing-page-for-invoices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSigningPageForInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSigningPageForInvoices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SigningPageForMassInvoicesResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SigningPageForMassInvoicesResponseDto>;
        }));
    }

    protected processSigningPageForInvoices(response: HttpResponseBase): Observable<SigningPageForMassInvoicesResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SigningPageForMassInvoicesResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationProblemDetails.fromJS(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SigningPageForMassInvoicesResponseDto>();
    }
}

@Injectable()
export class JdeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:50852";
    }

    getJdeArByCompositeId(id?: number | undefined, documentNumber?: string | null | undefined, documentType?: string | null | undefined): Observable<JdeArInvoiceDto> {
        let url_ = this.baseUrl + "/api/Jde/get-jde-ar-by-composite-id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (documentNumber !== undefined && documentNumber !== null)
            url_ += "documentNumber=" + encodeURIComponent("" + documentNumber) + "&";
        if (documentType !== undefined && documentType !== null)
            url_ += "documentType=" + encodeURIComponent("" + documentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJdeArByCompositeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJdeArByCompositeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JdeArInvoiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JdeArInvoiceDto>;
        }));
    }

    protected processGetJdeArByCompositeId(response: HttpResponseBase): Observable<JdeArInvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JdeArInvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JdeArInvoiceDto>();
    }

    getOutboundInvoiceDraftByJdeId(id: number): Observable<JdeArInvoiceDto> {
        let url_ = this.baseUrl + "/api/Jde/outbound/jde-draft/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOutboundInvoiceDraftByJdeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOutboundInvoiceDraftByJdeId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JdeArInvoiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JdeArInvoiceDto>;
        }));
    }

    protected processGetOutboundInvoiceDraftByJdeId(response: HttpResponseBase): Observable<JdeArInvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JdeArInvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JdeArInvoiceDto>();
    }

    getJdeArMatches(filter_DateFrom?: Date | undefined, filter_DateTo?: Date | undefined, filter_Number?: string | null | undefined, filter_ReconciliationStatus?: ReconciliationStatus | null | undefined, filter_CustomerName?: string | null | undefined, filter_Tin?: string | null | undefined, filter_RegistrationNumber?: string | null | undefined, filter_OwnInvoices?: boolean | undefined, filter_IsDrafts?: boolean | undefined, sorting_SortColumn?: string | null | undefined, sorting_SortOrder?: SortingOrder | undefined, paging_CurrentPage?: number | undefined, paging_ItemsPerPage?: number | undefined): Observable<GetJdeArMatchesResponseDto> {
        let url_ = this.baseUrl + "/api/Jde/get-jde-ar-matches?";
        if (filter_DateFrom === null)
            throw new Error("The parameter 'filter_DateFrom' cannot be null.");
        else if (filter_DateFrom !== undefined)
            url_ += "Filter.DateFrom=" + encodeURIComponent(filter_DateFrom ? "" + filter_DateFrom.toYearMonthDateString() : "") + "&";
        if (filter_DateTo === null)
            throw new Error("The parameter 'filter_DateTo' cannot be null.");
        else if (filter_DateTo !== undefined)
            url_ += "Filter.DateTo=" + encodeURIComponent(filter_DateTo ? "" + filter_DateTo.toYearMonthDateString() : "") + "&";
        if (filter_Number !== undefined && filter_Number !== null)
            url_ += "Filter.Number=" + encodeURIComponent("" + filter_Number) + "&";
        if (filter_ReconciliationStatus !== undefined && filter_ReconciliationStatus !== null)
            url_ += "Filter.ReconciliationStatus=" + encodeURIComponent("" + filter_ReconciliationStatus) + "&";
        if (filter_CustomerName !== undefined && filter_CustomerName !== null)
            url_ += "Filter.CustomerName=" + encodeURIComponent("" + filter_CustomerName) + "&";
        if (filter_Tin !== undefined && filter_Tin !== null)
            url_ += "Filter.Tin=" + encodeURIComponent("" + filter_Tin) + "&";
        if (filter_RegistrationNumber !== undefined && filter_RegistrationNumber !== null)
            url_ += "Filter.RegistrationNumber=" + encodeURIComponent("" + filter_RegistrationNumber) + "&";
        if (filter_OwnInvoices === null)
            throw new Error("The parameter 'filter_OwnInvoices' cannot be null.");
        else if (filter_OwnInvoices !== undefined)
            url_ += "Filter.OwnInvoices=" + encodeURIComponent("" + filter_OwnInvoices) + "&";
        if (filter_IsDrafts === null)
            throw new Error("The parameter 'filter_IsDrafts' cannot be null.");
        else if (filter_IsDrafts !== undefined)
            url_ += "Filter.IsDrafts=" + encodeURIComponent("" + filter_IsDrafts) + "&";
        if (sorting_SortColumn !== undefined && sorting_SortColumn !== null)
            url_ += "Sorting.SortColumn=" + encodeURIComponent("" + sorting_SortColumn) + "&";
        if (sorting_SortOrder === null)
            throw new Error("The parameter 'sorting_SortOrder' cannot be null.");
        else if (sorting_SortOrder !== undefined)
            url_ += "Sorting.SortOrder=" + encodeURIComponent("" + sorting_SortOrder) + "&";
        if (paging_CurrentPage === null)
            throw new Error("The parameter 'paging_CurrentPage' cannot be null.");
        else if (paging_CurrentPage !== undefined)
            url_ += "Paging.CurrentPage=" + encodeURIComponent("" + paging_CurrentPage) + "&";
        if (paging_ItemsPerPage === null)
            throw new Error("The parameter 'paging_ItemsPerPage' cannot be null.");
        else if (paging_ItemsPerPage !== undefined)
            url_ += "Paging.ItemsPerPage=" + encodeURIComponent("" + paging_ItemsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJdeArMatches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJdeArMatches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetJdeArMatchesResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetJdeArMatchesResponseDto>;
        }));
    }

    protected processGetJdeArMatches(response: HttpResponseBase): Observable<GetJdeArMatchesResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetJdeArMatchesResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetJdeArMatchesResponseDto>();
    }

    getJdeApPoMatches(filter_DateFrom?: Date | undefined, filter_DateTo?: Date | undefined, filter_Number?: string | null | undefined, filter_ReconciliationStatus?: ApReconciliationStatus | null | undefined, filter_InvoiceStatuses?: InvoiceStatus[] | null | undefined, filter_SupllierName?: string | null | undefined, filter_InvoiceType?: InvoiceType | null | undefined, filter_Tin?: string | null | undefined, filter_EsfRegistrationNumber?: string | null | undefined, filter_ManualReconciliationCommentTypes?: ManualReconciliationCommentType[] | null | undefined, sorting_SortColumn?: string | null | undefined, sorting_SortOrder?: SortingOrder | undefined, paging_CurrentPage?: number | undefined, paging_ItemsPerPage?: number | undefined): Observable<GetJdePoMatchesResponseDto> {
        let url_ = this.baseUrl + "/api/Jde/get-jde-ap-po-matches?";
        if (filter_DateFrom === null)
            throw new Error("The parameter 'filter_DateFrom' cannot be null.");
        else if (filter_DateFrom !== undefined)
            url_ += "Filter.DateFrom=" + encodeURIComponent(filter_DateFrom ? "" + filter_DateFrom.toYearMonthDateString() : "") + "&";
        if (filter_DateTo === null)
            throw new Error("The parameter 'filter_DateTo' cannot be null.");
        else if (filter_DateTo !== undefined)
            url_ += "Filter.DateTo=" + encodeURIComponent(filter_DateTo ? "" + filter_DateTo.toYearMonthDateString() : "") + "&";
        if (filter_Number !== undefined && filter_Number !== null)
            url_ += "Filter.Number=" + encodeURIComponent("" + filter_Number) + "&";
        if (filter_ReconciliationStatus !== undefined && filter_ReconciliationStatus !== null)
            url_ += "Filter.ReconciliationStatus=" + encodeURIComponent("" + filter_ReconciliationStatus) + "&";
        if (filter_InvoiceStatuses !== undefined && filter_InvoiceStatuses !== null)
            filter_InvoiceStatuses && filter_InvoiceStatuses.forEach(item => { url_ += "Filter.InvoiceStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (filter_SupllierName !== undefined && filter_SupllierName !== null)
            url_ += "Filter.SupllierName=" + encodeURIComponent("" + filter_SupllierName) + "&";
        if (filter_InvoiceType !== undefined && filter_InvoiceType !== null)
            url_ += "Filter.InvoiceType=" + encodeURIComponent("" + filter_InvoiceType) + "&";
        if (filter_Tin !== undefined && filter_Tin !== null)
            url_ += "Filter.Tin=" + encodeURIComponent("" + filter_Tin) + "&";
        if (filter_EsfRegistrationNumber !== undefined && filter_EsfRegistrationNumber !== null)
            url_ += "Filter.EsfRegistrationNumber=" + encodeURIComponent("" + filter_EsfRegistrationNumber) + "&";
        if (filter_ManualReconciliationCommentTypes !== undefined && filter_ManualReconciliationCommentTypes !== null)
            filter_ManualReconciliationCommentTypes && filter_ManualReconciliationCommentTypes.forEach(item => { url_ += "Filter.ManualReconciliationCommentTypes=" + encodeURIComponent("" + item) + "&"; });
        if (sorting_SortColumn !== undefined && sorting_SortColumn !== null)
            url_ += "Sorting.SortColumn=" + encodeURIComponent("" + sorting_SortColumn) + "&";
        if (sorting_SortOrder === null)
            throw new Error("The parameter 'sorting_SortOrder' cannot be null.");
        else if (sorting_SortOrder !== undefined)
            url_ += "Sorting.SortOrder=" + encodeURIComponent("" + sorting_SortOrder) + "&";
        if (paging_CurrentPage === null)
            throw new Error("The parameter 'paging_CurrentPage' cannot be null.");
        else if (paging_CurrentPage !== undefined)
            url_ += "Paging.CurrentPage=" + encodeURIComponent("" + paging_CurrentPage) + "&";
        if (paging_ItemsPerPage === null)
            throw new Error("The parameter 'paging_ItemsPerPage' cannot be null.");
        else if (paging_ItemsPerPage !== undefined)
            url_ += "Paging.ItemsPerPage=" + encodeURIComponent("" + paging_ItemsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJdeApPoMatches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJdeApPoMatches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetJdePoMatchesResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetJdePoMatchesResponseDto>;
        }));
    }

    protected processGetJdeApPoMatches(response: HttpResponseBase): Observable<GetJdePoMatchesResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetJdePoMatchesResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetJdePoMatchesResponseDto>();
    }

    getJdeApNcMatches(filter_DateFrom?: Date | undefined, filter_DateTo?: Date | undefined, filter_Number?: string | null | undefined, filter_ReconciliationStatus?: ApReconciliationStatus | null | undefined, filter_InvoiceStatuses?: InvoiceStatus[] | null | undefined, filter_SupllierName?: string | null | undefined, filter_InvoiceType?: InvoiceType | null | undefined, filter_Tin?: string | null | undefined, filter_EsfRegistrationNumber?: string | null | undefined, filter_ManualReconciliationCommentTypes?: ManualReconciliationCommentType[] | null | undefined, sorting_SortColumn?: string | null | undefined, sorting_SortOrder?: SortingOrder | undefined, paging_CurrentPage?: number | undefined, paging_ItemsPerPage?: number | undefined): Observable<GetJdeNcMatchesResponseDto> {
        let url_ = this.baseUrl + "/api/Jde/get-jde-ap-nc-matches?";
        if (filter_DateFrom === null)
            throw new Error("The parameter 'filter_DateFrom' cannot be null.");
        else if (filter_DateFrom !== undefined)
            url_ += "Filter.DateFrom=" + encodeURIComponent(filter_DateFrom ? "" + filter_DateFrom.toYearMonthDateString() : "") + "&";
        if (filter_DateTo === null)
            throw new Error("The parameter 'filter_DateTo' cannot be null.");
        else if (filter_DateTo !== undefined)
            url_ += "Filter.DateTo=" + encodeURIComponent(filter_DateTo ? "" + filter_DateTo.toYearMonthDateString() : "") + "&";
        if (filter_Number !== undefined && filter_Number !== null)
            url_ += "Filter.Number=" + encodeURIComponent("" + filter_Number) + "&";
        if (filter_ReconciliationStatus !== undefined && filter_ReconciliationStatus !== null)
            url_ += "Filter.ReconciliationStatus=" + encodeURIComponent("" + filter_ReconciliationStatus) + "&";
        if (filter_InvoiceStatuses !== undefined && filter_InvoiceStatuses !== null)
            filter_InvoiceStatuses && filter_InvoiceStatuses.forEach(item => { url_ += "Filter.InvoiceStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (filter_SupllierName !== undefined && filter_SupllierName !== null)
            url_ += "Filter.SupllierName=" + encodeURIComponent("" + filter_SupllierName) + "&";
        if (filter_InvoiceType !== undefined && filter_InvoiceType !== null)
            url_ += "Filter.InvoiceType=" + encodeURIComponent("" + filter_InvoiceType) + "&";
        if (filter_Tin !== undefined && filter_Tin !== null)
            url_ += "Filter.Tin=" + encodeURIComponent("" + filter_Tin) + "&";
        if (filter_EsfRegistrationNumber !== undefined && filter_EsfRegistrationNumber !== null)
            url_ += "Filter.EsfRegistrationNumber=" + encodeURIComponent("" + filter_EsfRegistrationNumber) + "&";
        if (filter_ManualReconciliationCommentTypes !== undefined && filter_ManualReconciliationCommentTypes !== null)
            filter_ManualReconciliationCommentTypes && filter_ManualReconciliationCommentTypes.forEach(item => { url_ += "Filter.ManualReconciliationCommentTypes=" + encodeURIComponent("" + item) + "&"; });
        if (sorting_SortColumn !== undefined && sorting_SortColumn !== null)
            url_ += "Sorting.SortColumn=" + encodeURIComponent("" + sorting_SortColumn) + "&";
        if (sorting_SortOrder === null)
            throw new Error("The parameter 'sorting_SortOrder' cannot be null.");
        else if (sorting_SortOrder !== undefined)
            url_ += "Sorting.SortOrder=" + encodeURIComponent("" + sorting_SortOrder) + "&";
        if (paging_CurrentPage === null)
            throw new Error("The parameter 'paging_CurrentPage' cannot be null.");
        else if (paging_CurrentPage !== undefined)
            url_ += "Paging.CurrentPage=" + encodeURIComponent("" + paging_CurrentPage) + "&";
        if (paging_ItemsPerPage === null)
            throw new Error("The parameter 'paging_ItemsPerPage' cannot be null.");
        else if (paging_ItemsPerPage !== undefined)
            url_ += "Paging.ItemsPerPage=" + encodeURIComponent("" + paging_ItemsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJdeApNcMatches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJdeApNcMatches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetJdeNcMatchesResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetJdeNcMatchesResponseDto>;
        }));
    }

    protected processGetJdeApNcMatches(response: HttpResponseBase): Observable<GetJdeNcMatchesResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetJdeNcMatchesResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetJdeNcMatchesResponseDto>();
    }

    getJdeApSoMatches(filter_DateFrom?: Date | undefined, filter_DateTo?: Date | undefined, filter_Number?: string | null | undefined, filter_ReconciliationStatus?: ApReconciliationStatus | null | undefined, filter_InvoiceStatuses?: InvoiceStatus[] | null | undefined, filter_SupllierName?: string | null | undefined, filter_InvoiceType?: InvoiceType | null | undefined, filter_Tin?: string | null | undefined, filter_EsfRegistrationNumber?: string | null | undefined, filter_ManualReconciliationCommentTypes?: ManualReconciliationCommentType[] | null | undefined, sorting_SortColumn?: string | null | undefined, sorting_SortOrder?: SortingOrder | undefined, paging_CurrentPage?: number | undefined, paging_ItemsPerPage?: number | undefined): Observable<GetJdeSoMatchesResponseDto> {
        let url_ = this.baseUrl + "/api/Jde/get-jde-ap-so-matches?";
        if (filter_DateFrom === null)
            throw new Error("The parameter 'filter_DateFrom' cannot be null.");
        else if (filter_DateFrom !== undefined)
            url_ += "Filter.DateFrom=" + encodeURIComponent(filter_DateFrom ? "" + filter_DateFrom.toYearMonthDateString() : "") + "&";
        if (filter_DateTo === null)
            throw new Error("The parameter 'filter_DateTo' cannot be null.");
        else if (filter_DateTo !== undefined)
            url_ += "Filter.DateTo=" + encodeURIComponent(filter_DateTo ? "" + filter_DateTo.toYearMonthDateString() : "") + "&";
        if (filter_Number !== undefined && filter_Number !== null)
            url_ += "Filter.Number=" + encodeURIComponent("" + filter_Number) + "&";
        if (filter_ReconciliationStatus !== undefined && filter_ReconciliationStatus !== null)
            url_ += "Filter.ReconciliationStatus=" + encodeURIComponent("" + filter_ReconciliationStatus) + "&";
        if (filter_InvoiceStatuses !== undefined && filter_InvoiceStatuses !== null)
            filter_InvoiceStatuses && filter_InvoiceStatuses.forEach(item => { url_ += "Filter.InvoiceStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (filter_SupllierName !== undefined && filter_SupllierName !== null)
            url_ += "Filter.SupllierName=" + encodeURIComponent("" + filter_SupllierName) + "&";
        if (filter_InvoiceType !== undefined && filter_InvoiceType !== null)
            url_ += "Filter.InvoiceType=" + encodeURIComponent("" + filter_InvoiceType) + "&";
        if (filter_Tin !== undefined && filter_Tin !== null)
            url_ += "Filter.Tin=" + encodeURIComponent("" + filter_Tin) + "&";
        if (filter_EsfRegistrationNumber !== undefined && filter_EsfRegistrationNumber !== null)
            url_ += "Filter.EsfRegistrationNumber=" + encodeURIComponent("" + filter_EsfRegistrationNumber) + "&";
        if (filter_ManualReconciliationCommentTypes !== undefined && filter_ManualReconciliationCommentTypes !== null)
            filter_ManualReconciliationCommentTypes && filter_ManualReconciliationCommentTypes.forEach(item => { url_ += "Filter.ManualReconciliationCommentTypes=" + encodeURIComponent("" + item) + "&"; });
        if (sorting_SortColumn !== undefined && sorting_SortColumn !== null)
            url_ += "Sorting.SortColumn=" + encodeURIComponent("" + sorting_SortColumn) + "&";
        if (sorting_SortOrder === null)
            throw new Error("The parameter 'sorting_SortOrder' cannot be null.");
        else if (sorting_SortOrder !== undefined)
            url_ += "Sorting.SortOrder=" + encodeURIComponent("" + sorting_SortOrder) + "&";
        if (paging_CurrentPage === null)
            throw new Error("The parameter 'paging_CurrentPage' cannot be null.");
        else if (paging_CurrentPage !== undefined)
            url_ += "Paging.CurrentPage=" + encodeURIComponent("" + paging_CurrentPage) + "&";
        if (paging_ItemsPerPage === null)
            throw new Error("The parameter 'paging_ItemsPerPage' cannot be null.");
        else if (paging_ItemsPerPage !== undefined)
            url_ += "Paging.ItemsPerPage=" + encodeURIComponent("" + paging_ItemsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJdeApSoMatches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJdeApSoMatches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetJdeSoMatchesResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetJdeSoMatchesResponseDto>;
        }));
    }

    protected processGetJdeApSoMatches(response: HttpResponseBase): Observable<GetJdeSoMatchesResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetJdeSoMatchesResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetJdeSoMatchesResponseDto>();
    }

    getJdeApUndistributedMatches(filter_DateFrom?: Date | undefined, filter_DateTo?: Date | undefined, filter_Number?: string | null | undefined, filter_ReconciliationStatus?: ApReconciliationStatus | null | undefined, filter_InvoiceStatuses?: InvoiceStatus[] | null | undefined, filter_SupllierName?: string | null | undefined, filter_InvoiceType?: InvoiceType | null | undefined, filter_Tin?: string | null | undefined, filter_EsfRegistrationNumber?: string | null | undefined, filter_ManualReconciliationCommentTypes?: ManualReconciliationCommentType[] | null | undefined, sorting_SortColumn?: string | null | undefined, sorting_SortOrder?: SortingOrder | undefined, paging_CurrentPage?: number | undefined, paging_ItemsPerPage?: number | undefined): Observable<GetJdeUndistributedMatchesResponseDto> {
        let url_ = this.baseUrl + "/api/Jde/get-jde-ap-undistributed-matches?";
        if (filter_DateFrom === null)
            throw new Error("The parameter 'filter_DateFrom' cannot be null.");
        else if (filter_DateFrom !== undefined)
            url_ += "Filter.DateFrom=" + encodeURIComponent(filter_DateFrom ? "" + filter_DateFrom.toYearMonthDateString() : "") + "&";
        if (filter_DateTo === null)
            throw new Error("The parameter 'filter_DateTo' cannot be null.");
        else if (filter_DateTo !== undefined)
            url_ += "Filter.DateTo=" + encodeURIComponent(filter_DateTo ? "" + filter_DateTo.toYearMonthDateString() : "") + "&";
        if (filter_Number !== undefined && filter_Number !== null)
            url_ += "Filter.Number=" + encodeURIComponent("" + filter_Number) + "&";
        if (filter_ReconciliationStatus !== undefined && filter_ReconciliationStatus !== null)
            url_ += "Filter.ReconciliationStatus=" + encodeURIComponent("" + filter_ReconciliationStatus) + "&";
        if (filter_InvoiceStatuses !== undefined && filter_InvoiceStatuses !== null)
            filter_InvoiceStatuses && filter_InvoiceStatuses.forEach(item => { url_ += "Filter.InvoiceStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (filter_SupllierName !== undefined && filter_SupllierName !== null)
            url_ += "Filter.SupllierName=" + encodeURIComponent("" + filter_SupllierName) + "&";
        if (filter_InvoiceType !== undefined && filter_InvoiceType !== null)
            url_ += "Filter.InvoiceType=" + encodeURIComponent("" + filter_InvoiceType) + "&";
        if (filter_Tin !== undefined && filter_Tin !== null)
            url_ += "Filter.Tin=" + encodeURIComponent("" + filter_Tin) + "&";
        if (filter_EsfRegistrationNumber !== undefined && filter_EsfRegistrationNumber !== null)
            url_ += "Filter.EsfRegistrationNumber=" + encodeURIComponent("" + filter_EsfRegistrationNumber) + "&";
        if (filter_ManualReconciliationCommentTypes !== undefined && filter_ManualReconciliationCommentTypes !== null)
            filter_ManualReconciliationCommentTypes && filter_ManualReconciliationCommentTypes.forEach(item => { url_ += "Filter.ManualReconciliationCommentTypes=" + encodeURIComponent("" + item) + "&"; });
        if (sorting_SortColumn !== undefined && sorting_SortColumn !== null)
            url_ += "Sorting.SortColumn=" + encodeURIComponent("" + sorting_SortColumn) + "&";
        if (sorting_SortOrder === null)
            throw new Error("The parameter 'sorting_SortOrder' cannot be null.");
        else if (sorting_SortOrder !== undefined)
            url_ += "Sorting.SortOrder=" + encodeURIComponent("" + sorting_SortOrder) + "&";
        if (paging_CurrentPage === null)
            throw new Error("The parameter 'paging_CurrentPage' cannot be null.");
        else if (paging_CurrentPage !== undefined)
            url_ += "Paging.CurrentPage=" + encodeURIComponent("" + paging_CurrentPage) + "&";
        if (paging_ItemsPerPage === null)
            throw new Error("The parameter 'paging_ItemsPerPage' cannot be null.");
        else if (paging_ItemsPerPage !== undefined)
            url_ += "Paging.ItemsPerPage=" + encodeURIComponent("" + paging_ItemsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJdeApUndistributedMatches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJdeApUndistributedMatches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetJdeUndistributedMatchesResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetJdeUndistributedMatchesResponseDto>;
        }));
    }

    protected processGetJdeApUndistributedMatches(response: HttpResponseBase): Observable<GetJdeUndistributedMatchesResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetJdeUndistributedMatchesResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetJdeUndistributedMatchesResponseDto>();
    }

    getSuppliersForAr(): Observable<GetSuppliersResultDto[]> {
        let url_ = this.baseUrl + "/api/Jde/get-suppliers-ar";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSuppliersForAr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSuppliersForAr(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSuppliersResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSuppliersResultDto[]>;
        }));
    }

    protected processGetSuppliersForAr(response: HttpResponseBase): Observable<GetSuppliersResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetSuppliersResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSuppliersResultDto[]>();
    }

    getSuppliersForApPo(): Observable<GetSuppliersResultDto[]> {
        let url_ = this.baseUrl + "/api/Jde/get-suppliers-ap-po";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSuppliersForApPo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSuppliersForApPo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSuppliersResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSuppliersResultDto[]>;
        }));
    }

    protected processGetSuppliersForApPo(response: HttpResponseBase): Observable<GetSuppliersResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetSuppliersResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSuppliersResultDto[]>();
    }

    getSuppliersForApSo(): Observable<GetSuppliersResultDto[]> {
        let url_ = this.baseUrl + "/api/Jde/get-suppliers-ap-so";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSuppliersForApSo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSuppliersForApSo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSuppliersResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSuppliersResultDto[]>;
        }));
    }

    protected processGetSuppliersForApSo(response: HttpResponseBase): Observable<GetSuppliersResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetSuppliersResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSuppliersResultDto[]>();
    }

    getSuppliersForApNcOc(): Observable<GetSuppliersResultDto[]> {
        let url_ = this.baseUrl + "/api/Jde/get-suppliers-ap-ncoc";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSuppliersForApNcOc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSuppliersForApNcOc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSuppliersResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSuppliersResultDto[]>;
        }));
    }

    protected processGetSuppliersForApNcOc(response: HttpResponseBase): Observable<GetSuppliersResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetSuppliersResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSuppliersResultDto[]>();
    }

    getSuppliersForApUndistributed(): Observable<GetSuppliersResultDto[]> {
        let url_ = this.baseUrl + "/api/Jde/get-suppliers-ap-undistributed";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSuppliersForApUndistributed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSuppliersForApUndistributed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSuppliersResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSuppliersResultDto[]>;
        }));
    }

    protected processGetSuppliersForApUndistributed(response: HttpResponseBase): Observable<GetSuppliersResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetSuppliersResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSuppliersResultDto[]>();
    }

    getArLastUpdates(): Observable<GetArLastUpdateDatesDto> {
        let url_ = this.baseUrl + "/api/Jde/get-ar-last-dates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetArLastUpdates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetArLastUpdates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetArLastUpdateDatesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetArLastUpdateDatesDto>;
        }));
    }

    protected processGetArLastUpdates(response: HttpResponseBase): Observable<GetArLastUpdateDatesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetArLastUpdateDatesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetArLastUpdateDatesDto>();
    }

    getApLastUpdates(): Observable<GetApLastUpdateDatesDto> {
        let url_ = this.baseUrl + "/api/Jde/get-ap-last-dates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApLastUpdates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApLastUpdates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetApLastUpdateDatesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetApLastUpdateDatesDto>;
        }));
    }

    protected processGetApLastUpdates(response: HttpResponseBase): Observable<GetApLastUpdateDatesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetApLastUpdateDatesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetApLastUpdateDatesDto>();
    }

    getJdeApNcMatchesReport(filter_DateFrom?: Date | undefined, filter_DateTo?: Date | undefined, filter_Number?: string | null | undefined, filter_ReconciliationStatus?: ApReconciliationStatus | null | undefined, filter_InvoiceStatuses?: InvoiceStatus[] | null | undefined, filter_SupllierName?: string | null | undefined, filter_InvoiceType?: InvoiceType | null | undefined, filter_Tin?: string | null | undefined, filter_EsfRegistrationNumber?: string | null | undefined, filter_ManualReconciliationCommentTypes?: ManualReconciliationCommentType[] | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Jde/get-jde-ap-nc-matches-report?";
        if (filter_DateFrom === null)
            throw new Error("The parameter 'filter_DateFrom' cannot be null.");
        else if (filter_DateFrom !== undefined)
            url_ += "Filter.DateFrom=" + encodeURIComponent(filter_DateFrom ? "" + filter_DateFrom.toYearMonthDateString() : "") + "&";
        if (filter_DateTo === null)
            throw new Error("The parameter 'filter_DateTo' cannot be null.");
        else if (filter_DateTo !== undefined)
            url_ += "Filter.DateTo=" + encodeURIComponent(filter_DateTo ? "" + filter_DateTo.toYearMonthDateString() : "") + "&";
        if (filter_Number !== undefined && filter_Number !== null)
            url_ += "Filter.Number=" + encodeURIComponent("" + filter_Number) + "&";
        if (filter_ReconciliationStatus !== undefined && filter_ReconciliationStatus !== null)
            url_ += "Filter.ReconciliationStatus=" + encodeURIComponent("" + filter_ReconciliationStatus) + "&";
        if (filter_InvoiceStatuses !== undefined && filter_InvoiceStatuses !== null)
            filter_InvoiceStatuses && filter_InvoiceStatuses.forEach(item => { url_ += "Filter.InvoiceStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (filter_SupllierName !== undefined && filter_SupllierName !== null)
            url_ += "Filter.SupllierName=" + encodeURIComponent("" + filter_SupllierName) + "&";
        if (filter_InvoiceType !== undefined && filter_InvoiceType !== null)
            url_ += "Filter.InvoiceType=" + encodeURIComponent("" + filter_InvoiceType) + "&";
        if (filter_Tin !== undefined && filter_Tin !== null)
            url_ += "Filter.Tin=" + encodeURIComponent("" + filter_Tin) + "&";
        if (filter_EsfRegistrationNumber !== undefined && filter_EsfRegistrationNumber !== null)
            url_ += "Filter.EsfRegistrationNumber=" + encodeURIComponent("" + filter_EsfRegistrationNumber) + "&";
        if (filter_ManualReconciliationCommentTypes !== undefined && filter_ManualReconciliationCommentTypes !== null)
            filter_ManualReconciliationCommentTypes && filter_ManualReconciliationCommentTypes.forEach(item => { url_ += "Filter.ManualReconciliationCommentTypes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJdeApNcMatchesReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJdeApNcMatchesReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetJdeApNcMatchesReport(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>();
    }

    getJdeApPoMatchesReport(filter_DateFrom?: Date | undefined, filter_DateTo?: Date | undefined, filter_Number?: string | null | undefined, filter_ReconciliationStatus?: ApReconciliationStatus | null | undefined, filter_InvoiceStatuses?: InvoiceStatus[] | null | undefined, filter_SupllierName?: string | null | undefined, filter_InvoiceType?: InvoiceType | null | undefined, filter_Tin?: string | null | undefined, filter_EsfRegistrationNumber?: string | null | undefined, filter_ManualReconciliationCommentTypes?: ManualReconciliationCommentType[] | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Jde/get-jde-ap-po-matches-report?";
        if (filter_DateFrom === null)
            throw new Error("The parameter 'filter_DateFrom' cannot be null.");
        else if (filter_DateFrom !== undefined)
            url_ += "Filter.DateFrom=" + encodeURIComponent(filter_DateFrom ? "" + filter_DateFrom.toYearMonthDateString() : "") + "&";
        if (filter_DateTo === null)
            throw new Error("The parameter 'filter_DateTo' cannot be null.");
        else if (filter_DateTo !== undefined)
            url_ += "Filter.DateTo=" + encodeURIComponent(filter_DateTo ? "" + filter_DateTo.toYearMonthDateString() : "") + "&";
        if (filter_Number !== undefined && filter_Number !== null)
            url_ += "Filter.Number=" + encodeURIComponent("" + filter_Number) + "&";
        if (filter_ReconciliationStatus !== undefined && filter_ReconciliationStatus !== null)
            url_ += "Filter.ReconciliationStatus=" + encodeURIComponent("" + filter_ReconciliationStatus) + "&";
        if (filter_InvoiceStatuses !== undefined && filter_InvoiceStatuses !== null)
            filter_InvoiceStatuses && filter_InvoiceStatuses.forEach(item => { url_ += "Filter.InvoiceStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (filter_SupllierName !== undefined && filter_SupllierName !== null)
            url_ += "Filter.SupllierName=" + encodeURIComponent("" + filter_SupllierName) + "&";
        if (filter_InvoiceType !== undefined && filter_InvoiceType !== null)
            url_ += "Filter.InvoiceType=" + encodeURIComponent("" + filter_InvoiceType) + "&";
        if (filter_Tin !== undefined && filter_Tin !== null)
            url_ += "Filter.Tin=" + encodeURIComponent("" + filter_Tin) + "&";
        if (filter_EsfRegistrationNumber !== undefined && filter_EsfRegistrationNumber !== null)
            url_ += "Filter.EsfRegistrationNumber=" + encodeURIComponent("" + filter_EsfRegistrationNumber) + "&";
        if (filter_ManualReconciliationCommentTypes !== undefined && filter_ManualReconciliationCommentTypes !== null)
            filter_ManualReconciliationCommentTypes && filter_ManualReconciliationCommentTypes.forEach(item => { url_ += "Filter.ManualReconciliationCommentTypes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJdeApPoMatchesReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJdeApPoMatchesReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetJdeApPoMatchesReport(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>();
    }

    getJdeApSoMatchesReport(filter_DateFrom?: Date | undefined, filter_DateTo?: Date | undefined, filter_Number?: string | null | undefined, filter_ReconciliationStatus?: ApReconciliationStatus | null | undefined, filter_InvoiceStatuses?: InvoiceStatus[] | null | undefined, filter_SupllierName?: string | null | undefined, filter_InvoiceType?: InvoiceType | null | undefined, filter_Tin?: string | null | undefined, filter_EsfRegistrationNumber?: string | null | undefined, filter_ManualReconciliationCommentTypes?: ManualReconciliationCommentType[] | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Jde/get-jde-ap-so-matches-report?";
        if (filter_DateFrom === null)
            throw new Error("The parameter 'filter_DateFrom' cannot be null.");
        else if (filter_DateFrom !== undefined)
            url_ += "Filter.DateFrom=" + encodeURIComponent(filter_DateFrom ? "" + filter_DateFrom.toYearMonthDateString() : "") + "&";
        if (filter_DateTo === null)
            throw new Error("The parameter 'filter_DateTo' cannot be null.");
        else if (filter_DateTo !== undefined)
            url_ += "Filter.DateTo=" + encodeURIComponent(filter_DateTo ? "" + filter_DateTo.toYearMonthDateString() : "") + "&";
        if (filter_Number !== undefined && filter_Number !== null)
            url_ += "Filter.Number=" + encodeURIComponent("" + filter_Number) + "&";
        if (filter_ReconciliationStatus !== undefined && filter_ReconciliationStatus !== null)
            url_ += "Filter.ReconciliationStatus=" + encodeURIComponent("" + filter_ReconciliationStatus) + "&";
        if (filter_InvoiceStatuses !== undefined && filter_InvoiceStatuses !== null)
            filter_InvoiceStatuses && filter_InvoiceStatuses.forEach(item => { url_ += "Filter.InvoiceStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (filter_SupllierName !== undefined && filter_SupllierName !== null)
            url_ += "Filter.SupllierName=" + encodeURIComponent("" + filter_SupllierName) + "&";
        if (filter_InvoiceType !== undefined && filter_InvoiceType !== null)
            url_ += "Filter.InvoiceType=" + encodeURIComponent("" + filter_InvoiceType) + "&";
        if (filter_Tin !== undefined && filter_Tin !== null)
            url_ += "Filter.Tin=" + encodeURIComponent("" + filter_Tin) + "&";
        if (filter_EsfRegistrationNumber !== undefined && filter_EsfRegistrationNumber !== null)
            url_ += "Filter.EsfRegistrationNumber=" + encodeURIComponent("" + filter_EsfRegistrationNumber) + "&";
        if (filter_ManualReconciliationCommentTypes !== undefined && filter_ManualReconciliationCommentTypes !== null)
            filter_ManualReconciliationCommentTypes && filter_ManualReconciliationCommentTypes.forEach(item => { url_ += "Filter.ManualReconciliationCommentTypes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJdeApSoMatchesReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJdeApSoMatchesReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetJdeApSoMatchesReport(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>();
    }

    getJdeApUndistributedMatchesReport(filter_DateFrom?: Date | undefined, filter_DateTo?: Date | undefined, filter_Number?: string | null | undefined, filter_ReconciliationStatus?: ApReconciliationStatus | null | undefined, filter_InvoiceStatuses?: InvoiceStatus[] | null | undefined, filter_SupllierName?: string | null | undefined, filter_InvoiceType?: InvoiceType | null | undefined, filter_Tin?: string | null | undefined, filter_EsfRegistrationNumber?: string | null | undefined, filter_ManualReconciliationCommentTypes?: ManualReconciliationCommentType[] | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Jde/get-jde-ap-undistributed-matches-report?";
        if (filter_DateFrom === null)
            throw new Error("The parameter 'filter_DateFrom' cannot be null.");
        else if (filter_DateFrom !== undefined)
            url_ += "Filter.DateFrom=" + encodeURIComponent(filter_DateFrom ? "" + filter_DateFrom.toYearMonthDateString() : "") + "&";
        if (filter_DateTo === null)
            throw new Error("The parameter 'filter_DateTo' cannot be null.");
        else if (filter_DateTo !== undefined)
            url_ += "Filter.DateTo=" + encodeURIComponent(filter_DateTo ? "" + filter_DateTo.toYearMonthDateString() : "") + "&";
        if (filter_Number !== undefined && filter_Number !== null)
            url_ += "Filter.Number=" + encodeURIComponent("" + filter_Number) + "&";
        if (filter_ReconciliationStatus !== undefined && filter_ReconciliationStatus !== null)
            url_ += "Filter.ReconciliationStatus=" + encodeURIComponent("" + filter_ReconciliationStatus) + "&";
        if (filter_InvoiceStatuses !== undefined && filter_InvoiceStatuses !== null)
            filter_InvoiceStatuses && filter_InvoiceStatuses.forEach(item => { url_ += "Filter.InvoiceStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (filter_SupllierName !== undefined && filter_SupllierName !== null)
            url_ += "Filter.SupllierName=" + encodeURIComponent("" + filter_SupllierName) + "&";
        if (filter_InvoiceType !== undefined && filter_InvoiceType !== null)
            url_ += "Filter.InvoiceType=" + encodeURIComponent("" + filter_InvoiceType) + "&";
        if (filter_Tin !== undefined && filter_Tin !== null)
            url_ += "Filter.Tin=" + encodeURIComponent("" + filter_Tin) + "&";
        if (filter_EsfRegistrationNumber !== undefined && filter_EsfRegistrationNumber !== null)
            url_ += "Filter.EsfRegistrationNumber=" + encodeURIComponent("" + filter_EsfRegistrationNumber) + "&";
        if (filter_ManualReconciliationCommentTypes !== undefined && filter_ManualReconciliationCommentTypes !== null)
            filter_ManualReconciliationCommentTypes && filter_ManualReconciliationCommentTypes.forEach(item => { url_ += "Filter.ManualReconciliationCommentTypes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJdeApUndistributedMatchesReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJdeApUndistributedMatchesReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetJdeApUndistributedMatchesReport(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>();
    }

    getJdeArMatchesReport(filter_DateFrom?: Date | undefined, filter_DateTo?: Date | undefined, filter_Number?: string | null | undefined, filter_ReconciliationStatus?: ReconciliationStatus | null | undefined, filter_CustomerName?: string | null | undefined, filter_Tin?: string | null | undefined, filter_RegistrationNumber?: string | null | undefined, filter_OwnInvoices?: boolean | undefined, filter_IsDrafts?: boolean | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Jde/get-jde-ar-matches-report?";
        if (filter_DateFrom === null)
            throw new Error("The parameter 'filter_DateFrom' cannot be null.");
        else if (filter_DateFrom !== undefined)
            url_ += "Filter.DateFrom=" + encodeURIComponent(filter_DateFrom ? "" + filter_DateFrom.toYearMonthDateString() : "") + "&";
        if (filter_DateTo === null)
            throw new Error("The parameter 'filter_DateTo' cannot be null.");
        else if (filter_DateTo !== undefined)
            url_ += "Filter.DateTo=" + encodeURIComponent(filter_DateTo ? "" + filter_DateTo.toYearMonthDateString() : "") + "&";
        if (filter_Number !== undefined && filter_Number !== null)
            url_ += "Filter.Number=" + encodeURIComponent("" + filter_Number) + "&";
        if (filter_ReconciliationStatus !== undefined && filter_ReconciliationStatus !== null)
            url_ += "Filter.ReconciliationStatus=" + encodeURIComponent("" + filter_ReconciliationStatus) + "&";
        if (filter_CustomerName !== undefined && filter_CustomerName !== null)
            url_ += "Filter.CustomerName=" + encodeURIComponent("" + filter_CustomerName) + "&";
        if (filter_Tin !== undefined && filter_Tin !== null)
            url_ += "Filter.Tin=" + encodeURIComponent("" + filter_Tin) + "&";
        if (filter_RegistrationNumber !== undefined && filter_RegistrationNumber !== null)
            url_ += "Filter.RegistrationNumber=" + encodeURIComponent("" + filter_RegistrationNumber) + "&";
        if (filter_OwnInvoices === null)
            throw new Error("The parameter 'filter_OwnInvoices' cannot be null.");
        else if (filter_OwnInvoices !== undefined)
            url_ += "Filter.OwnInvoices=" + encodeURIComponent("" + filter_OwnInvoices) + "&";
        if (filter_IsDrafts === null)
            throw new Error("The parameter 'filter_IsDrafts' cannot be null.");
        else if (filter_IsDrafts !== undefined)
            url_ += "Filter.IsDrafts=" + encodeURIComponent("" + filter_IsDrafts) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJdeArMatchesReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJdeArMatchesReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetJdeArMatchesReport(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>();
    }

    getInvoiceReport(id?: number | undefined, documentNumber?: string | null | undefined, documentType?: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Jde/get-invoice-report?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (documentNumber !== undefined && documentNumber !== null)
            url_ += "documentNumber=" + encodeURIComponent("" + documentNumber) + "&";
        if (documentType !== undefined && documentType !== null)
            url_ += "documentType=" + encodeURIComponent("" + documentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetInvoiceReport(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>();
    }

    changeManualReconciliationComment(dto: ChangeManualReconciliationCommentDto[]): Observable<ChangeManualReconciliationCommentResponseDto[]> {
        let url_ = this.baseUrl + "/api/Jde/manual-reconciliation-comment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto.map(item => item.toJSON()));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeManualReconciliationComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeManualReconciliationComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChangeManualReconciliationCommentResponseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChangeManualReconciliationCommentResponseDto[]>;
        }));
    }

    protected processChangeManualReconciliationComment(response: HttpResponseBase): Observable<ChangeManualReconciliationCommentResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChangeManualReconciliationCommentResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChangeManualReconciliationCommentResponseDto[]>();
    }
}

@Injectable()
export class SntClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:50852";
    }

    /**
     * @param filter_DateFrom (optional) Дата СНТ "с" (yyyy-MM-dd format)
     * @param filter_DateTo (optional) Дата СНТ "по" (yyyy-MM-dd format)
     * @param filter_Type (optional) Тип
     * @param filter_ImportType (optional) Тип импорта
     * @param filter_ExportType (optional) Тип экспорта
     * @param filter_TransferType (optional) Тип транспортировки
     * @param filter_Statuses (optional) Статусы
     * @param filter_LastUpdateDateFromUtc (optional) Дата обновления СНТ "c" (yyyy-MM-ddT00:00Z format)
     * @param filter_LastUpdateDateToUtc (optional) Дата обновления СНТ "по" yyyy-MM-ddT00:00Z format)
     * @param filter_SellerTin (optional) ИИН/БИН поставщика/отправителя
     * @param filter_SellerName (optional) Имя поставщика/отправителя
     * @param filter_CustomerTin (optional) ИИН/БИН получателя
     * @param filter_Number (optional) Номер СНТ из учетной системы
     * @param filter_RegistrationNumber (optional) Регистрационный номер СНТ
     * @param filter_SellerStoreId (optional) Id склада отправителя
     * @param filter_CustomerStoreId (optional) Id склада получателя
     * @param filter_Category (optional) 
     * @param sorting_SortColumn (optional) 
     * @param sorting_SortOrder (optional) 
     * @param paging_CurrentPage (optional) 
     * @param paging_ItemsPerPage (optional) 
     */
    getSntList(filter_DateFrom?: Date | null | undefined, filter_DateTo?: Date | null | undefined, filter_Type?: SntFilterType | null | undefined, filter_ImportType?: SntImportType | null | undefined, filter_ExportType?: SntExportType | null | undefined, filter_TransferType?: SntTransferType | null | undefined, filter_Statuses?: SntStatus[] | null | undefined, filter_LastUpdateDateFromUtc?: Date | null | undefined, filter_LastUpdateDateToUtc?: Date | null | undefined, filter_SellerTin?: string | null | undefined, filter_SellerName?: string | null | undefined, filter_CustomerTin?: string | null | undefined, filter_Number?: string | null | undefined, filter_RegistrationNumber?: string | null | undefined, filter_SellerStoreId?: number | null | undefined, filter_CustomerStoreId?: number | null | undefined, filter_Category?: SntCategory | null | undefined, sorting_SortColumn?: string | null | undefined, sorting_SortOrder?: SortingOrder | undefined, paging_CurrentPage?: number | undefined, paging_ItemsPerPage?: number | undefined): Observable<SntListResponseDto> {
        let url_ = this.baseUrl + "/api/Snt/get-snt-list?";
        if (filter_DateFrom !== undefined && filter_DateFrom !== null)
            url_ += "Filter.DateFrom=" + encodeURIComponent(filter_DateFrom ? "" + filter_DateFrom.toYearMonthDateString() : "") + "&";
        if (filter_DateTo !== undefined && filter_DateTo !== null)
            url_ += "Filter.DateTo=" + encodeURIComponent(filter_DateTo ? "" + filter_DateTo.toYearMonthDateString() : "") + "&";
        if (filter_Type !== undefined && filter_Type !== null)
            url_ += "Filter.Type=" + encodeURIComponent("" + filter_Type) + "&";
        if (filter_ImportType !== undefined && filter_ImportType !== null)
            url_ += "Filter.ImportType=" + encodeURIComponent("" + filter_ImportType) + "&";
        if (filter_ExportType !== undefined && filter_ExportType !== null)
            url_ += "Filter.ExportType=" + encodeURIComponent("" + filter_ExportType) + "&";
        if (filter_TransferType !== undefined && filter_TransferType !== null)
            url_ += "Filter.TransferType=" + encodeURIComponent("" + filter_TransferType) + "&";
        if (filter_Statuses !== undefined && filter_Statuses !== null)
            filter_Statuses && filter_Statuses.forEach(item => { url_ += "Filter.Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (filter_LastUpdateDateFromUtc !== undefined && filter_LastUpdateDateFromUtc !== null)
            url_ += "Filter.LastUpdateDateFromUtc=" + encodeURIComponent(filter_LastUpdateDateFromUtc ? "" + filter_LastUpdateDateFromUtc.toYearMonthDateString() : "") + "&";
        if (filter_LastUpdateDateToUtc !== undefined && filter_LastUpdateDateToUtc !== null)
            url_ += "Filter.LastUpdateDateToUtc=" + encodeURIComponent(filter_LastUpdateDateToUtc ? "" + filter_LastUpdateDateToUtc.toYearMonthDateString() : "") + "&";
        if (filter_SellerTin !== undefined && filter_SellerTin !== null)
            url_ += "Filter.SellerTin=" + encodeURIComponent("" + filter_SellerTin) + "&";
        if (filter_SellerName !== undefined && filter_SellerName !== null)
            url_ += "Filter.SellerName=" + encodeURIComponent("" + filter_SellerName) + "&";
        if (filter_CustomerTin !== undefined && filter_CustomerTin !== null)
            url_ += "Filter.CustomerTin=" + encodeURIComponent("" + filter_CustomerTin) + "&";
        if (filter_Number !== undefined && filter_Number !== null)
            url_ += "Filter.Number=" + encodeURIComponent("" + filter_Number) + "&";
        if (filter_RegistrationNumber !== undefined && filter_RegistrationNumber !== null)
            url_ += "Filter.RegistrationNumber=" + encodeURIComponent("" + filter_RegistrationNumber) + "&";
        if (filter_SellerStoreId !== undefined && filter_SellerStoreId !== null)
            url_ += "Filter.SellerStoreId=" + encodeURIComponent("" + filter_SellerStoreId) + "&";
        if (filter_CustomerStoreId !== undefined && filter_CustomerStoreId !== null)
            url_ += "Filter.CustomerStoreId=" + encodeURIComponent("" + filter_CustomerStoreId) + "&";
        if (filter_Category !== undefined && filter_Category !== null)
            url_ += "Filter.Category=" + encodeURIComponent("" + filter_Category) + "&";
        if (sorting_SortColumn !== undefined && sorting_SortColumn !== null)
            url_ += "Sorting.SortColumn=" + encodeURIComponent("" + sorting_SortColumn) + "&";
        if (sorting_SortOrder === null)
            throw new Error("The parameter 'sorting_SortOrder' cannot be null.");
        else if (sorting_SortOrder !== undefined)
            url_ += "Sorting.SortOrder=" + encodeURIComponent("" + sorting_SortOrder) + "&";
        if (paging_CurrentPage === null)
            throw new Error("The parameter 'paging_CurrentPage' cannot be null.");
        else if (paging_CurrentPage !== undefined)
            url_ += "Paging.CurrentPage=" + encodeURIComponent("" + paging_CurrentPage) + "&";
        if (paging_ItemsPerPage === null)
            throw new Error("The parameter 'paging_ItemsPerPage' cannot be null.");
        else if (paging_ItemsPerPage !== undefined)
            url_ += "Paging.ItemsPerPage=" + encodeURIComponent("" + paging_ItemsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSntList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSntList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SntListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SntListResponseDto>;
        }));
    }

    protected processGetSntList(response: HttpResponseBase): Observable<SntListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SntListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SntListResponseDto>();
    }

    getSntProudctBySntId(sntId?: number | undefined, invoiceDirection?: InvoiceDirection | undefined): Observable<GetSntProductBySntIdResponseDto> {
        let url_ = this.baseUrl + "/api/Snt/get-snt-product-by-sntid?";
        if (sntId === null)
            throw new Error("The parameter 'sntId' cannot be null.");
        else if (sntId !== undefined)
            url_ += "SntId=" + encodeURIComponent("" + sntId) + "&";
        if (invoiceDirection === null)
            throw new Error("The parameter 'invoiceDirection' cannot be null.");
        else if (invoiceDirection !== undefined)
            url_ += "InvoiceDirection=" + encodeURIComponent("" + invoiceDirection) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSntProudctBySntId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSntProudctBySntId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSntProductBySntIdResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSntProductBySntIdResponseDto>;
        }));
    }

    protected processGetSntProudctBySntId(response: HttpResponseBase): Observable<GetSntProductBySntIdResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSntProductBySntIdResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSntProductBySntIdResponseDto>();
    }

    /**
     * Get all Snt
     * @param filter_DateFrom (optional) Дата СНТ "с" (yyyy-MM-dd format)
     * @param filter_DateTo (optional) Дата СНТ "по" (yyyy-MM-dd format)
     * @param filter_Type (optional) Тип
     * @param filter_ImportType (optional) Тип импорта
     * @param filter_ExportType (optional) Тип экспорта
     * @param filter_TransferType (optional) Тип транспортировки
     * @param filter_Statuses (optional) Статусы
     * @param filter_LastUpdateDateFromUtc (optional) Дата обновления СНТ "c" (yyyy-MM-ddT00:00Z format)
     * @param filter_LastUpdateDateToUtc (optional) Дата обновления СНТ "по" yyyy-MM-ddT00:00Z format)
     * @param filter_SellerTin (optional) ИИН/БИН поставщика/отправителя
     * @param filter_SellerName (optional) Имя поставщика/отправителя
     * @param filter_CustomerTin (optional) ИИН/БИН получателя
     * @param filter_Number (optional) Номер СНТ из учетной системы
     * @param filter_RegistrationNumber (optional) Регистрационный номер СНТ
     * @param filter_SellerStoreId (optional) Id склада отправителя
     * @param filter_CustomerStoreId (optional) Id склада получателя
     * @param filter_Category (optional) 
     * @param sorting_SortColumn (optional) 
     * @param sorting_SortOrder (optional) 
     * @param paging_CurrentPage (optional) 
     * @param paging_ItemsPerPage (optional) 
     */
    getAll(filter_DateFrom?: Date | null | undefined, filter_DateTo?: Date | null | undefined, filter_Type?: SntFilterType | null | undefined, filter_ImportType?: SntImportType | null | undefined, filter_ExportType?: SntExportType | null | undefined, filter_TransferType?: SntTransferType | null | undefined, filter_Statuses?: SntStatus[] | null | undefined, filter_LastUpdateDateFromUtc?: Date | null | undefined, filter_LastUpdateDateToUtc?: Date | null | undefined, filter_SellerTin?: string | null | undefined, filter_SellerName?: string | null | undefined, filter_CustomerTin?: string | null | undefined, filter_Number?: string | null | undefined, filter_RegistrationNumber?: string | null | undefined, filter_SellerStoreId?: number | null | undefined, filter_CustomerStoreId?: number | null | undefined, filter_Category?: SntCategory | null | undefined, sorting_SortColumn?: string | null | undefined, sorting_SortOrder?: SortingOrder | undefined, paging_CurrentPage?: number | undefined, paging_ItemsPerPage?: number | undefined): Observable<SntListResponseDto> {
        let url_ = this.baseUrl + "/api/Snt?";
        if (filter_DateFrom !== undefined && filter_DateFrom !== null)
            url_ += "Filter.DateFrom=" + encodeURIComponent(filter_DateFrom ? "" + filter_DateFrom.toYearMonthDateString() : "") + "&";
        if (filter_DateTo !== undefined && filter_DateTo !== null)
            url_ += "Filter.DateTo=" + encodeURIComponent(filter_DateTo ? "" + filter_DateTo.toYearMonthDateString() : "") + "&";
        if (filter_Type !== undefined && filter_Type !== null)
            url_ += "Filter.Type=" + encodeURIComponent("" + filter_Type) + "&";
        if (filter_ImportType !== undefined && filter_ImportType !== null)
            url_ += "Filter.ImportType=" + encodeURIComponent("" + filter_ImportType) + "&";
        if (filter_ExportType !== undefined && filter_ExportType !== null)
            url_ += "Filter.ExportType=" + encodeURIComponent("" + filter_ExportType) + "&";
        if (filter_TransferType !== undefined && filter_TransferType !== null)
            url_ += "Filter.TransferType=" + encodeURIComponent("" + filter_TransferType) + "&";
        if (filter_Statuses !== undefined && filter_Statuses !== null)
            filter_Statuses && filter_Statuses.forEach(item => { url_ += "Filter.Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (filter_LastUpdateDateFromUtc !== undefined && filter_LastUpdateDateFromUtc !== null)
            url_ += "Filter.LastUpdateDateFromUtc=" + encodeURIComponent(filter_LastUpdateDateFromUtc ? "" + filter_LastUpdateDateFromUtc.toYearMonthDateString() : "") + "&";
        if (filter_LastUpdateDateToUtc !== undefined && filter_LastUpdateDateToUtc !== null)
            url_ += "Filter.LastUpdateDateToUtc=" + encodeURIComponent(filter_LastUpdateDateToUtc ? "" + filter_LastUpdateDateToUtc.toYearMonthDateString() : "") + "&";
        if (filter_SellerTin !== undefined && filter_SellerTin !== null)
            url_ += "Filter.SellerTin=" + encodeURIComponent("" + filter_SellerTin) + "&";
        if (filter_SellerName !== undefined && filter_SellerName !== null)
            url_ += "Filter.SellerName=" + encodeURIComponent("" + filter_SellerName) + "&";
        if (filter_CustomerTin !== undefined && filter_CustomerTin !== null)
            url_ += "Filter.CustomerTin=" + encodeURIComponent("" + filter_CustomerTin) + "&";
        if (filter_Number !== undefined && filter_Number !== null)
            url_ += "Filter.Number=" + encodeURIComponent("" + filter_Number) + "&";
        if (filter_RegistrationNumber !== undefined && filter_RegistrationNumber !== null)
            url_ += "Filter.RegistrationNumber=" + encodeURIComponent("" + filter_RegistrationNumber) + "&";
        if (filter_SellerStoreId !== undefined && filter_SellerStoreId !== null)
            url_ += "Filter.SellerStoreId=" + encodeURIComponent("" + filter_SellerStoreId) + "&";
        if (filter_CustomerStoreId !== undefined && filter_CustomerStoreId !== null)
            url_ += "Filter.CustomerStoreId=" + encodeURIComponent("" + filter_CustomerStoreId) + "&";
        if (filter_Category !== undefined && filter_Category !== null)
            url_ += "Filter.Category=" + encodeURIComponent("" + filter_Category) + "&";
        if (sorting_SortColumn !== undefined && sorting_SortColumn !== null)
            url_ += "Sorting.SortColumn=" + encodeURIComponent("" + sorting_SortColumn) + "&";
        if (sorting_SortOrder === null)
            throw new Error("The parameter 'sorting_SortOrder' cannot be null.");
        else if (sorting_SortOrder !== undefined)
            url_ += "Sorting.SortOrder=" + encodeURIComponent("" + sorting_SortOrder) + "&";
        if (paging_CurrentPage === null)
            throw new Error("The parameter 'paging_CurrentPage' cannot be null.");
        else if (paging_CurrentPage !== undefined)
            url_ += "Paging.CurrentPage=" + encodeURIComponent("" + paging_CurrentPage) + "&";
        if (paging_ItemsPerPage === null)
            throw new Error("The parameter 'paging_ItemsPerPage' cannot be null.");
        else if (paging_ItemsPerPage !== undefined)
            url_ += "Paging.ItemsPerPage=" + encodeURIComponent("" + paging_ItemsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SntListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SntListResponseDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SntListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SntListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SntListResponseDto>();
    }

    /**
     * Get Snt full information
     */
    get(id: number): Observable<SntFullDto> {
        let url_ = this.baseUrl + "/api/Snt/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SntFullDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SntFullDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SntFullDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SntFullDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SntFullDto>();
    }

    /**
     * Get SNT report by filters
     * @param dateFrom (optional) Дата СНТ "с" (yyyy-MM-dd format)
     * @param dateTo (optional) Дата СНТ "по" (yyyy-MM-dd format)
     * @param type (optional) Тип
     * @param importType (optional) Тип импорта
     * @param exportType (optional) Тип экспорта
     * @param transferType (optional) Тип транспортировки
     * @param statuses (optional) Статусы
     * @param lastUpdateDateFromUtc (optional) Дата обновления СНТ "c" (yyyy-MM-ddT00:00Z format)
     * @param lastUpdateDateToUtc (optional) Дата обновления СНТ "по" yyyy-MM-ddT00:00Z format)
     * @param sellerTin (optional) ИИН/БИН поставщика/отправителя
     * @param sellerName (optional) Имя поставщика/отправителя
     * @param customerTin (optional) ИИН/БИН получателя
     * @param number (optional) Номер СНТ из учетной системы
     * @param registrationNumber (optional) Регистрационный номер СНТ
     * @param sellerStoreId (optional) Id склада отправителя
     * @param customerStoreId (optional) Id склада получателя
     * @param category (optional) 
     */
    getSntListReport(dateFrom?: Date | null | undefined, dateTo?: Date | null | undefined, type?: SntFilterType | null | undefined, importType?: SntImportType | null | undefined, exportType?: SntExportType | null | undefined, transferType?: SntTransferType | null | undefined, statuses?: SntStatus[] | null | undefined, lastUpdateDateFromUtc?: Date | null | undefined, lastUpdateDateToUtc?: Date | null | undefined, sellerTin?: string | null | undefined, sellerName?: string | null | undefined, customerTin?: string | null | undefined, number?: string | null | undefined, registrationNumber?: string | null | undefined, sellerStoreId?: number | null | undefined, customerStoreId?: number | null | undefined, category?: SntCategory | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Snt/get-snt-list-report?";
        if (dateFrom !== undefined && dateFrom !== null)
            url_ += "DateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toYearMonthDateString() : "") + "&";
        if (dateTo !== undefined && dateTo !== null)
            url_ += "DateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toYearMonthDateString() : "") + "&";
        if (type !== undefined && type !== null)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (importType !== undefined && importType !== null)
            url_ += "ImportType=" + encodeURIComponent("" + importType) + "&";
        if (exportType !== undefined && exportType !== null)
            url_ += "ExportType=" + encodeURIComponent("" + exportType) + "&";
        if (transferType !== undefined && transferType !== null)
            url_ += "TransferType=" + encodeURIComponent("" + transferType) + "&";
        if (statuses !== undefined && statuses !== null)
            statuses && statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (lastUpdateDateFromUtc !== undefined && lastUpdateDateFromUtc !== null)
            url_ += "LastUpdateDateFromUtc=" + encodeURIComponent(lastUpdateDateFromUtc ? "" + lastUpdateDateFromUtc.toYearMonthDateString() : "") + "&";
        if (lastUpdateDateToUtc !== undefined && lastUpdateDateToUtc !== null)
            url_ += "LastUpdateDateToUtc=" + encodeURIComponent(lastUpdateDateToUtc ? "" + lastUpdateDateToUtc.toYearMonthDateString() : "") + "&";
        if (sellerTin !== undefined && sellerTin !== null)
            url_ += "SellerTin=" + encodeURIComponent("" + sellerTin) + "&";
        if (sellerName !== undefined && sellerName !== null)
            url_ += "SellerName=" + encodeURIComponent("" + sellerName) + "&";
        if (customerTin !== undefined && customerTin !== null)
            url_ += "CustomerTin=" + encodeURIComponent("" + customerTin) + "&";
        if (number !== undefined && number !== null)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (registrationNumber !== undefined && registrationNumber !== null)
            url_ += "RegistrationNumber=" + encodeURIComponent("" + registrationNumber) + "&";
        if (sellerStoreId !== undefined && sellerStoreId !== null)
            url_ += "SellerStoreId=" + encodeURIComponent("" + sellerStoreId) + "&";
        if (customerStoreId !== undefined && customerStoreId !== null)
            url_ += "CustomerStoreId=" + encodeURIComponent("" + customerStoreId) + "&";
        if (category !== undefined && category !== null)
            url_ += "Category=" + encodeURIComponent("" + category) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSntListReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSntListReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetSntListReport(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>();
    }

    /**
     * Generates a signing page using DSign to send an SNT to the ESF portal.
     * @param dto The DTO containing the details of the SNT to be sent.
     * @return A task that represents the asynchronous operation. The task result contains the document response DTO.
     */
    signingPageToSendSnt(dto: SendSntDto): Observable<SigningPageForSntResponseDto> {
        let url_ = this.baseUrl + "/api/Snt/signing-page-to-send-snt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSigningPageToSendSnt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSigningPageToSendSnt(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SigningPageForSntResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SigningPageForSntResponseDto>;
        }));
    }

    protected processSigningPageToSendSnt(response: HttpResponseBase): Observable<SigningPageForSntResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SigningPageForSntResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationProblemDetails.fromJS(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SigningPageForSntResponseDto>();
    }

    /**
     * Generates a signing page using DSign client to revoke an SNT.
     * @param dto The DTO containing the details of the SNT to be revoked.
     * @return A task that represents the asynchronous operation. The task result contains the document response DTO.
     */
    signingPageToRevokeSnt(dto: RevokeSntDto): Observable<SigningPageForChangeSntStatusResponseDto> {
        let url_ = this.baseUrl + "/api/Snt/signing-page-to-revoke-snt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSigningPageToRevokeSnt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSigningPageToRevokeSnt(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SigningPageForChangeSntStatusResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SigningPageForChangeSntStatusResponseDto>;
        }));
    }

    protected processSigningPageToRevokeSnt(response: HttpResponseBase): Observable<SigningPageForChangeSntStatusResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SigningPageForChangeSntStatusResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationProblemDetails.fromJS(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SigningPageForChangeSntStatusResponseDto>();
    }

    /**
     * To generate signing page using DSign client to confirm SNT
     * @param dto The DTO containing the details of the Snt to be confirmed.
     * @return A task that represents the asynchronous operation. The task result contains the document response DTO.
     */
    signingPageToConfirmSnt(dto: ConfirmSntDto): Observable<SigningPageForChangeSntStatusResponseDto> {
        let url_ = this.baseUrl + "/api/Snt/signing-page-to-confirm-snt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSigningPageToConfirmSnt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSigningPageToConfirmSnt(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SigningPageForChangeSntStatusResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SigningPageForChangeSntStatusResponseDto>;
        }));
    }

    protected processSigningPageToConfirmSnt(response: HttpResponseBase): Observable<SigningPageForChangeSntStatusResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SigningPageForChangeSntStatusResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationProblemDetails.fromJS(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SigningPageForChangeSntStatusResponseDto>();
    }

    /**
     * To generate signing page using DSign client to decline SNT
     * @param dto The DTO containing the details of the Snt to be declined.
     * @return A task that represents the asynchronous operation. The task result contains the document response DTO.
     */
    signingPageToDeclineSnt(dto: DeclineSntDto): Observable<SigningPageForChangeSntStatusResponseDto> {
        let url_ = this.baseUrl + "/api/Snt/signing-page-to-decline-snt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSigningPageToDeclineSnt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSigningPageToDeclineSnt(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SigningPageForChangeSntStatusResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SigningPageForChangeSntStatusResponseDto>;
        }));
    }

    protected processSigningPageToDeclineSnt(response: HttpResponseBase): Observable<SigningPageForChangeSntStatusResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SigningPageForChangeSntStatusResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationProblemDetails.fromJS(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SigningPageForChangeSntStatusResponseDto>();
    }

    /**
     * Import Snt
     */
    import(): Observable<ImportSntResultDto> {
        let url_ = this.baseUrl + "/api/Snt/import";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImportSntResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImportSntResultDto>;
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<ImportSntResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportSntResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationProblemDetails.fromJS(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportSntResultDto>();
    }

    /**
     * Save draft
     */
    saveDraft(dto: SntDraftDto): Observable<number> {
        let url_ = this.baseUrl + "/api/Snt/save-draft";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDraft(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDraft(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveDraft(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>();
    }

    /**
     * Get snt participant by tin
     * @param tin (optional) 
     */
    getSellerByTin(tin?: string | null | undefined): Observable<SntParticipantDto> {
        let url_ = this.baseUrl + "/api/Snt/get-snt-participant-by-tin?";
        if (tin !== undefined && tin !== null)
            url_ += "tin=" + encodeURIComponent("" + tin) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSellerByTin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSellerByTin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SntParticipantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SntParticipantDto>;
        }));
    }

    protected processGetSellerByTin(response: HttpResponseBase): Observable<SntParticipantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SntParticipantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SntParticipantDto>();
    }

    /**
     * Search top snt participants by name
     * @param name (optional) 
     * @param top (optional) 
     */
    searchSntParticipantsByName(name?: string | null | undefined, top?: number | undefined): Observable<SntParticipantShortDto[]> {
        let url_ = this.baseUrl + "/api/Snt/search-snt-participants-by-name?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "top=" + encodeURIComponent("" + top) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchSntParticipantsByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchSntParticipantsByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SntParticipantShortDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SntParticipantShortDto[]>;
        }));
    }

    protected processSearchSntParticipantsByName(response: HttpResponseBase): Observable<SntParticipantShortDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SntParticipantShortDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SntParticipantShortDto[]>();
    }
}

@Injectable()
export class ResponsibleAccountantClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:50852";
    }

    getResponsibleAccountants(): Observable<ResponsibleAccountantDto[]> {
        let url_ = this.baseUrl + "/api/admin/responsible-accountants";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetResponsibleAccountants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetResponsibleAccountants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponsibleAccountantDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponsibleAccountantDto[]>;
        }));
    }

    protected processGetResponsibleAccountants(response: HttpResponseBase): Observable<ResponsibleAccountantDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponsibleAccountantDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponsibleAccountantDto[]>();
    }

    addResponsibleAccountant(model: ResponsibleAccountantDto): Observable<ResponsibleAccountantDto> {
        let url_ = this.baseUrl + "/api/admin/responsible-accountants";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddResponsibleAccountant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddResponsibleAccountant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponsibleAccountantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponsibleAccountantDto>;
        }));
    }

    protected processAddResponsibleAccountant(response: HttpResponseBase): Observable<ResponsibleAccountantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponsibleAccountantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponsibleAccountantDto>();
    }

    updateResponsibleAccountant(id: number, model: ResponsibleAccountantDto): Observable<ResponsibleAccountantDto> {
        let url_ = this.baseUrl + "/api/admin/responsible-accountants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResponsibleAccountant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResponsibleAccountant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponsibleAccountantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponsibleAccountantDto>;
        }));
    }

    protected processUpdateResponsibleAccountant(response: HttpResponseBase): Observable<ResponsibleAccountantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponsibleAccountantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponsibleAccountantDto>();
    }

    deleteResponsibleAccountant(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/responsible-accountants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteResponsibleAccountant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteResponsibleAccountant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteResponsibleAccountant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>();
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>();
    }

    getGroupMembers(): Observable<MsGraphUser[]> {
        let url_ = this.baseUrl + "/api/admin/responsible-accountants/group-members";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGroupMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupMembers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MsGraphUser[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MsGraphUser[]>;
        }));
    }

    protected processGetGroupMembers(response: HttpResponseBase): Observable<MsGraphUser[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MsGraphUser.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MsGraphUser[]>();
    }
}

@Injectable()
export class BalanceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:50852";
    }

    /**
     * Get all balances
     * @param filter_Name (optional) 
     * @param filter_ProductNameInImportDoc (optional) 
     * @param filter_ProductNumberInImportDoc (optional) 
     * @param filter_ManufactureOrImportDocNumber (optional) 
     * @param filter_ProductId (optional) 
     * @param filter_UnitPrice (optional) 
     * @param filter_KpvedCode (optional) 
     * @param filter_TnvedCode (optional) 
     * @param filter_GtinCode (optional) 
     * @param filter_PhysicalLabel (optional) 
     * @param filter_TaxpayerStoreId (optional) 
     * @param filter_MeasureUnitId (optional) 
     * @param sorting_SortColumn (optional) 
     * @param sorting_SortOrder (optional) 
     * @param paging_CurrentPage (optional) 
     * @param paging_ItemsPerPage (optional) 
     */
    getAll(filter_Name?: string | null | undefined, filter_ProductNameInImportDoc?: string | null | undefined, filter_ProductNumberInImportDoc?: string | null | undefined, filter_ManufactureOrImportDocNumber?: string | null | undefined, filter_ProductId?: number | null | undefined, filter_UnitPrice?: number | null | undefined, filter_KpvedCode?: string | null | undefined, filter_TnvedCode?: string | null | undefined, filter_GtinCode?: string | null | undefined, filter_PhysicalLabel?: string | null | undefined, filter_TaxpayerStoreId?: number | null | undefined, filter_MeasureUnitId?: number | null | undefined, sorting_SortColumn?: string | null | undefined, sorting_SortOrder?: SortingOrder | undefined, paging_CurrentPage?: number | undefined, paging_ItemsPerPage?: number | undefined): Observable<BalancesListResponseDto> {
        let url_ = this.baseUrl + "/api/Balance/getall?";
        if (filter_Name !== undefined && filter_Name !== null)
            url_ += "Filter.Name=" + encodeURIComponent("" + filter_Name) + "&";
        if (filter_ProductNameInImportDoc !== undefined && filter_ProductNameInImportDoc !== null)
            url_ += "Filter.ProductNameInImportDoc=" + encodeURIComponent("" + filter_ProductNameInImportDoc) + "&";
        if (filter_ProductNumberInImportDoc !== undefined && filter_ProductNumberInImportDoc !== null)
            url_ += "Filter.ProductNumberInImportDoc=" + encodeURIComponent("" + filter_ProductNumberInImportDoc) + "&";
        if (filter_ManufactureOrImportDocNumber !== undefined && filter_ManufactureOrImportDocNumber !== null)
            url_ += "Filter.ManufactureOrImportDocNumber=" + encodeURIComponent("" + filter_ManufactureOrImportDocNumber) + "&";
        if (filter_ProductId !== undefined && filter_ProductId !== null)
            url_ += "Filter.ProductId=" + encodeURIComponent("" + filter_ProductId) + "&";
        if (filter_UnitPrice !== undefined && filter_UnitPrice !== null)
            url_ += "Filter.UnitPrice=" + encodeURIComponent("" + filter_UnitPrice) + "&";
        if (filter_KpvedCode !== undefined && filter_KpvedCode !== null)
            url_ += "Filter.KpvedCode=" + encodeURIComponent("" + filter_KpvedCode) + "&";
        if (filter_TnvedCode !== undefined && filter_TnvedCode !== null)
            url_ += "Filter.TnvedCode=" + encodeURIComponent("" + filter_TnvedCode) + "&";
        if (filter_GtinCode !== undefined && filter_GtinCode !== null)
            url_ += "Filter.GtinCode=" + encodeURIComponent("" + filter_GtinCode) + "&";
        if (filter_PhysicalLabel !== undefined && filter_PhysicalLabel !== null)
            url_ += "Filter.PhysicalLabel=" + encodeURIComponent("" + filter_PhysicalLabel) + "&";
        if (filter_TaxpayerStoreId !== undefined && filter_TaxpayerStoreId !== null)
            url_ += "Filter.TaxpayerStoreId=" + encodeURIComponent("" + filter_TaxpayerStoreId) + "&";
        if (filter_MeasureUnitId !== undefined && filter_MeasureUnitId !== null)
            url_ += "Filter.MeasureUnitId=" + encodeURIComponent("" + filter_MeasureUnitId) + "&";
        if (sorting_SortColumn !== undefined && sorting_SortColumn !== null)
            url_ += "Sorting.SortColumn=" + encodeURIComponent("" + sorting_SortColumn) + "&";
        if (sorting_SortOrder === null)
            throw new Error("The parameter 'sorting_SortOrder' cannot be null.");
        else if (sorting_SortOrder !== undefined)
            url_ += "Sorting.SortOrder=" + encodeURIComponent("" + sorting_SortOrder) + "&";
        if (paging_CurrentPage === null)
            throw new Error("The parameter 'paging_CurrentPage' cannot be null.");
        else if (paging_CurrentPage !== undefined)
            url_ += "Paging.CurrentPage=" + encodeURIComponent("" + paging_CurrentPage) + "&";
        if (paging_ItemsPerPage === null)
            throw new Error("The parameter 'paging_ItemsPerPage' cannot be null.");
        else if (paging_ItemsPerPage !== undefined)
            url_ += "Paging.ItemsPerPage=" + encodeURIComponent("" + paging_ItemsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BalancesListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BalancesListResponseDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<BalancesListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BalancesListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BalancesListResponseDto>();
    }

    /**
     * Get Balance report by filters
     * @param filter_Name (optional) 
     * @param filter_ProductNameInImportDoc (optional) 
     * @param filter_ProductNumberInImportDoc (optional) 
     * @param filter_ManufactureOrImportDocNumber (optional) 
     * @param filter_ProductId (optional) 
     * @param filter_UnitPrice (optional) 
     * @param filter_KpvedCode (optional) 
     * @param filter_TnvedCode (optional) 
     * @param filter_GtinCode (optional) 
     * @param filter_PhysicalLabel (optional) 
     * @param filter_TaxpayerStoreId (optional) 
     * @param filter_MeasureUnitId (optional) 
     * @param sorting_SortColumn (optional) 
     * @param sorting_SortOrder (optional) 
     */
    getBalanceListReport(filter_Name?: string | null | undefined, filter_ProductNameInImportDoc?: string | null | undefined, filter_ProductNumberInImportDoc?: string | null | undefined, filter_ManufactureOrImportDocNumber?: string | null | undefined, filter_ProductId?: number | null | undefined, filter_UnitPrice?: number | null | undefined, filter_KpvedCode?: string | null | undefined, filter_TnvedCode?: string | null | undefined, filter_GtinCode?: string | null | undefined, filter_PhysicalLabel?: string | null | undefined, filter_TaxpayerStoreId?: number | null | undefined, filter_MeasureUnitId?: number | null | undefined, sorting_SortColumn?: string | null | undefined, sorting_SortOrder?: SortingOrder | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Balance/get-balance-list-report?";
        if (filter_Name !== undefined && filter_Name !== null)
            url_ += "Filter.Name=" + encodeURIComponent("" + filter_Name) + "&";
        if (filter_ProductNameInImportDoc !== undefined && filter_ProductNameInImportDoc !== null)
            url_ += "Filter.ProductNameInImportDoc=" + encodeURIComponent("" + filter_ProductNameInImportDoc) + "&";
        if (filter_ProductNumberInImportDoc !== undefined && filter_ProductNumberInImportDoc !== null)
            url_ += "Filter.ProductNumberInImportDoc=" + encodeURIComponent("" + filter_ProductNumberInImportDoc) + "&";
        if (filter_ManufactureOrImportDocNumber !== undefined && filter_ManufactureOrImportDocNumber !== null)
            url_ += "Filter.ManufactureOrImportDocNumber=" + encodeURIComponent("" + filter_ManufactureOrImportDocNumber) + "&";
        if (filter_ProductId !== undefined && filter_ProductId !== null)
            url_ += "Filter.ProductId=" + encodeURIComponent("" + filter_ProductId) + "&";
        if (filter_UnitPrice !== undefined && filter_UnitPrice !== null)
            url_ += "Filter.UnitPrice=" + encodeURIComponent("" + filter_UnitPrice) + "&";
        if (filter_KpvedCode !== undefined && filter_KpvedCode !== null)
            url_ += "Filter.KpvedCode=" + encodeURIComponent("" + filter_KpvedCode) + "&";
        if (filter_TnvedCode !== undefined && filter_TnvedCode !== null)
            url_ += "Filter.TnvedCode=" + encodeURIComponent("" + filter_TnvedCode) + "&";
        if (filter_GtinCode !== undefined && filter_GtinCode !== null)
            url_ += "Filter.GtinCode=" + encodeURIComponent("" + filter_GtinCode) + "&";
        if (filter_PhysicalLabel !== undefined && filter_PhysicalLabel !== null)
            url_ += "Filter.PhysicalLabel=" + encodeURIComponent("" + filter_PhysicalLabel) + "&";
        if (filter_TaxpayerStoreId !== undefined && filter_TaxpayerStoreId !== null)
            url_ += "Filter.TaxpayerStoreId=" + encodeURIComponent("" + filter_TaxpayerStoreId) + "&";
        if (filter_MeasureUnitId !== undefined && filter_MeasureUnitId !== null)
            url_ += "Filter.MeasureUnitId=" + encodeURIComponent("" + filter_MeasureUnitId) + "&";
        if (sorting_SortColumn !== undefined && sorting_SortColumn !== null)
            url_ += "Sorting.SortColumn=" + encodeURIComponent("" + sorting_SortColumn) + "&";
        if (sorting_SortOrder === null)
            throw new Error("The parameter 'sorting_SortOrder' cannot be null.");
        else if (sorting_SortOrder !== undefined)
            url_ += "Sorting.SortOrder=" + encodeURIComponent("" + sorting_SortOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBalanceListReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBalanceListReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetBalanceListReport(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>();
    }

    /**
     * Import balances regular
     */
    importBalances(): Observable<ImportBalancesRegularResultDto> {
        let url_ = this.baseUrl + "/api/Balance/import";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportBalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportBalances(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImportBalancesRegularResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImportBalancesRegularResultDto>;
        }));
    }

    protected processImportBalances(response: HttpResponseBase): Observable<ImportBalancesRegularResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportBalancesRegularResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationProblemDetails.fromJS(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportBalancesRegularResultDto>();
    }

    /**
     * Import balances initial
     */
    importBalancesInitial(): Observable<number> {
        let url_ = this.baseUrl + "/api/Balance/import-initial";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportBalancesInitial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportBalancesInitial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processImportBalancesInitial(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationProblemDetails.fromJS(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>();
    }

    /**
     * Import balances initial
     */
    fixBalancesImportKey(): Observable<FixBalancesImportKeyResultDto> {
        let url_ = this.baseUrl + "/api/Balance/fix-import-key";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFixBalancesImportKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFixBalancesImportKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FixBalancesImportKeyResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FixBalancesImportKeyResultDto>;
        }));
    }

    protected processFixBalancesImportKey(response: HttpResponseBase): Observable<FixBalancesImportKeyResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FixBalancesImportKeyResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationProblemDetails.fromJS(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FixBalancesImportKeyResultDto>();
    }

    /**
     * Validate balances
     * @param storeId (optional) 
     */
    validateBalances(dto: ValidateBalanceDto, storeId?: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Balance/validate?";
        if (storeId !== undefined && storeId !== null)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateBalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateBalances(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processValidateBalances(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>();
    }
}

@Injectable()
export class DictionariesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:50852";
    }

    /**
     * Get favorite gsvs items
     */
    getFavoriteProducts(): Observable<FavoriteProductDto[]> {
        let url_ = this.baseUrl + "/api/Dictionaries/gsvs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFavoriteProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFavoriteProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FavoriteProductDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FavoriteProductDto[]>;
        }));
    }

    protected processGetFavoriteProducts(response: HttpResponseBase): Observable<FavoriteProductDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FavoriteProductDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FavoriteProductDto[]>();
    }

    /**
     * Add gsvs item to favorite
     * @param code (optional) 
     */
    addFavoriteProduct(code?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Dictionaries/gsvs?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddFavoriteProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddFavoriteProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddFavoriteProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>();
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>();
    }

    /**
     * Import gsvs
     */
    importGsvs(): Observable<number> {
        let url_ = this.baseUrl + "/api/Dictionaries/import-gsvs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportGsvs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportGsvs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processImportGsvs(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationProblemDetails.fromJS(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>();
    }

    /**
     * Import error codes
     */
    importErrorCodes(): Observable<ImportErrorCodesResultDto> {
        let url_ = this.baseUrl + "/api/Dictionaries/import-error-codes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportErrorCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportErrorCodes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImportErrorCodesResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImportErrorCodesResultDto>;
        }));
    }

    protected processImportErrorCodes(response: HttpResponseBase): Observable<ImportErrorCodesResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportErrorCodesResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationProblemDetails.fromJS(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportErrorCodesResultDto>();
    }

    /**
     * Get child products by parent id
     * @param fixedId (optional) 
     */
    getChildrenProducts(fixedId?: number | undefined): Observable<ProductDto[]> {
        let url_ = this.baseUrl + "/api/Dictionaries/get-children-products?";
        if (fixedId === null)
            throw new Error("The parameter 'fixedId' cannot be null.");
        else if (fixedId !== undefined)
            url_ += "fixedId=" + encodeURIComponent("" + fixedId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChildrenProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChildrenProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto[]>;
        }));
    }

    protected processGetChildrenProducts(response: HttpResponseBase): Observable<ProductDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDto[]>();
    }

    /**
     * Search products
     * @param code (optional) 
     * @param name (optional) 
     * @param useInVstore (optional) 
     * @param unique (optional) 
     * @param withdrawal (optional) 
     * @param twofoldPurpose (optional) 
     * @param sociallySignificant (optional) 
     * @param excisable (optional) 
     */
    searchProducts(code?: string | null | undefined, name?: string | null | undefined, useInVstore?: boolean | null | undefined, unique?: boolean | null | undefined, withdrawal?: boolean | null | undefined, twofoldPurpose?: boolean | null | undefined, sociallySignificant?: boolean | null | undefined, excisable?: boolean | null | undefined): Observable<ProductDto[]> {
        let url_ = this.baseUrl + "/api/Dictionaries/search-products?";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (useInVstore !== undefined && useInVstore !== null)
            url_ += "UseInVstore=" + encodeURIComponent("" + useInVstore) + "&";
        if (unique !== undefined && unique !== null)
            url_ += "Unique=" + encodeURIComponent("" + unique) + "&";
        if (withdrawal !== undefined && withdrawal !== null)
            url_ += "Withdrawal=" + encodeURIComponent("" + withdrawal) + "&";
        if (twofoldPurpose !== undefined && twofoldPurpose !== null)
            url_ += "TwofoldPurpose=" + encodeURIComponent("" + twofoldPurpose) + "&";
        if (sociallySignificant !== undefined && sociallySignificant !== null)
            url_ += "SociallySignificant=" + encodeURIComponent("" + sociallySignificant) + "&";
        if (excisable !== undefined && excisable !== null)
            url_ += "Excisable=" + encodeURIComponent("" + excisable) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductDto[]>;
        }));
    }

    protected processSearchProducts(response: HttpResponseBase): Observable<ProductDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDto[]>();
    }

    getRateByCurrencyAndDate(currencyCode?: string | null | undefined, date?: Date | undefined, localTimezoneOffsetMinutes?: number | undefined): Observable<GetRateResponseDto> {
        let url_ = this.baseUrl + "/api/Dictionaries/get-rate?";
        if (currencyCode !== undefined && currencyCode !== null)
            url_ += "CurrencyCode=" + encodeURIComponent("" + currencyCode) + "&";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "Date=" + encodeURIComponent(date ? "" + date.toYearMonthDateString() : "") + "&";
        if (localTimezoneOffsetMinutes === null)
            throw new Error("The parameter 'localTimezoneOffsetMinutes' cannot be null.");
        else if (localTimezoneOffsetMinutes !== undefined)
            url_ += "LocalTimezoneOffsetMinutes=" + encodeURIComponent("" + localTimezoneOffsetMinutes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRateByCurrencyAndDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRateByCurrencyAndDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRateResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRateResponseDto>;
        }));
    }

    protected processGetRateByCurrencyAndDate(response: HttpResponseBase): Observable<GetRateResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRateResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRateResponseDto>();
    }

    getMeasureUnits(): Observable<MeasureUnitDto[]> {
        let url_ = this.baseUrl + "/api/Dictionaries/measure-units";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMeasureUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMeasureUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MeasureUnitDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MeasureUnitDto[]>;
        }));
    }

    protected processGetMeasureUnits(response: HttpResponseBase): Observable<MeasureUnitDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MeasureUnitDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MeasureUnitDto[]>();
    }

    getFavouriteMeasureUnits(): Observable<MeasureUnitDto[]> {
        let url_ = this.baseUrl + "/api/Dictionaries/favourite-measure-units";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFavouriteMeasureUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFavouriteMeasureUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MeasureUnitDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MeasureUnitDto[]>;
        }));
    }

    protected processGetFavouriteMeasureUnits(response: HttpResponseBase): Observable<MeasureUnitDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MeasureUnitDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MeasureUnitDto[]>();
    }

    importMeasureUnits(): Observable<ImportMeasureUnitsResultDto> {
        let url_ = this.baseUrl + "/api/Dictionaries/import-measure-units";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportMeasureUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportMeasureUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImportMeasureUnitsResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImportMeasureUnitsResultDto>;
        }));
    }

    protected processImportMeasureUnits(response: HttpResponseBase): Observable<ImportMeasureUnitsResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportMeasureUnitsResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationProblemDetails.fromJS(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportMeasureUnitsResultDto>();
    }

    importPinCodesInitial(): Observable<number> {
        let url_ = this.baseUrl + "/api/Dictionaries/import-pin-codes-initial";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportPinCodesInitial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportPinCodesInitial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processImportPinCodesInitial(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>();
    }

    importPinCodesRegular(): Observable<ImportPinCodesResultDto> {
        let url_ = this.baseUrl + "/api/Dictionaries/import-pin-codes-regular";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportPinCodesRegular(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportPinCodesRegular(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImportPinCodesResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImportPinCodesResultDto>;
        }));
    }

    protected processImportPinCodesRegular(response: HttpResponseBase): Observable<ImportPinCodesResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportPinCodesResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportPinCodesResultDto>();
    }

    getPinCode(pinCode?: string | null | undefined): Observable<OilPinCodeDto[]> {
        let url_ = this.baseUrl + "/api/Dictionaries/get-pin-code?";
        if (pinCode !== undefined && pinCode !== null)
            url_ += "pinCode=" + encodeURIComponent("" + pinCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPinCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPinCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OilPinCodeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OilPinCodeDto[]>;
        }));
    }

    protected processGetPinCode(response: HttpResponseBase): Observable<OilPinCodeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OilPinCodeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OilPinCodeDto[]>();
    }

    getCountries(): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/Dictionaries/countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto[]>;
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto[]>();
    }

    getFavouriteCountries(): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/Dictionaries/favourite-countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFavouriteCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFavouriteCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto[]>;
        }));
    }

    protected processGetFavouriteCountries(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto[]>();
    }

    getCurrencies(): Observable<CurrencyDto[]> {
        let url_ = this.baseUrl + "/api/Dictionaries/currencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrencies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyDto[]>;
        }));
    }

    protected processGetCurrencies(response: HttpResponseBase): Observable<CurrencyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CurrencyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyDto[]>();
    }

    getFavouriteCurrencies(): Observable<CurrencyDto[]> {
        let url_ = this.baseUrl + "/api/Dictionaries/favourite-currencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFavouriteCurrencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFavouriteCurrencies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyDto[]>;
        }));
    }

    protected processGetFavouriteCurrencies(response: HttpResponseBase): Observable<CurrencyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CurrencyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyDto[]>();
    }

    importExchangeRates(): Observable<ImportExchangeRatesResultDto> {
        let url_ = this.baseUrl + "/api/Dictionaries/import-exchange-rates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportExchangeRates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportExchangeRates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImportExchangeRatesResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImportExchangeRatesResultDto>;
        }));
    }

    protected processImportExchangeRates(response: HttpResponseBase): Observable<ImportExchangeRatesResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportExchangeRatesResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportExchangeRatesResultDto>();
    }
}

@Injectable()
export class TaxpayerStoreClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:50852";
    }

    /**
     * Get only user taxpayer stores
     */
    getUserTaxpayerStores(): Observable<TaxpayerStoreSimpleDto[]> {
        let url_ = this.baseUrl + "/api/TaxpayerStore";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserTaxpayerStores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserTaxpayerStores(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TaxpayerStoreSimpleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TaxpayerStoreSimpleDto[]>;
        }));
    }

    protected processGetUserTaxpayerStores(response: HttpResponseBase): Observable<TaxpayerStoreSimpleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaxpayerStoreSimpleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TaxpayerStoreSimpleDto[]>();
    }

    /**
     * Get all taxpayer stores
     */
    getAllTaxpayerStores(): Observable<TaxpayerStoreSimpleDto[]> {
        let url_ = this.baseUrl + "/api/TaxpayerStore/alltaxpayerstores";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaxpayerStores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaxpayerStores(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TaxpayerStoreSimpleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TaxpayerStoreSimpleDto[]>;
        }));
    }

    protected processGetAllTaxpayerStores(response: HttpResponseBase): Observable<TaxpayerStoreSimpleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaxpayerStoreSimpleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TaxpayerStoreSimpleDto[]>();
    }

    /**
     * Import taxpayer stores
     */
    import(): Observable<number> {
        let url_ = this.baseUrl + "/api/TaxpayerStore/import";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationProblemDetails.fromJS(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>();
    }

    /**
     * Import customer stores by TIN
     */
    importByTin(request: ImportCustomerStoresCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/TaxpayerStore/import-by-tin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportByTin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportByTin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportByTin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>();
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>();
    }

    /**
     * Get all taxpayer stores
     * @param tin (optional) 
     */
    getCustomerStoresByTin(tin?: string | null | undefined): Observable<TaxpayerStoreSimpleDto[]> {
        let url_ = this.baseUrl + "/api/TaxpayerStore/get-customer-stores-by-tin?";
        if (tin !== undefined && tin !== null)
            url_ += "Tin=" + encodeURIComponent("" + tin) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerStoresByTin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerStoresByTin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TaxpayerStoreSimpleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TaxpayerStoreSimpleDto[]>;
        }));
    }

    protected processGetCustomerStoresByTin(response: HttpResponseBase): Observable<TaxpayerStoreSimpleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaxpayerStoreSimpleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TaxpayerStoreSimpleDto[]>();
    }
}

@Injectable()
export class UFormClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:50852";
    }

    /**
     * Get all forms
     * @param filter_Number (optional) Номер документа
     * @param filter_RegistrationNumber (optional) Регистрационный номер
     * @param filter_DateFrom (optional) Дата документа "с" (yyyy-MM-dd format)
     * @param filter_DateTo (optional) Дата документа "по" (yyyy-MM-dd format)
     * @param filter_SenderTin (optional) БИН отправителя
     * @param filter_RecipientTin (optional) БИН получателя
     * @param filter_TotalSumFrom (optional) Общая сумма "с"
     * @param filter_TotalSumTo (optional) Общая сумма "по"
     * @param filter_Type (optional) Тип
     * @param filter_Status (optional) Статус
     * @param filter_SenderStoreId (optional) Склад отправителя
     * @param filter_RecipientStoreId (optional) Склад получателя
     * @param sorting_SortColumn (optional) 
     * @param sorting_SortOrder (optional) 
     * @param paging_CurrentPage (optional) 
     * @param paging_ItemsPerPage (optional) 
     */
    getAllForms(filter_Number?: string | null | undefined, filter_RegistrationNumber?: string | null | undefined, filter_DateFrom?: Date | null | undefined, filter_DateTo?: Date | null | undefined, filter_SenderTin?: string | null | undefined, filter_RecipientTin?: string | null | undefined, filter_TotalSumFrom?: number | null | undefined, filter_TotalSumTo?: number | null | undefined, filter_Type?: UFormType | null | undefined, filter_Status?: UFormStatusType | null | undefined, filter_SenderStoreId?: number | null | undefined, filter_RecipientStoreId?: number | null | undefined, sorting_SortColumn?: string | null | undefined, sorting_SortOrder?: SortingOrder | undefined, paging_CurrentPage?: number | undefined, paging_ItemsPerPage?: number | undefined): Observable<UFormListResponseDto> {
        let url_ = this.baseUrl + "/api/UForm?";
        if (filter_Number !== undefined && filter_Number !== null)
            url_ += "Filter.Number=" + encodeURIComponent("" + filter_Number) + "&";
        if (filter_RegistrationNumber !== undefined && filter_RegistrationNumber !== null)
            url_ += "Filter.RegistrationNumber=" + encodeURIComponent("" + filter_RegistrationNumber) + "&";
        if (filter_DateFrom !== undefined && filter_DateFrom !== null)
            url_ += "Filter.DateFrom=" + encodeURIComponent(filter_DateFrom ? "" + filter_DateFrom.toYearMonthDateString() : "") + "&";
        if (filter_DateTo !== undefined && filter_DateTo !== null)
            url_ += "Filter.DateTo=" + encodeURIComponent(filter_DateTo ? "" + filter_DateTo.toYearMonthDateString() : "") + "&";
        if (filter_SenderTin !== undefined && filter_SenderTin !== null)
            url_ += "Filter.SenderTin=" + encodeURIComponent("" + filter_SenderTin) + "&";
        if (filter_RecipientTin !== undefined && filter_RecipientTin !== null)
            url_ += "Filter.RecipientTin=" + encodeURIComponent("" + filter_RecipientTin) + "&";
        if (filter_TotalSumFrom !== undefined && filter_TotalSumFrom !== null)
            url_ += "Filter.TotalSumFrom=" + encodeURIComponent("" + filter_TotalSumFrom) + "&";
        if (filter_TotalSumTo !== undefined && filter_TotalSumTo !== null)
            url_ += "Filter.TotalSumTo=" + encodeURIComponent("" + filter_TotalSumTo) + "&";
        if (filter_Type !== undefined && filter_Type !== null)
            url_ += "Filter.Type=" + encodeURIComponent("" + filter_Type) + "&";
        if (filter_Status !== undefined && filter_Status !== null)
            url_ += "Filter.Status=" + encodeURIComponent("" + filter_Status) + "&";
        if (filter_SenderStoreId !== undefined && filter_SenderStoreId !== null)
            url_ += "Filter.SenderStoreId=" + encodeURIComponent("" + filter_SenderStoreId) + "&";
        if (filter_RecipientStoreId !== undefined && filter_RecipientStoreId !== null)
            url_ += "Filter.RecipientStoreId=" + encodeURIComponent("" + filter_RecipientStoreId) + "&";
        if (sorting_SortColumn !== undefined && sorting_SortColumn !== null)
            url_ += "Sorting.SortColumn=" + encodeURIComponent("" + sorting_SortColumn) + "&";
        if (sorting_SortOrder === null)
            throw new Error("The parameter 'sorting_SortOrder' cannot be null.");
        else if (sorting_SortOrder !== undefined)
            url_ += "Sorting.SortOrder=" + encodeURIComponent("" + sorting_SortOrder) + "&";
        if (paging_CurrentPage === null)
            throw new Error("The parameter 'paging_CurrentPage' cannot be null.");
        else if (paging_CurrentPage !== undefined)
            url_ += "Paging.CurrentPage=" + encodeURIComponent("" + paging_CurrentPage) + "&";
        if (paging_ItemsPerPage === null)
            throw new Error("The parameter 'paging_ItemsPerPage' cannot be null.");
        else if (paging_ItemsPerPage !== undefined)
            url_ += "Paging.ItemsPerPage=" + encodeURIComponent("" + paging_ItemsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllForms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UFormListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UFormListResponseDto>;
        }));
    }

    protected processGetAllForms(response: HttpResponseBase): Observable<UFormListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UFormListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UFormListResponseDto>();
    }

    /**
     * Get form
     */
    get(id: number): Observable<UFormFullDto> {
        let url_ = this.baseUrl + "/api/UForm/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UFormFullDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UFormFullDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UFormFullDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UFormFullDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UFormFullDto>();
    }

    /**
     * Get Uform list report by filters
     * @param filter_Number (optional) Номер документа
     * @param filter_RegistrationNumber (optional) Регистрационный номер
     * @param filter_DateFrom (optional) Дата документа "с" (yyyy-MM-dd format)
     * @param filter_DateTo (optional) Дата документа "по" (yyyy-MM-dd format)
     * @param filter_SenderTin (optional) БИН отправителя
     * @param filter_RecipientTin (optional) БИН получателя
     * @param filter_TotalSumFrom (optional) Общая сумма "с"
     * @param filter_TotalSumTo (optional) Общая сумма "по"
     * @param filter_Type (optional) Тип
     * @param filter_Status (optional) Статус
     * @param filter_SenderStoreId (optional) Склад отправителя
     * @param filter_RecipientStoreId (optional) Склад получателя
     * @param sorting_SortColumn (optional) 
     * @param sorting_SortOrder (optional) 
     */
    getUFormListReport(filter_Number?: string | null | undefined, filter_RegistrationNumber?: string | null | undefined, filter_DateFrom?: Date | null | undefined, filter_DateTo?: Date | null | undefined, filter_SenderTin?: string | null | undefined, filter_RecipientTin?: string | null | undefined, filter_TotalSumFrom?: number | null | undefined, filter_TotalSumTo?: number | null | undefined, filter_Type?: UFormType | null | undefined, filter_Status?: UFormStatusType | null | undefined, filter_SenderStoreId?: number | null | undefined, filter_RecipientStoreId?: number | null | undefined, sorting_SortColumn?: string | null | undefined, sorting_SortOrder?: SortingOrder | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/UForm/get-uform-list-report?";
        if (filter_Number !== undefined && filter_Number !== null)
            url_ += "Filter.Number=" + encodeURIComponent("" + filter_Number) + "&";
        if (filter_RegistrationNumber !== undefined && filter_RegistrationNumber !== null)
            url_ += "Filter.RegistrationNumber=" + encodeURIComponent("" + filter_RegistrationNumber) + "&";
        if (filter_DateFrom !== undefined && filter_DateFrom !== null)
            url_ += "Filter.DateFrom=" + encodeURIComponent(filter_DateFrom ? "" + filter_DateFrom.toYearMonthDateString() : "") + "&";
        if (filter_DateTo !== undefined && filter_DateTo !== null)
            url_ += "Filter.DateTo=" + encodeURIComponent(filter_DateTo ? "" + filter_DateTo.toYearMonthDateString() : "") + "&";
        if (filter_SenderTin !== undefined && filter_SenderTin !== null)
            url_ += "Filter.SenderTin=" + encodeURIComponent("" + filter_SenderTin) + "&";
        if (filter_RecipientTin !== undefined && filter_RecipientTin !== null)
            url_ += "Filter.RecipientTin=" + encodeURIComponent("" + filter_RecipientTin) + "&";
        if (filter_TotalSumFrom !== undefined && filter_TotalSumFrom !== null)
            url_ += "Filter.TotalSumFrom=" + encodeURIComponent("" + filter_TotalSumFrom) + "&";
        if (filter_TotalSumTo !== undefined && filter_TotalSumTo !== null)
            url_ += "Filter.TotalSumTo=" + encodeURIComponent("" + filter_TotalSumTo) + "&";
        if (filter_Type !== undefined && filter_Type !== null)
            url_ += "Filter.Type=" + encodeURIComponent("" + filter_Type) + "&";
        if (filter_Status !== undefined && filter_Status !== null)
            url_ += "Filter.Status=" + encodeURIComponent("" + filter_Status) + "&";
        if (filter_SenderStoreId !== undefined && filter_SenderStoreId !== null)
            url_ += "Filter.SenderStoreId=" + encodeURIComponent("" + filter_SenderStoreId) + "&";
        if (filter_RecipientStoreId !== undefined && filter_RecipientStoreId !== null)
            url_ += "Filter.RecipientStoreId=" + encodeURIComponent("" + filter_RecipientStoreId) + "&";
        if (sorting_SortColumn !== undefined && sorting_SortColumn !== null)
            url_ += "Sorting.SortColumn=" + encodeURIComponent("" + sorting_SortColumn) + "&";
        if (sorting_SortOrder === null)
            throw new Error("The parameter 'sorting_SortOrder' cannot be null.");
        else if (sorting_SortOrder !== undefined)
            url_ += "Sorting.SortOrder=" + encodeURIComponent("" + sorting_SortOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUFormListReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUFormListReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetUFormListReport(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>();
    }

    /**
     * Save manufacture draft
     */
    saveManufactureDraft(form: ManufactureUFormDto): Observable<number> {
        let url_ = this.baseUrl + "/api/UForm/save-manufacture-draft";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(form.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveManufactureDraft(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveManufactureDraft(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveManufactureDraft(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>();
    }

    /**
     * Save write-off draft
     */
    saveWriteOffDraft(form: WriteOffUFormDto): Observable<number> {
        let url_ = this.baseUrl + "/api/UForm/save-writeoff-draft";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(form.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveWriteOffDraft(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveWriteOffDraft(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveWriteOffDraft(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>();
    }

    /**
     * Save movement draft
     */
    saveMovementDraft(form: MovementUFormDto): Observable<number> {
        let url_ = this.baseUrl + "/api/UForm/save-movement-draft";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(form.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveMovementDraft(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveMovementDraft(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveMovementDraft(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>();
    }

    /**
     * Cancel UForm
     */
    cancel(): Observable<void> {
        let url_ = this.baseUrl + "/api/UForm/cancel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>();
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>();
    }

    /**
     * Save balance draft
     */
    saveBalanceDraft(form: BalanceUFormDto): Observable<number> {
        let url_ = this.baseUrl + "/api/UForm/save-balance-draft";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(form.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveBalanceDraft(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveBalanceDraft(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveBalanceDraft(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>();
    }

    /**
     * Save detailing draft
     */
    saveDetailingDraft(form: DetailingUFormDto): Observable<number> {
        let url_ = this.baseUrl + "/api/UForm/save-detailing-draft";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(form.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDetailingDraft(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDetailingDraft(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveDetailingDraft(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>();
    }

    /**
     * Generate a signing page using DSign client to send UForm
     * @param id The ID of the UForm to be sent
     * @return No content result
     */
    signingPageToSendUForm(id: number): Observable<SigningPageForUFormResponseDto> {
        let url_ = this.baseUrl + "/api/UForm/signing-page-to-send-uform/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSigningPageToSendUForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSigningPageToSendUForm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SigningPageForUFormResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SigningPageForUFormResponseDto>;
        }));
    }

    protected processSigningPageToSendUForm(response: HttpResponseBase): Observable<SigningPageForUFormResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SigningPageForUFormResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationProblemDetails.fromJS(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SigningPageForUFormResponseDto>();
    }

    /**
     * Import UForms
     */
    import(): Observable<ImportUFormsResultDto> {
        let url_ = this.baseUrl + "/api/UForm/import";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImportUFormsResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImportUFormsResultDto>;
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<ImportUFormsResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportUFormsResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ValidationProblemDetails.fromJS(resultData422);
            return throwException("A server side error occurred.", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportUFormsResultDto>();
    }
}

@Injectable()
export class AdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:50852";
    }

    /**
     * Get groups from AzureAD with names which matches pattern
     * @param seek (optional) 
     */
    searchGroup(seek?: string | null | undefined): Observable<AdGroupDto[]> {
        let url_ = this.baseUrl + "/api/admin/searchgroup?";
        if (seek !== undefined && seek !== null)
            url_ += "seek=" + encodeURIComponent("" + seek) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdGroupDto[]>;
        }));
    }

    protected processSearchGroup(response: HttpResponseBase): Observable<AdGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdGroupDto[]>();
    }
}

@Injectable()
export class GroupTaxpayerStoreClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:50852";
    }

    /**
     * Get all groups with their taxpayer stores
     */
    getAllGroupTaxpayerStores(): Observable<GroupTaxpayerStoresDto[]> {
        let url_ = this.baseUrl + "/api/admin/GroupTaxpayerStore/grouptaxpayerstores";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGroupTaxpayerStores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGroupTaxpayerStores(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GroupTaxpayerStoresDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GroupTaxpayerStoresDto[]>;
        }));
    }

    protected processGetAllGroupTaxpayerStores(response: HttpResponseBase): Observable<GroupTaxpayerStoresDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GroupTaxpayerStoresDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupTaxpayerStoresDto[]>();
    }

    /**
     * Put group taxpayer stores
     */
    putGroupTaxpayerStores(dto: GroupTaxpayerStoresIdsDto): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/GroupTaxpayerStore/grouptaxpayerstores";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutGroupTaxpayerStores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutGroupTaxpayerStores(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPutGroupTaxpayerStores(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>();
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>();
    }

    /**
     * Get group taxpayer stores
     */
    getGroupTaxpayerStores(groupId: string): Observable<TaxpayerStoreDescriptionDto[]> {
        let url_ = this.baseUrl + "/api/admin/GroupTaxpayerStore/grouptaxpayerstores/{groupId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGroupTaxpayerStores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupTaxpayerStores(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TaxpayerStoreDescriptionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TaxpayerStoreDescriptionDto[]>;
        }));
    }

    protected processGetGroupTaxpayerStores(response: HttpResponseBase): Observable<TaxpayerStoreDescriptionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaxpayerStoreDescriptionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TaxpayerStoreDescriptionDto[]>();
    }

    /**
     * Delete group access for all taxpayer stores
     * @param groupId (optional) 
     */
    deleteGroupTxpayerStore(groupId?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/GroupTaxpayerStore/grouptaxpayerstore?";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGroupTxpayerStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGroupTxpayerStore(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteGroupTxpayerStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>();
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>();
    }
}

@Injectable()
export class EsfProfileClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:50852";
    }

    get(): Observable<EsfUserProfileDto> {
        let url_ = this.baseUrl + "/api/EsfProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EsfUserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EsfUserProfileDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<EsfUserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EsfUserProfileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EsfUserProfileDto>();
    }

    testConnection(isPowerUser?: boolean | undefined): Observable<TestConnectionResponseDto> {
        let url_ = this.baseUrl + "/api/EsfProfile/test-connection?";
        if (isPowerUser === null)
            throw new Error("The parameter 'isPowerUser' cannot be null.");
        else if (isPowerUser !== undefined)
            url_ += "isPowerUser=" + encodeURIComponent("" + isPowerUser) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestConnection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestConnection(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TestConnectionResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TestConnectionResponseDto>;
        }));
    }

    protected processTestConnection(response: HttpResponseBase): Observable<TestConnectionResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TestConnectionResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TestConnectionResponseDto>();
    }

    saveCredential(request: SetCredentialCommand): Observable<EsfUserProfileDto> {
        let url_ = this.baseUrl + "/api/EsfProfile/credential";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCredential(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCredential(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EsfUserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EsfUserProfileDto>;
        }));
    }

    protected processSaveCredential(response: HttpResponseBase): Observable<EsfUserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EsfUserProfileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EsfUserProfileDto>();
    }

    uploadAuthCertificate(password?: string | null | undefined, file?: FileParameter | null | undefined): Observable<EsfUserProfileDto> {
        let url_ = this.baseUrl + "/api/EsfProfile/auth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (password !== null && password !== undefined)
            content_.append("Password", password.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadAuthCertificate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadAuthCertificate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EsfUserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EsfUserProfileDto>;
        }));
    }

    protected processUploadAuthCertificate(response: HttpResponseBase): Observable<EsfUserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EsfUserProfileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EsfUserProfileDto>();
    }

    uploadSignCertificate(password?: string | null | undefined, file?: FileParameter | null | undefined): Observable<EsfUserProfileDto> {
        let url_ = this.baseUrl + "/api/EsfProfile/sign";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (password !== null && password !== undefined)
            content_.append("Password", password.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadSignCertificate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadSignCertificate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EsfUserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EsfUserProfileDto>;
        }));
    }

    protected processUploadSignCertificate(response: HttpResponseBase): Observable<EsfUserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EsfUserProfileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EsfUserProfileDto>();
    }

    uploadGostCertificate(password?: string | null | undefined, file?: FileParameter | null | undefined): Observable<EsfUserProfileDto> {
        let url_ = this.baseUrl + "/api/EsfProfile/gost";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (password !== null && password !== undefined)
            content_.append("Password", password.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadGostCertificate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadGostCertificate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EsfUserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EsfUserProfileDto>;
        }));
    }

    protected processUploadGostCertificate(response: HttpResponseBase): Observable<EsfUserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EsfUserProfileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EsfUserProfileDto>();
    }
}

@Injectable()
export class NotificationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:50852";
    }

    getSignalRConnectionInfo(): Observable<NegotiationResponse> {
        let url_ = this.baseUrl + "/api/Notification/negotiate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSignalRConnectionInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSignalRConnectionInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NegotiationResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NegotiationResponse>;
        }));
    }

    protected processGetSignalRConnectionInfo(response: HttpResponseBase): Observable<NegotiationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NegotiationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NegotiationResponse>();
    }

    getUnreadNotifications(): Observable<NotificationDto[]> {
        let url_ = this.baseUrl + "/api/Notification/unread-notifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnreadNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnreadNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationDto[]>;
        }));
    }

    protected processGetUnreadNotifications(response: HttpResponseBase): Observable<NotificationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDto[]>();
    }

    markAsRead(rowKey: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Notification/mark-as-read/{rowKey}";
        if (rowKey === undefined || rowKey === null)
            throw new Error("The parameter 'rowKey' must be defined.");
        url_ = url_.replace("{rowKey}", encodeURIComponent("" + rowKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMarkAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>();
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>();
    }

    markAsReadAll(): Observable<void> {
        let url_ = this.baseUrl + "/api/Notification/mark-as-read";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsReadAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsReadAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMarkAsReadAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>();
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>();
    }

    get(filter_DateFrom?: Date | null | undefined, filter_DateTo?: Date | null | undefined, filter_DocumentTypes?: string[] | null | undefined, filter_ActionTypes?: string[] | null | undefined, filter_DocumentIds?: string[] | null | undefined, paging_CurrentPage?: number | undefined, paging_ItemsPerPage?: number | undefined): Observable<NotificationListResponseDto> {
        let url_ = this.baseUrl + "/api/Notification/list?";
        if (filter_DateFrom !== undefined && filter_DateFrom !== null)
            url_ += "Filter.DateFrom=" + encodeURIComponent(filter_DateFrom ? "" + filter_DateFrom.toYearMonthDateString() : "") + "&";
        if (filter_DateTo !== undefined && filter_DateTo !== null)
            url_ += "Filter.DateTo=" + encodeURIComponent(filter_DateTo ? "" + filter_DateTo.toYearMonthDateString() : "") + "&";
        if (filter_DocumentTypes !== undefined && filter_DocumentTypes !== null)
            filter_DocumentTypes && filter_DocumentTypes.forEach(item => { url_ += "Filter.DocumentTypes=" + encodeURIComponent("" + item) + "&"; });
        if (filter_ActionTypes !== undefined && filter_ActionTypes !== null)
            filter_ActionTypes && filter_ActionTypes.forEach(item => { url_ += "Filter.ActionTypes=" + encodeURIComponent("" + item) + "&"; });
        if (filter_DocumentIds !== undefined && filter_DocumentIds !== null)
            filter_DocumentIds && filter_DocumentIds.forEach(item => { url_ += "Filter.DocumentIds=" + encodeURIComponent("" + item) + "&"; });
        if (paging_CurrentPage === null)
            throw new Error("The parameter 'paging_CurrentPage' cannot be null.");
        else if (paging_CurrentPage !== undefined)
            url_ += "Paging.CurrentPage=" + encodeURIComponent("" + paging_CurrentPage) + "&";
        if (paging_ItemsPerPage === null)
            throw new Error("The parameter 'paging_ItemsPerPage' cannot be null.");
        else if (paging_ItemsPerPage !== undefined)
            url_ += "Paging.ItemsPerPage=" + encodeURIComponent("" + paging_ItemsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationListResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationListResponseDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<NotificationListResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationListResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationListResponseDto>();
    }
}

@Injectable()
export class SignProcessClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:50852";
    }

    send(): Observable<AuthTicketSigningProcessResultDto> {
        let url_ = this.baseUrl + "/api/SignProcess/authTicket/sign";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthTicketSigningProcessResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthTicketSigningProcessResultDto>;
        }));
    }

    protected processSend(response: HttpResponseBase): Observable<AuthTicketSigningProcessResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthTicketSigningProcessResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthTicketSigningProcessResultDto>();
    }
}

@Injectable()
export class UserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:50852";
    }

    getUserProfile(): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/User/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileDto>;
        }));
    }

    protected processGetUserProfile(response: HttpResponseBase): Observable<UserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfileDto>();
    }
}

@Injectable()
export class DSignCallbackClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:50852";
    }

    processCallback(model: DocumentSignedRequestDto): Observable<void> {
        let url_ = this.baseUrl + "/api/DSignCallback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessCallback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessCallback(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProcessCallback(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>();
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>();
    }

    processMassSigningCallback(model: DocumentSignedRequestDto): Observable<void> {
        let url_ = this.baseUrl + "/api/DSignCallback/process-mass-signing-callback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessMassSigningCallback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessMassSigningCallback(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProcessMassSigningCallback(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>();
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>();
    }
}

@Injectable()
export class UserProfileClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:50852";
    }

    getUserProfileByUserId(userId?: string | undefined): Observable<EsfUserProfileDataResultDto> {
        let url_ = this.baseUrl + "/api/UserProfile/user-profile?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserProfileByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserProfileByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EsfUserProfileDataResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EsfUserProfileDataResultDto>;
        }));
    }

    protected processGetUserProfileByUserId(response: HttpResponseBase): Observable<EsfUserProfileDataResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EsfUserProfileDataResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EsfUserProfileDataResultDto>();
    }

    getEsfUserProfilesByUserIds(userIds?: string[] | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/UserProfile/user-profiles?";
        if (userIds !== undefined && userIds !== null)
            userIds && userIds.forEach(item => { url_ += "userIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEsfUserProfilesByUserIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEsfUserProfilesByUserIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetEsfUserProfilesByUserIds(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>();
    }
}

@Injectable()
export class GroupRoleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:50852";
    }

    getAllGroupRoles(): Observable<GroupRolesDto[]> {
        let url_ = this.baseUrl + "/api/admin/GroupRole/grouproles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGroupRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGroupRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GroupRolesDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GroupRolesDto[]>;
        }));
    }

    protected processGetAllGroupRoles(response: HttpResponseBase): Observable<GroupRolesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GroupRolesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupRolesDto[]>();
    }

    putGroupRoles(dto: PutGroupRolesDto): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/GroupRole/grouproles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto.toJSON());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutGroupRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutGroupRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPutGroupRoles(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>();
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>();
    }

    deleteGroupRoles(groupId?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/GroupRole/grouproles?";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGroupRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGroupRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteGroupRoles(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>();
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>();
    }

    getGroupRoles(groupId: string): Observable<RoleType[]> {
        let url_ = this.baseUrl + "/api/admin/GroupRole/grouproles/{groupId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGroupRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleType[]>;
        }));
    }

    protected processGetGroupRoles(response: HttpResponseBase): Observable<RoleType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleType[]>();
    }
}

export class ImportAwpsResultDto implements IImportAwpsResultDto {
    added!: number;
    updated!: number;

    constructor(data?: IImportAwpsResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.added = _data["added"];
            this.updated = _data["updated"];
        }
    }

    static fromJS(data: any): ImportAwpsResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportAwpsResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["added"] = this.added;
        data["updated"] = this.updated;
        return data;
    }
}

export interface IImportAwpsResultDto {
    added: number;
    updated: number;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class AwpListResponseDto implements IAwpListResponseDto {
    awps?: AwpDto[] | undefined;
    paging?: PagingModel | undefined;

    constructor(data?: IAwpListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["awps"])) {
                this.awps = [] as any;
                for (let item of _data["awps"])
                    this.awps!.push(AwpDto.fromJS(item));
            }
            this.paging = _data["paging"] ? PagingModel.fromJS(_data["paging"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AwpListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new AwpListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.awps)) {
            data["awps"] = [];
            for (let item of this.awps)
                data["awps"].push(item.toJSON());
        }
        data["paging"] = this.paging ? this.paging.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAwpListResponseDto {
    awps?: AwpDto[] | undefined;
    paging?: PagingModel | undefined;
}

export class AwpDto implements IAwpDto {
    id!: number;
    registrationNumber?: string | undefined;
    number?: string | undefined;
    awpDate?: Date | undefined;
    awpSignDate?: Date | undefined;
    senderTin?: string | undefined;
    recipientTin?: string | undefined;
    status!: AwpStatus;

    constructor(data?: IAwpDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.registrationNumber = _data["registrationNumber"];
            this.number = _data["number"];
            this.awpDate = _data["awpDate"] ? new Date(_data["awpDate"].toString()) : <any>undefined;
            this.awpSignDate = _data["awpSignDate"] ? new Date(_data["awpSignDate"].toString()) : <any>undefined;
            this.senderTin = _data["senderTin"];
            this.recipientTin = _data["recipientTin"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): AwpDto {
        data = typeof data === 'object' ? data : {};
        let result = new AwpDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["registrationNumber"] = this.registrationNumber;
        data["number"] = this.number;
        data["awpDate"] = this.awpDate ? this.awpDate.toYearMonthDateString() : <any>undefined;
        data["awpSignDate"] = this.awpSignDate ? this.awpSignDate.toYearMonthDateString() : <any>undefined;
        data["senderTin"] = this.senderTin;
        data["recipientTin"] = this.recipientTin;
        data["status"] = this.status;
        return data;
    }
}

export interface IAwpDto {
    id: number;
    registrationNumber?: string | undefined;
    number?: string | undefined;
    awpDate?: Date | undefined;
    awpSignDate?: Date | undefined;
    senderTin?: string | undefined;
    recipientTin?: string | undefined;
    status: AwpStatus;
}

export enum AwpStatus {
    DRAFT = "DRAFT",
    NOT_VIEWED = "NOT_VIEWED",
    DELIVERED = "DELIVERED",
    CREATED = "CREATED",
    IMPORTED = "IMPORTED",
    FAILED = "FAILED",
    CONFIRMED = "CONFIRMED",
    DECLINED = "DECLINED",
    REVOKED = "REVOKED",
    IN_TERMINATING = "IN_TERMINATING",
    TERMINATED = "TERMINATED",
    CANCELED = "CANCELED",
}

export class PagingModel implements IPagingModel {
    totalRecords!: number;
    currentPage!: number;
    itemsPerPage!: number;
    pageCount!: number;

    constructor(data?: IPagingModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalRecords = _data["totalRecords"];
            this.currentPage = _data["currentPage"];
            this.itemsPerPage = _data["itemsPerPage"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagingModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagingModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRecords"] = this.totalRecords;
        data["currentPage"] = this.currentPage;
        data["itemsPerPage"] = this.itemsPerPage;
        data["pageCount"] = this.pageCount;
        return data;
    }
}

export interface IPagingModel {
    totalRecords: number;
    currentPage: number;
    itemsPerPage: number;
    pageCount: number;
}

export enum SortingOrder {
    Asc = "Asc",
    Desc = "Desc",
}

export class AwpWorksPerformedDto implements IAwpWorksPerformedDto {
    currencyCode?: string | undefined;
    rate?: number | undefined;
    total?: string | undefined;
    totalNdsAmount!: number;
    totalSumWithTax!: number;
    totalSumWithoutTax!: number;
    totalTurnoverSize!: number;
    awpWorks?: AwpWorkDto[] | undefined;

    constructor(data?: IAwpWorksPerformedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyCode = _data["currencyCode"];
            this.rate = _data["rate"];
            this.total = _data["total"];
            this.totalNdsAmount = _data["totalNdsAmount"];
            this.totalSumWithTax = _data["totalSumWithTax"];
            this.totalSumWithoutTax = _data["totalSumWithoutTax"];
            this.totalTurnoverSize = _data["totalTurnoverSize"];
            if (Array.isArray(_data["awpWorks"])) {
                this.awpWorks = [] as any;
                for (let item of _data["awpWorks"])
                    this.awpWorks!.push(AwpWorkDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AwpWorksPerformedDto {
        data = typeof data === 'object' ? data : {};
        let result = new AwpWorksPerformedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyCode"] = this.currencyCode;
        data["rate"] = this.rate;
        data["total"] = this.total;
        data["totalNdsAmount"] = this.totalNdsAmount;
        data["totalSumWithTax"] = this.totalSumWithTax;
        data["totalSumWithoutTax"] = this.totalSumWithoutTax;
        data["totalTurnoverSize"] = this.totalTurnoverSize;
        if (Array.isArray(this.awpWorks)) {
            data["awpWorks"] = [];
            for (let item of this.awpWorks)
                data["awpWorks"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAwpWorksPerformedDto {
    currencyCode?: string | undefined;
    rate?: number | undefined;
    total?: string | undefined;
    totalNdsAmount: number;
    totalSumWithTax: number;
    totalSumWithoutTax: number;
    totalTurnoverSize: number;
    awpWorks?: AwpWorkDto[] | undefined;
}

export class AwpWorkDto implements IAwpWorkDto {
    additionalInfo?: string | undefined;
    measureUnitCode?: string | undefined;
    name?: string | undefined;
    systemName?: string | undefined;
    ndsAmount?: number | undefined;
    ndsRate!: number;
    quantity?: number | undefined;
    sumWithTax!: number;
    sumWithoutTax!: number;
    turnoverSize!: number;
    unitPriceWithoutTax!: number;

    constructor(data?: IAwpWorkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.additionalInfo = _data["additionalInfo"];
            this.measureUnitCode = _data["measureUnitCode"];
            this.name = _data["name"];
            this.systemName = _data["systemName"];
            this.ndsAmount = _data["ndsAmount"];
            this.ndsRate = _data["ndsRate"];
            this.quantity = _data["quantity"];
            this.sumWithTax = _data["sumWithTax"];
            this.sumWithoutTax = _data["sumWithoutTax"];
            this.turnoverSize = _data["turnoverSize"];
            this.unitPriceWithoutTax = _data["unitPriceWithoutTax"];
        }
    }

    static fromJS(data: any): AwpWorkDto {
        data = typeof data === 'object' ? data : {};
        let result = new AwpWorkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additionalInfo"] = this.additionalInfo;
        data["measureUnitCode"] = this.measureUnitCode;
        data["name"] = this.name;
        data["systemName"] = this.systemName;
        data["ndsAmount"] = this.ndsAmount;
        data["ndsRate"] = this.ndsRate;
        data["quantity"] = this.quantity;
        data["sumWithTax"] = this.sumWithTax;
        data["sumWithoutTax"] = this.sumWithoutTax;
        data["turnoverSize"] = this.turnoverSize;
        data["unitPriceWithoutTax"] = this.unitPriceWithoutTax;
        return data;
    }
}

export interface IAwpWorkDto {
    additionalInfo?: string | undefined;
    measureUnitCode?: string | undefined;
    name?: string | undefined;
    systemName?: string | undefined;
    ndsAmount?: number | undefined;
    ndsRate: number;
    quantity?: number | undefined;
    sumWithTax: number;
    sumWithoutTax: number;
    turnoverSize: number;
    unitPriceWithoutTax: number;
}

export class AwpEsfResponseDto implements IAwpEsfResponseDto {
    esfNumber?: string | undefined;
    invoiceDate!: Date;
    contractNumber?: string | undefined;
    awps?: AwpResponse[] | undefined;

    constructor(data?: IAwpEsfResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.esfNumber = _data["esfNumber"];
            this.invoiceDate = _data["invoiceDate"] ? new Date(_data["invoiceDate"].toString()) : <any>undefined;
            this.contractNumber = _data["contractNumber"];
            if (Array.isArray(_data["awps"])) {
                this.awps = [] as any;
                for (let item of _data["awps"])
                    this.awps!.push(AwpResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AwpEsfResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new AwpEsfResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["esfNumber"] = this.esfNumber;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toYearMonthDateString() : <any>undefined;
        data["contractNumber"] = this.contractNumber;
        if (Array.isArray(this.awps)) {
            data["awps"] = [];
            for (let item of this.awps)
                data["awps"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAwpEsfResponseDto {
    esfNumber?: string | undefined;
    invoiceDate: Date;
    contractNumber?: string | undefined;
    awps?: AwpResponse[] | undefined;
}

export class AwpResponse implements IAwpResponse {
    aoaNumber?: string | undefined;
    awpStatus!: AwpStatus;
    aoaAmount!: number;
    vatAmount!: number;

    constructor(data?: IAwpResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.aoaNumber = _data["aoaNumber"];
            this.awpStatus = _data["awpStatus"];
            this.aoaAmount = _data["aoaAmount"];
            this.vatAmount = _data["vatAmount"];
        }
    }

    static fromJS(data: any): AwpResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AwpResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aoaNumber"] = this.aoaNumber;
        data["awpStatus"] = this.awpStatus;
        data["aoaAmount"] = this.aoaAmount;
        data["vatAmount"] = this.vatAmount;
        return data;
    }
}

export interface IAwpResponse {
    aoaNumber?: string | undefined;
    awpStatus: AwpStatus;
    aoaAmount: number;
    vatAmount: number;
}

export class AwpConiResponseDto implements IAwpConiResponseDto {
    status?: string | undefined;
    registrationNumber?: string | undefined;
    contract?: string | undefined;
    performedDate?: Date | undefined;
    date?: Date | undefined;
    lastUpdateDate?: Date | undefined;
    number?: string | undefined;
    senderTin?: string | undefined;
    iban?: string | undefined;
    currency?: string | undefined;
    totalAoaNetAmount?: string | undefined;
    totalAoaTaxAmount?: string | undefined;

    constructor(data?: IAwpConiResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.registrationNumber = _data["registrationNumber"];
            this.contract = _data["contract"];
            this.performedDate = _data["performedDate"] ? new Date(_data["performedDate"].toString()) : <any>undefined;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.lastUpdateDate = _data["lastUpdateDate"] ? new Date(_data["lastUpdateDate"].toString()) : <any>undefined;
            this.number = _data["number"];
            this.senderTin = _data["senderTin"];
            this.iban = _data["iban"];
            this.currency = _data["currency"];
            this.totalAoaNetAmount = _data["totalAoaNetAmount"];
            this.totalAoaTaxAmount = _data["totalAoaTaxAmount"];
        }
    }

    static fromJS(data: any): AwpConiResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new AwpConiResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["registrationNumber"] = this.registrationNumber;
        data["contract"] = this.contract;
        data["performedDate"] = this.performedDate ? this.performedDate.toYearMonthDateString() : <any>undefined;
        data["date"] = this.date ? this.date.toYearMonthDateString() : <any>undefined;
        data["lastUpdateDate"] = this.lastUpdateDate ? this.lastUpdateDate.toYearMonthDateString() : <any>undefined;
        data["number"] = this.number;
        data["senderTin"] = this.senderTin;
        data["iban"] = this.iban;
        data["currency"] = this.currency;
        data["totalAoaNetAmount"] = this.totalAoaNetAmount;
        data["totalAoaTaxAmount"] = this.totalAoaTaxAmount;
        return data;
    }
}

export interface IAwpConiResponseDto {
    status?: string | undefined;
    registrationNumber?: string | undefined;
    contract?: string | undefined;
    performedDate?: Date | undefined;
    date?: Date | undefined;
    lastUpdateDate?: Date | undefined;
    number?: string | undefined;
    senderTin?: string | undefined;
    iban?: string | undefined;
    currency?: string | undefined;
    totalAoaNetAmount?: string | undefined;
    totalAoaTaxAmount?: string | undefined;
}

export class ImportInvoicesInitialResultDto implements IImportInvoicesInitialResultDto {
    addedInbound!: number;
    addedOutbound!: number;

    constructor(data?: IImportInvoicesInitialResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addedInbound = _data["addedInbound"];
            this.addedOutbound = _data["addedOutbound"];
        }
    }

    static fromJS(data: any): ImportInvoicesInitialResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportInvoicesInitialResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addedInbound"] = this.addedInbound;
        data["addedOutbound"] = this.addedOutbound;
        return data;
    }
}

export interface IImportInvoicesInitialResultDto {
    addedInbound: number;
    addedOutbound: number;
}

export class ImportInvoicesRegularResultDto implements IImportInvoicesRegularResultDto {
    inboundAdded!: number;
    inboundUpdated!: number;
    outboundAdded!: number;
    outboundUpdated!: number;

    constructor(data?: IImportInvoicesRegularResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inboundAdded = _data["inboundAdded"];
            this.inboundUpdated = _data["inboundUpdated"];
            this.outboundAdded = _data["outboundAdded"];
            this.outboundUpdated = _data["outboundUpdated"];
        }
    }

    static fromJS(data: any): ImportInvoicesRegularResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportInvoicesRegularResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inboundAdded"] = this.inboundAdded;
        data["inboundUpdated"] = this.inboundUpdated;
        data["outboundAdded"] = this.outboundAdded;
        data["outboundUpdated"] = this.outboundUpdated;
        return data;
    }
}

export interface IImportInvoicesRegularResultDto {
    inboundAdded: number;
    inboundUpdated: number;
    outboundAdded: number;
    outboundUpdated: number;
}

export class InvoiceFullDto implements IInvoiceFullDto {
    id?: number | undefined;
    jdeArInvoiceId?: number | undefined;
    num?: string | undefined;
    registrationNumber?: string | undefined;
    invoiceType!: InvoiceType;
    date!: Date;
    turnoverDate!: Date;
    seller?: InvoiceSellerDto | undefined;
    customer?: InvoiceCustomerDto | undefined;
    consignor?: InvoiceConsignorDto | undefined;
    consignee?: InvoiceConsigneeDto | undefined;
    deliveryTerm?: InvoiceDeliveryTermDto | undefined;
    publicOffice?: InvoicePublicOfficeDto | undefined;
    deliveryDocDate?: Date | undefined;
    deliveryDocNum?: string | undefined;
    relatedInvoice?: RelatedInvoiceDto | undefined;
    currencyCode?: string | undefined;
    currencyRate?: number | undefined;
    ndsRateType?: InvoiceNdsRateType | undefined;
    products?: InvoiceProductDto[] | undefined;
    addInf?: string | undefined;

    constructor(data?: IInvoiceFullDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jdeArInvoiceId = _data["jdeArInvoiceId"];
            this.num = _data["num"];
            this.registrationNumber = _data["registrationNumber"];
            this.invoiceType = _data["invoiceType"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.turnoverDate = _data["turnoverDate"] ? new Date(_data["turnoverDate"].toString()) : <any>undefined;
            this.seller = _data["seller"] ? InvoiceSellerDto.fromJS(_data["seller"]) : <any>undefined;
            this.customer = _data["customer"] ? InvoiceCustomerDto.fromJS(_data["customer"]) : <any>undefined;
            this.consignor = _data["consignor"] ? InvoiceConsignorDto.fromJS(_data["consignor"]) : <any>undefined;
            this.consignee = _data["consignee"] ? InvoiceConsigneeDto.fromJS(_data["consignee"]) : <any>undefined;
            this.deliveryTerm = _data["deliveryTerm"] ? InvoiceDeliveryTermDto.fromJS(_data["deliveryTerm"]) : <any>undefined;
            this.publicOffice = _data["publicOffice"] ? InvoicePublicOfficeDto.fromJS(_data["publicOffice"]) : <any>undefined;
            this.deliveryDocDate = _data["deliveryDocDate"] ? new Date(_data["deliveryDocDate"].toString()) : <any>undefined;
            this.deliveryDocNum = _data["deliveryDocNum"];
            this.relatedInvoice = _data["relatedInvoice"] ? RelatedInvoiceDto.fromJS(_data["relatedInvoice"]) : <any>undefined;
            this.currencyCode = _data["currencyCode"];
            this.currencyRate = _data["currencyRate"];
            this.ndsRateType = _data["ndsRateType"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(InvoiceProductDto.fromJS(item));
            }
            this.addInf = _data["addInf"];
        }
    }

    static fromJS(data: any): InvoiceFullDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceFullDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jdeArInvoiceId"] = this.jdeArInvoiceId;
        data["num"] = this.num;
        data["registrationNumber"] = this.registrationNumber;
        data["invoiceType"] = this.invoiceType;
        data["date"] = this.date ? this.date.toYearMonthDateString() : <any>undefined;
        data["turnoverDate"] = this.turnoverDate ? this.turnoverDate.toYearMonthDateString() : <any>undefined;
        data["seller"] = this.seller ? this.seller.toJSON() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["consignor"] = this.consignor ? this.consignor.toJSON() : <any>undefined;
        data["consignee"] = this.consignee ? this.consignee.toJSON() : <any>undefined;
        data["deliveryTerm"] = this.deliveryTerm ? this.deliveryTerm.toJSON() : <any>undefined;
        data["publicOffice"] = this.publicOffice ? this.publicOffice.toJSON() : <any>undefined;
        data["deliveryDocDate"] = this.deliveryDocDate ? this.deliveryDocDate.toYearMonthDateString() : <any>undefined;
        data["deliveryDocNum"] = this.deliveryDocNum;
        data["relatedInvoice"] = this.relatedInvoice ? this.relatedInvoice.toJSON() : <any>undefined;
        data["currencyCode"] = this.currencyCode;
        data["currencyRate"] = this.currencyRate;
        data["ndsRateType"] = this.ndsRateType;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["addInf"] = this.addInf;
        return data;
    }
}

export interface IInvoiceFullDto {
    id?: number | undefined;
    jdeArInvoiceId?: number | undefined;
    num?: string | undefined;
    registrationNumber?: string | undefined;
    invoiceType: InvoiceType;
    date: Date;
    turnoverDate: Date;
    seller?: InvoiceSellerDto | undefined;
    customer?: InvoiceCustomerDto | undefined;
    consignor?: InvoiceConsignorDto | undefined;
    consignee?: InvoiceConsigneeDto | undefined;
    deliveryTerm?: InvoiceDeliveryTermDto | undefined;
    publicOffice?: InvoicePublicOfficeDto | undefined;
    deliveryDocDate?: Date | undefined;
    deliveryDocNum?: string | undefined;
    relatedInvoice?: RelatedInvoiceDto | undefined;
    currencyCode?: string | undefined;
    currencyRate?: number | undefined;
    ndsRateType?: InvoiceNdsRateType | undefined;
    products?: InvoiceProductDto[] | undefined;
    addInf?: string | undefined;
}

export enum InvoiceType {
    ORDINARY_INVOICE = "ORDINARY_INVOICE",
    FIXED_INVOICE = "FIXED_INVOICE",
    ADDITIONAL_INVOICE = "ADDITIONAL_INVOICE",
}

export class InvoiceSellerDto implements IInvoiceSellerDto {
    isBranchNonResident?: boolean | undefined;
    statuses?: InvoiceSellerType[] | undefined;
    trailer?: string | undefined;
    kbe?: string | undefined;
    iik?: string | undefined;
    bik?: string | undefined;
    bank?: string | undefined;

    constructor(data?: IInvoiceSellerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isBranchNonResident = _data["isBranchNonResident"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(item);
            }
            this.trailer = _data["trailer"];
            this.kbe = _data["kbe"];
            this.iik = _data["iik"];
            this.bik = _data["bik"];
            this.bank = _data["bank"];
        }
    }

    static fromJS(data: any): InvoiceSellerDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceSellerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isBranchNonResident"] = this.isBranchNonResident;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item);
        }
        data["trailer"] = this.trailer;
        data["kbe"] = this.kbe;
        data["iik"] = this.iik;
        data["bik"] = this.bik;
        data["bank"] = this.bank;
        return data;
    }
}

export interface IInvoiceSellerDto {
    isBranchNonResident?: boolean | undefined;
    statuses?: InvoiceSellerType[] | undefined;
    trailer?: string | undefined;
    kbe?: string | undefined;
    iik?: string | undefined;
    bik?: string | undefined;
    bank?: string | undefined;
}

export enum InvoiceSellerType {
    COMMITTENT = "COMMITTENT",
    BROKER = "BROKER",
    FORWARDER = "FORWARDER",
    LESSOR = "LESSOR",
    JOINT_ACTIVITY_PARTICIPANT = "JOINT_ACTIVITY_PARTICIPANT",
    SHARING_AGREEMENT_PARTICIPANT = "SHARING_AGREEMENT_PARTICIPANT",
    EXPORTER = "EXPORTER",
    TRANSPORTER = "TRANSPORTER",
    PRINCIPAL = "PRINCIPAL",
    LAWYER = "LAWYER",
    BAILIFF = "BAILIFF",
    MEDIATOR = "MEDIATOR",
    NOTARY = "NOTARY",
}

export class InvoiceCustomerDto implements IInvoiceCustomerDto {
    tin?: string | undefined;
    branchTin?: string | undefined;
    reorganizedTin?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    countryCode?: string | undefined;
    trailer?: string | undefined;
    statuses?: InvoiceCustomerType[] | undefined;

    constructor(data?: IInvoiceCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tin = _data["tin"];
            this.branchTin = _data["branchTin"];
            this.reorganizedTin = _data["reorganizedTin"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.countryCode = _data["countryCode"];
            this.trailer = _data["trailer"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tin"] = this.tin;
        data["branchTin"] = this.branchTin;
        data["reorganizedTin"] = this.reorganizedTin;
        data["name"] = this.name;
        data["address"] = this.address;
        data["countryCode"] = this.countryCode;
        data["trailer"] = this.trailer;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item);
        }
        return data;
    }
}

export interface IInvoiceCustomerDto {
    tin?: string | undefined;
    branchTin?: string | undefined;
    reorganizedTin?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    countryCode?: string | undefined;
    trailer?: string | undefined;
    statuses?: InvoiceCustomerType[] | undefined;
}

export enum InvoiceCustomerType {
    COMMITTENT = "COMMITTENT",
    BROKER = "BROKER",
    LESSEE = "LESSEE",
    JOINT_ACTIVITY_PARTICIPANT = "JOINT_ACTIVITY_PARTICIPANT",
    PUBLIC_OFFICE = "PUBLIC_OFFICE",
    NONRESIDENT = "NONRESIDENT",
    SHARING_AGREEMENT_PARTICIPANT = "SHARING_AGREEMENT_PARTICIPANT",
    PRINCIPAL = "PRINCIPAL",
    RETAIL = "RETAIL",
    INDIVIDUAL = "INDIVIDUAL",
    LAWYER = "LAWYER",
    BAILIFF = "BAILIFF",
    MEDIATOR = "MEDIATOR",
    NOTARY = "NOTARY",
}

export class InvoiceConsignorDto implements IInvoiceConsignorDto {
    tin?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;

    constructor(data?: IInvoiceConsignorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tin = _data["tin"];
            this.name = _data["name"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): InvoiceConsignorDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceConsignorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tin"] = this.tin;
        data["name"] = this.name;
        data["address"] = this.address;
        return data;
    }
}

export interface IInvoiceConsignorDto {
    tin?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
}

export class InvoiceConsigneeDto implements IInvoiceConsigneeDto {
    tin?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    countryCode?: string | undefined;

    constructor(data?: IInvoiceConsigneeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tin = _data["tin"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): InvoiceConsigneeDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceConsigneeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tin"] = this.tin;
        data["name"] = this.name;
        data["address"] = this.address;
        data["countryCode"] = this.countryCode;
        return data;
    }
}

export interface IInvoiceConsigneeDto {
    tin?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    countryCode?: string | undefined;
}

export class InvoiceDeliveryTermDto implements IInvoiceDeliveryTermDto {
    hasContract!: boolean;
    contractNum?: string | undefined;
    accountNumber?: string | undefined;
    contractDate?: Date | undefined;
    term?: string | undefined;
    transportTypeCode?: string | undefined;
    warrant?: string | undefined;
    warrantDate?: Date | undefined;
    destination?: string | undefined;
    deliveryConditionCode?: string | undefined;

    constructor(data?: IInvoiceDeliveryTermDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasContract = _data["hasContract"];
            this.contractNum = _data["contractNum"];
            this.accountNumber = _data["accountNumber"];
            this.contractDate = _data["contractDate"] ? new Date(_data["contractDate"].toString()) : <any>undefined;
            this.term = _data["term"];
            this.transportTypeCode = _data["transportTypeCode"];
            this.warrant = _data["warrant"];
            this.warrantDate = _data["warrantDate"] ? new Date(_data["warrantDate"].toString()) : <any>undefined;
            this.destination = _data["destination"];
            this.deliveryConditionCode = _data["deliveryConditionCode"];
        }
    }

    static fromJS(data: any): InvoiceDeliveryTermDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDeliveryTermDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasContract"] = this.hasContract;
        data["contractNum"] = this.contractNum;
        data["accountNumber"] = this.accountNumber;
        data["contractDate"] = this.contractDate ? this.contractDate.toYearMonthDateString() : <any>undefined;
        data["term"] = this.term;
        data["transportTypeCode"] = this.transportTypeCode;
        data["warrant"] = this.warrant;
        data["warrantDate"] = this.warrantDate ? this.warrantDate.toYearMonthDateString() : <any>undefined;
        data["destination"] = this.destination;
        data["deliveryConditionCode"] = this.deliveryConditionCode;
        return data;
    }
}

export interface IInvoiceDeliveryTermDto {
    hasContract: boolean;
    contractNum?: string | undefined;
    accountNumber?: string | undefined;
    contractDate?: Date | undefined;
    term?: string | undefined;
    transportTypeCode?: string | undefined;
    warrant?: string | undefined;
    warrantDate?: Date | undefined;
    destination?: string | undefined;
    deliveryConditionCode?: string | undefined;
}

export class InvoicePublicOfficeDto implements IInvoicePublicOfficeDto {
    bik?: string | undefined;
    iik?: string | undefined;
    payPurpose?: string | undefined;
    productCode?: string | undefined;

    constructor(data?: IInvoicePublicOfficeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bik = _data["bik"];
            this.iik = _data["iik"];
            this.payPurpose = _data["payPurpose"];
            this.productCode = _data["productCode"];
        }
    }

    static fromJS(data: any): InvoicePublicOfficeDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePublicOfficeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bik"] = this.bik;
        data["iik"] = this.iik;
        data["payPurpose"] = this.payPurpose;
        data["productCode"] = this.productCode;
        return data;
    }
}

export interface IInvoicePublicOfficeDto {
    bik?: string | undefined;
    iik?: string | undefined;
    payPurpose?: string | undefined;
    productCode?: string | undefined;
}

export class RelatedInvoiceDto implements IRelatedInvoiceDto {
    date!: Date;
    num?: string | undefined;
    registrationNumber?: string | undefined;

    constructor(data?: IRelatedInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.num = _data["num"];
            this.registrationNumber = _data["registrationNumber"];
        }
    }

    static fromJS(data: any): RelatedInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new RelatedInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toYearMonthDateString() : <any>undefined;
        data["num"] = this.num;
        data["registrationNumber"] = this.registrationNumber;
        return data;
    }
}

export interface IRelatedInvoiceDto {
    date: Date;
    num?: string | undefined;
    registrationNumber?: string | undefined;
}

export enum InvoiceNdsRateType {
    WITHOUT_NDS_NOT_KZ = "WITHOUT_NDS_NOT_KZ",
}

export class InvoiceProductDto implements IInvoiceProductDto {
    productNumberInSnt?: string | undefined;
    truOriginCode?: string | undefined;
    description?: string | undefined;
    tnvedName?: string | undefined;
    unitCode?: string | undefined;
    measureUnitId?: number | undefined;
    quantity?: number | undefined;
    unitPrice?: number | undefined;
    priceWithoutTax!: number;
    exciseRate?: number | undefined;
    exciseAmount?: number | undefined;
    turnoverSize!: number;
    ndsRate?: number | undefined;
    ndsAmount?: number | undefined;
    priceWithTax!: number;
    productDeclaration?: string | undefined;
    productNumberInDeclaration?: string | undefined;
    additional?: string | undefined;
    catalogTruId?: string | undefined;

    constructor(data?: IInvoiceProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productNumberInSnt = _data["productNumberInSnt"];
            this.truOriginCode = _data["truOriginCode"];
            this.description = _data["description"];
            this.tnvedName = _data["tnvedName"];
            this.unitCode = _data["unitCode"];
            this.measureUnitId = _data["measureUnitId"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
            this.priceWithoutTax = _data["priceWithoutTax"];
            this.exciseRate = _data["exciseRate"];
            this.exciseAmount = _data["exciseAmount"];
            this.turnoverSize = _data["turnoverSize"];
            this.ndsRate = _data["ndsRate"];
            this.ndsAmount = _data["ndsAmount"];
            this.priceWithTax = _data["priceWithTax"];
            this.productDeclaration = _data["productDeclaration"];
            this.productNumberInDeclaration = _data["productNumberInDeclaration"];
            this.additional = _data["additional"];
            this.catalogTruId = _data["catalogTruId"];
        }
    }

    static fromJS(data: any): InvoiceProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productNumberInSnt"] = this.productNumberInSnt;
        data["truOriginCode"] = this.truOriginCode;
        data["description"] = this.description;
        data["tnvedName"] = this.tnvedName;
        data["unitCode"] = this.unitCode;
        data["measureUnitId"] = this.measureUnitId;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["priceWithoutTax"] = this.priceWithoutTax;
        data["exciseRate"] = this.exciseRate;
        data["exciseAmount"] = this.exciseAmount;
        data["turnoverSize"] = this.turnoverSize;
        data["ndsRate"] = this.ndsRate;
        data["ndsAmount"] = this.ndsAmount;
        data["priceWithTax"] = this.priceWithTax;
        data["productDeclaration"] = this.productDeclaration;
        data["productNumberInDeclaration"] = this.productNumberInDeclaration;
        data["additional"] = this.additional;
        data["catalogTruId"] = this.catalogTruId;
        return data;
    }
}

export interface IInvoiceProductDto {
    productNumberInSnt?: string | undefined;
    truOriginCode?: string | undefined;
    description?: string | undefined;
    tnvedName?: string | undefined;
    unitCode?: string | undefined;
    measureUnitId?: number | undefined;
    quantity?: number | undefined;
    unitPrice?: number | undefined;
    priceWithoutTax: number;
    exciseRate?: number | undefined;
    exciseAmount?: number | undefined;
    turnoverSize: number;
    ndsRate?: number | undefined;
    ndsAmount?: number | undefined;
    priceWithTax: number;
    productDeclaration?: string | undefined;
    productNumberInDeclaration?: string | undefined;
    additional?: string | undefined;
    catalogTruId?: string | undefined;
}

export class HttpValidationProblemDetails extends ProblemDetails implements IHttpValidationProblemDetails {
    errors!: { [key: string]: string[]; };

    [key: string]: any;

    constructor(data?: IHttpValidationProblemDetails) {
        super(data);
        if (!data) {
            this.errors = {};
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHttpValidationProblemDetails extends IProblemDetails {
    errors: { [key: string]: string[]; };

    [key: string]: any;
}

export class ValidationProblemDetails extends HttpValidationProblemDetails implements IValidationProblemDetails {
    errors!: { [key: string]: string[]; };

    [key: string]: any;

    constructor(data?: IValidationProblemDetails) {
        super(data);
        if (!data) {
            this.errors = {};
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IValidationProblemDetails extends IHttpValidationProblemDetails {
    errors: { [key: string]: string[]; };

    [key: string]: any;
}

export class InvoiceDto implements IInvoiceDto {
    id?: number | undefined;
    jdeArInvoiceId?: number | undefined;
    num!: string;
    turnoverDate!: Date;
    seller!: InvoiceSellerDto;
    customer!: InvoiceCustomerDto;
    consignor!: InvoiceConsignorDto;
    consignee!: InvoiceConsigneeDto;
    deliveryTerm!: InvoiceDeliveryTermDto;
    publicOffice?: InvoicePublicOfficeDto | undefined;
    deliveryDocDate?: Date | undefined;
    deliveryDocNum?: string | undefined;
    currencyCode?: string | undefined;
    currencyRate?: number | undefined;
    ndsRateType?: InvoiceNdsRateType | undefined;
    products!: InvoiceProductDto[];
    addInf?: string | undefined;
    localTimezoneOffsetMinutes!: number;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.seller = new InvoiceSellerDto();
            this.customer = new InvoiceCustomerDto();
            this.consignor = new InvoiceConsignorDto();
            this.consignee = new InvoiceConsigneeDto();
            this.deliveryTerm = new InvoiceDeliveryTermDto();
            this.products = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jdeArInvoiceId = _data["jdeArInvoiceId"];
            this.num = _data["num"];
            this.turnoverDate = _data["turnoverDate"] ? new Date(_data["turnoverDate"].toString()) : <any>undefined;
            this.seller = _data["seller"] ? InvoiceSellerDto.fromJS(_data["seller"]) : new InvoiceSellerDto();
            this.customer = _data["customer"] ? InvoiceCustomerDto.fromJS(_data["customer"]) : new InvoiceCustomerDto();
            this.consignor = _data["consignor"] ? InvoiceConsignorDto.fromJS(_data["consignor"]) : new InvoiceConsignorDto();
            this.consignee = _data["consignee"] ? InvoiceConsigneeDto.fromJS(_data["consignee"]) : new InvoiceConsigneeDto();
            this.deliveryTerm = _data["deliveryTerm"] ? InvoiceDeliveryTermDto.fromJS(_data["deliveryTerm"]) : new InvoiceDeliveryTermDto();
            this.publicOffice = _data["publicOffice"] ? InvoicePublicOfficeDto.fromJS(_data["publicOffice"]) : <any>undefined;
            this.deliveryDocDate = _data["deliveryDocDate"] ? new Date(_data["deliveryDocDate"].toString()) : <any>undefined;
            this.deliveryDocNum = _data["deliveryDocNum"];
            this.currencyCode = _data["currencyCode"];
            this.currencyRate = _data["currencyRate"];
            this.ndsRateType = _data["ndsRateType"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(InvoiceProductDto.fromJS(item));
            }
            this.addInf = _data["addInf"];
            this.localTimezoneOffsetMinutes = _data["localTimezoneOffsetMinutes"];
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jdeArInvoiceId"] = this.jdeArInvoiceId;
        data["num"] = this.num;
        data["turnoverDate"] = this.turnoverDate ? this.turnoverDate.toYearMonthDateString() : <any>undefined;
        data["seller"] = this.seller ? this.seller.toJSON() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["consignor"] = this.consignor ? this.consignor.toJSON() : <any>undefined;
        data["consignee"] = this.consignee ? this.consignee.toJSON() : <any>undefined;
        data["deliveryTerm"] = this.deliveryTerm ? this.deliveryTerm.toJSON() : <any>undefined;
        data["publicOffice"] = this.publicOffice ? this.publicOffice.toJSON() : <any>undefined;
        data["deliveryDocDate"] = this.deliveryDocDate ? this.deliveryDocDate.toYearMonthDateString() : <any>undefined;
        data["deliveryDocNum"] = this.deliveryDocNum;
        data["currencyCode"] = this.currencyCode;
        data["currencyRate"] = this.currencyRate;
        data["ndsRateType"] = this.ndsRateType;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["addInf"] = this.addInf;
        data["localTimezoneOffsetMinutes"] = this.localTimezoneOffsetMinutes;
        return data;
    }
}

export interface IInvoiceDto {
    id?: number | undefined;
    jdeArInvoiceId?: number | undefined;
    num: string;
    turnoverDate: Date;
    seller: InvoiceSellerDto;
    customer: InvoiceCustomerDto;
    consignor: InvoiceConsignorDto;
    consignee: InvoiceConsigneeDto;
    deliveryTerm: InvoiceDeliveryTermDto;
    publicOffice?: InvoicePublicOfficeDto | undefined;
    deliveryDocDate?: Date | undefined;
    deliveryDocNum?: string | undefined;
    currencyCode?: string | undefined;
    currencyRate?: number | undefined;
    ndsRateType?: InvoiceNdsRateType | undefined;
    products: InvoiceProductDto[];
    addInf?: string | undefined;
    localTimezoneOffsetMinutes: number;
}

export class SigningPageForInvoiceResponseDto implements ISigningPageForInvoiceResponseDto {
    urlToSign?: string | undefined;

    constructor(data?: ISigningPageForInvoiceResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.urlToSign = _data["urlToSign"];
        }
    }

    static fromJS(data: any): SigningPageForInvoiceResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SigningPageForInvoiceResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["urlToSign"] = this.urlToSign;
        return data;
    }
}

export interface ISigningPageForInvoiceResponseDto {
    urlToSign?: string | undefined;
}

export class SendInvoiceDto implements ISendInvoiceDto {
    id!: number;
    localTimezoneOffsetMinutes!: number;

    constructor(data?: ISendInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localTimezoneOffsetMinutes = _data["localTimezoneOffsetMinutes"];
        }
    }

    static fromJS(data: any): SendInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localTimezoneOffsetMinutes"] = this.localTimezoneOffsetMinutes;
        return data;
    }
}

export interface ISendInvoiceDto {
    id: number;
    localTimezoneOffsetMinutes: number;
}

export class GetInvoiceByRegistrationNumberResponseDto implements IGetInvoiceByRegistrationNumberResponseDto {
    registrationNumber?: string | undefined;
    invoiceStatus?: InvoiceStatus | undefined;
    deliveryDocNum?: string | undefined;
    num?: string | undefined;
    date!: Date;
    contractNum?: string | undefined;
    tin?: string | undefined;
    turnoverDate!: Date;
    iban?: string | undefined;
    totalNdsRate?: string | undefined;
    totalPriceWithoutTax!: number;
    currencyCode?: string | undefined;
    totalNdsAmount?: number | undefined;

    constructor(data?: IGetInvoiceByRegistrationNumberResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registrationNumber = _data["registrationNumber"];
            this.invoiceStatus = _data["invoiceStatus"];
            this.deliveryDocNum = _data["deliveryDocNum"];
            this.num = _data["num"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.contractNum = _data["contractNum"];
            this.tin = _data["tin"];
            this.turnoverDate = _data["turnoverDate"] ? new Date(_data["turnoverDate"].toString()) : <any>undefined;
            this.iban = _data["iban"];
            this.totalNdsRate = _data["totalNdsRate"];
            this.totalPriceWithoutTax = _data["totalPriceWithoutTax"];
            this.currencyCode = _data["currencyCode"];
            this.totalNdsAmount = _data["totalNdsAmount"];
        }
    }

    static fromJS(data: any): GetInvoiceByRegistrationNumberResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetInvoiceByRegistrationNumberResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registrationNumber"] = this.registrationNumber;
        data["invoiceStatus"] = this.invoiceStatus;
        data["deliveryDocNum"] = this.deliveryDocNum;
        data["num"] = this.num;
        data["date"] = this.date ? this.date.toYearMonthDateString() : <any>undefined;
        data["contractNum"] = this.contractNum;
        data["tin"] = this.tin;
        data["turnoverDate"] = this.turnoverDate ? this.turnoverDate.toYearMonthDateString() : <any>undefined;
        data["iban"] = this.iban;
        data["totalNdsRate"] = this.totalNdsRate;
        data["totalPriceWithoutTax"] = this.totalPriceWithoutTax;
        data["currencyCode"] = this.currencyCode;
        data["totalNdsAmount"] = this.totalNdsAmount;
        return data;
    }
}

export interface IGetInvoiceByRegistrationNumberResponseDto {
    registrationNumber?: string | undefined;
    invoiceStatus?: InvoiceStatus | undefined;
    deliveryDocNum?: string | undefined;
    num?: string | undefined;
    date: Date;
    contractNum?: string | undefined;
    tin?: string | undefined;
    turnoverDate: Date;
    iban?: string | undefined;
    totalNdsRate?: string | undefined;
    totalPriceWithoutTax: number;
    currencyCode?: string | undefined;
    totalNdsAmount?: number | undefined;
}

export enum InvoiceStatus {
    IN_QUEUE = "IN_QUEUE",
    IN_PROCESSING = "IN_PROCESSING",
    CREATED = "CREATED",
    DELIVERED = "DELIVERED",
    CANCELED = "CANCELED",
    CANCELED_BY_OGD = "CANCELED_BY_OGD",
    CANCELED_BY_SNT_DECLINE = "CANCELED_BY_SNT_DECLINE",
    CANCELED_BY_SNT_REVOKE = "CANCELED_BY_SNT_REVOKE",
    REVOKED = "REVOKED",
    IMPORTED = "IMPORTED",
    DRAFT = "DRAFT",
    FAILED = "FAILED",
    DELETED = "DELETED",
    DECLINED = "DECLINED",
}

export class GetInvoicesForSigningResponseDto implements IGetInvoicesForSigningResponseDto {
    invoices?: GetInvoicesForSigningDto[] | undefined;
    paging?: PagingModel | undefined;

    constructor(data?: IGetInvoicesForSigningResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["invoices"])) {
                this.invoices = [] as any;
                for (let item of _data["invoices"])
                    this.invoices!.push(GetInvoicesForSigningDto.fromJS(item));
            }
            this.paging = _data["paging"] ? PagingModel.fromJS(_data["paging"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetInvoicesForSigningResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetInvoicesForSigningResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.invoices)) {
            data["invoices"] = [];
            for (let item of this.invoices)
                data["invoices"].push(item.toJSON());
        }
        data["paging"] = this.paging ? this.paging.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetInvoicesForSigningResponseDto {
    invoices?: GetInvoicesForSigningDto[] | undefined;
    paging?: PagingModel | undefined;
}

export class GetInvoicesForSigningDto implements IGetInvoicesForSigningDto {
    id!: number;
    invoiceType?: string | undefined;
    invoiceDate?: Date | undefined;
    invoiceTurnoverDate?: Date | undefined;
    invoiceNumber?: string | undefined;
    customerIinBin?: string | undefined;
    customerName?: string | undefined;
    contractNumber?: string | undefined;
    contractDate?: Date | undefined;
    currency?: string | undefined;
    taxableAmount?: number | undefined;
    taxAmount?: number | undefined;
    grossAmount?: number | undefined;
    jdeInvoiceId?: number | undefined;

    constructor(data?: IGetInvoicesForSigningDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invoiceType = _data["invoiceType"];
            this.invoiceDate = _data["invoiceDate"] ? new Date(_data["invoiceDate"].toString()) : <any>undefined;
            this.invoiceTurnoverDate = _data["invoiceTurnoverDate"] ? new Date(_data["invoiceTurnoverDate"].toString()) : <any>undefined;
            this.invoiceNumber = _data["invoiceNumber"];
            this.customerIinBin = _data["customerIinBin"];
            this.customerName = _data["customerName"];
            this.contractNumber = _data["contractNumber"];
            this.contractDate = _data["contractDate"] ? new Date(_data["contractDate"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.taxableAmount = _data["taxableAmount"];
            this.taxAmount = _data["taxAmount"];
            this.grossAmount = _data["grossAmount"];
            this.jdeInvoiceId = _data["jdeInvoiceId"];
        }
    }

    static fromJS(data: any): GetInvoicesForSigningDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetInvoicesForSigningDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoiceType"] = this.invoiceType;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toYearMonthDateString() : <any>undefined;
        data["invoiceTurnoverDate"] = this.invoiceTurnoverDate ? this.invoiceTurnoverDate.toYearMonthDateString() : <any>undefined;
        data["invoiceNumber"] = this.invoiceNumber;
        data["customerIinBin"] = this.customerIinBin;
        data["customerName"] = this.customerName;
        data["contractNumber"] = this.contractNumber;
        data["contractDate"] = this.contractDate ? this.contractDate.toYearMonthDateString() : <any>undefined;
        data["currency"] = this.currency;
        data["taxableAmount"] = this.taxableAmount;
        data["taxAmount"] = this.taxAmount;
        data["grossAmount"] = this.grossAmount;
        data["jdeInvoiceId"] = this.jdeInvoiceId;
        return data;
    }
}

export interface IGetInvoicesForSigningDto {
    id: number;
    invoiceType?: string | undefined;
    invoiceDate?: Date | undefined;
    invoiceTurnoverDate?: Date | undefined;
    invoiceNumber?: string | undefined;
    customerIinBin?: string | undefined;
    customerName?: string | undefined;
    contractNumber?: string | undefined;
    contractDate?: Date | undefined;
    currency?: string | undefined;
    taxableAmount?: number | undefined;
    taxAmount?: number | undefined;
    grossAmount?: number | undefined;
    jdeInvoiceId?: number | undefined;
}

export class SigningPageForMassInvoicesResponseDto implements ISigningPageForMassInvoicesResponseDto {
    urlToSign?: string | undefined;

    constructor(data?: ISigningPageForMassInvoicesResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.urlToSign = _data["urlToSign"];
        }
    }

    static fromJS(data: any): SigningPageForMassInvoicesResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SigningPageForMassInvoicesResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["urlToSign"] = this.urlToSign;
        return data;
    }
}

export interface ISigningPageForMassInvoicesResponseDto {
    urlToSign?: string | undefined;
}

export class SendMassInvoicesDto implements ISendMassInvoicesDto {
    ids?: number[] | undefined;
    localTimezoneOffsetMinutes!: number;

    constructor(data?: ISendMassInvoicesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.localTimezoneOffsetMinutes = _data["localTimezoneOffsetMinutes"];
        }
    }

    static fromJS(data: any): SendMassInvoicesDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendMassInvoicesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["localTimezoneOffsetMinutes"] = this.localTimezoneOffsetMinutes;
        return data;
    }
}

export interface ISendMassInvoicesDto {
    ids?: number[] | undefined;
    localTimezoneOffsetMinutes: number;
}

export class JdeArInvoiceDto implements IJdeArInvoiceDto {
    id!: number;
    jdeArF03B11DocumentNumber?: string | undefined;
    jdeArF03B11DocumentType?: string | undefined;
    jdeArF03B11DocumentCompany?: string | undefined;
    jdeArF03B11AddressNumber!: number;
    jdeArF03B11InvoiceDate!: Date;
    jdeArF03B11VoidFlag?: boolean | undefined;
    jdeArF03B11UserReservedDate?: Date | undefined;
    jdeArF03B11UserReservedReference?: string | undefined;
    jdeArF03B11StatementDate?: Date | undefined;
    jdeArF03B11Reference?: string | undefined;
    jdeArF03B11CurrencyCodeFrom?: string | undefined;
    jdeArF03B11NonTaxableAmount!: number;
    jdeArF03B11ForeignNonTaxableAmount!: number;
    jdeArF03B11AmountTaxable!: number;
    jdeArF03B11ForeignTaxableAmount!: number;
    jdeArF03B11ForeignTaxAmount!: number;
    jdeArF03B11CurrencyAmount!: number;
    jdeArF03B11GlDate?: Date | undefined;
    jdeArF03B11TaxArea?: string | undefined;
    jdeArF03B11TaxAmount!: number;
    jdeArF03B11ToCurrency?: string | undefined;
    jdeArF03B11ExchangeRateEffectiveDate?: Date | undefined;
    jdeArF03B11CurrencyConversionRate!: number;
    jdeArF03B11DeliveryCondition?: string | undefined;
    jdeArF03B11PaymentTermCode?: string | undefined;
    jdeGeneralLedgerBatchNumber!: number;
    jdeGeneralLedgerBatchDate?: Date | undefined;
    jdeGeneralLedgerBatchType?: string | undefined;
    jdeGeneralLedgerInvoiceDate?: Date | undefined;
    jdeGeneralLedgerCompany?: string | undefined;
    jdeGeneralLedgerBatchStatus?: string | undefined;
    jdeAddressBookTaxId?: string | undefined;
    jdeAddressBookNameAlpha?: string | undefined;
    jdeAddressBookTaxExemptionCertificate?: string | undefined;
    jdeAddressBookAddressLine1?: string | undefined;
    jdeAddressBookAddressLine2?: string | undefined;
    jdeAddressBookAddressLine3?: string | undefined;
    jdeAddressBookAddressLine4?: string | undefined;
    jdeAddressBookCity?: string | undefined;
    jdeAddressBookCountry?: string | undefined;
    jdeAddressBookPostalCode?: string | undefined;
    jdeAddressBookIncoterm?: string | undefined;
    jdeAddressBookDestination?: string | undefined;
    jdeAddressBookDeliveryCondition?: string | undefined;
    jdeCurrencyExchangeRateF0115CurrencyCodeFrom?: string | undefined;
    jdeCurrencyExchangeRateF0115ToCurrency?: string | undefined;
    jdeCurrencyExchangeRateF0115ExchangeRateEffectiveDate?: Date | undefined;
    jdeCurrencyExchangeRateF0115CurrencyConversionRate!: number;
    jdeSalesOrderDetailsShipToNumber?: string | undefined;
    jdeSalesOrderDetailsRouteCode?: string | undefined;
    jdeSalesOrderDetailsTurnoverDate?: Date | undefined;
    jdeSalesOrderDetailsMethodOfTransportation?: string | undefined;
    jdeItemCrossReferencesContractDate?: Date | undefined;
    jdeItemCrossReferenceContractNumber?: string | undefined;
    jdeShipmentDataWaybillNumber?: string | undefined;
    jdeShipmentDataDeliveryWaybillDate?: Date | undefined;
    jdeShipmentDataDepartureDate?: Date | undefined;
    jdeAddressTaxRate1!: number;
    jdeTermsOfPayment?: string | undefined;
    jdeUnitOfMeasure?: string | undefined;
    esfInvoiceFullDto?: InvoiceFullDto | undefined;
    jdeArInvoceDetails?: JdeArInvoiceDetail[] | undefined;

    constructor(data?: IJdeArInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jdeArF03B11DocumentNumber = _data["jdeArF03B11DocumentNumber"];
            this.jdeArF03B11DocumentType = _data["jdeArF03B11DocumentType"];
            this.jdeArF03B11DocumentCompany = _data["jdeArF03B11DocumentCompany"];
            this.jdeArF03B11AddressNumber = _data["jdeArF03B11AddressNumber"];
            this.jdeArF03B11InvoiceDate = _data["jdeArF03B11InvoiceDate"] ? new Date(_data["jdeArF03B11InvoiceDate"].toString()) : <any>undefined;
            this.jdeArF03B11VoidFlag = _data["jdeArF03B11VoidFlag"];
            this.jdeArF03B11UserReservedDate = _data["jdeArF03B11UserReservedDate"] ? new Date(_data["jdeArF03B11UserReservedDate"].toString()) : <any>undefined;
            this.jdeArF03B11UserReservedReference = _data["jdeArF03B11UserReservedReference"];
            this.jdeArF03B11StatementDate = _data["jdeArF03B11StatementDate"] ? new Date(_data["jdeArF03B11StatementDate"].toString()) : <any>undefined;
            this.jdeArF03B11Reference = _data["jdeArF03B11Reference"];
            this.jdeArF03B11CurrencyCodeFrom = _data["jdeArF03B11CurrencyCodeFrom"];
            this.jdeArF03B11NonTaxableAmount = _data["jdeArF03B11NonTaxableAmount"];
            this.jdeArF03B11ForeignNonTaxableAmount = _data["jdeArF03B11ForeignNonTaxableAmount"];
            this.jdeArF03B11AmountTaxable = _data["jdeArF03B11AmountTaxable"];
            this.jdeArF03B11ForeignTaxableAmount = _data["jdeArF03B11ForeignTaxableAmount"];
            this.jdeArF03B11ForeignTaxAmount = _data["jdeArF03B11ForeignTaxAmount"];
            this.jdeArF03B11CurrencyAmount = _data["jdeArF03B11CurrencyAmount"];
            this.jdeArF03B11GlDate = _data["jdeArF03B11GlDate"] ? new Date(_data["jdeArF03B11GlDate"].toString()) : <any>undefined;
            this.jdeArF03B11TaxArea = _data["jdeArF03B11TaxArea"];
            this.jdeArF03B11TaxAmount = _data["jdeArF03B11TaxAmount"];
            this.jdeArF03B11ToCurrency = _data["jdeArF03B11ToCurrency"];
            this.jdeArF03B11ExchangeRateEffectiveDate = _data["jdeArF03B11ExchangeRateEffectiveDate"] ? new Date(_data["jdeArF03B11ExchangeRateEffectiveDate"].toString()) : <any>undefined;
            this.jdeArF03B11CurrencyConversionRate = _data["jdeArF03B11CurrencyConversionRate"];
            this.jdeArF03B11DeliveryCondition = _data["jdeArF03B11DeliveryCondition"];
            this.jdeArF03B11PaymentTermCode = _data["jdeArF03B11PaymentTermCode"];
            this.jdeGeneralLedgerBatchNumber = _data["jdeGeneralLedgerBatchNumber"];
            this.jdeGeneralLedgerBatchDate = _data["jdeGeneralLedgerBatchDate"] ? new Date(_data["jdeGeneralLedgerBatchDate"].toString()) : <any>undefined;
            this.jdeGeneralLedgerBatchType = _data["jdeGeneralLedgerBatchType"];
            this.jdeGeneralLedgerInvoiceDate = _data["jdeGeneralLedgerInvoiceDate"] ? new Date(_data["jdeGeneralLedgerInvoiceDate"].toString()) : <any>undefined;
            this.jdeGeneralLedgerCompany = _data["jdeGeneralLedgerCompany"];
            this.jdeGeneralLedgerBatchStatus = _data["jdeGeneralLedgerBatchStatus"];
            this.jdeAddressBookTaxId = _data["jdeAddressBookTaxId"];
            this.jdeAddressBookNameAlpha = _data["jdeAddressBookNameAlpha"];
            this.jdeAddressBookTaxExemptionCertificate = _data["jdeAddressBookTaxExemptionCertificate"];
            this.jdeAddressBookAddressLine1 = _data["jdeAddressBookAddressLine1"];
            this.jdeAddressBookAddressLine2 = _data["jdeAddressBookAddressLine2"];
            this.jdeAddressBookAddressLine3 = _data["jdeAddressBookAddressLine3"];
            this.jdeAddressBookAddressLine4 = _data["jdeAddressBookAddressLine4"];
            this.jdeAddressBookCity = _data["jdeAddressBookCity"];
            this.jdeAddressBookCountry = _data["jdeAddressBookCountry"];
            this.jdeAddressBookPostalCode = _data["jdeAddressBookPostalCode"];
            this.jdeAddressBookIncoterm = _data["jdeAddressBookIncoterm"];
            this.jdeAddressBookDestination = _data["jdeAddressBookDestination"];
            this.jdeAddressBookDeliveryCondition = _data["jdeAddressBookDeliveryCondition"];
            this.jdeCurrencyExchangeRateF0115CurrencyCodeFrom = _data["jdeCurrencyExchangeRateF0115CurrencyCodeFrom"];
            this.jdeCurrencyExchangeRateF0115ToCurrency = _data["jdeCurrencyExchangeRateF0115ToCurrency"];
            this.jdeCurrencyExchangeRateF0115ExchangeRateEffectiveDate = _data["jdeCurrencyExchangeRateF0115ExchangeRateEffectiveDate"] ? new Date(_data["jdeCurrencyExchangeRateF0115ExchangeRateEffectiveDate"].toString()) : <any>undefined;
            this.jdeCurrencyExchangeRateF0115CurrencyConversionRate = _data["jdeCurrencyExchangeRateF0115CurrencyConversionRate"];
            this.jdeSalesOrderDetailsShipToNumber = _data["jdeSalesOrderDetailsShipToNumber"];
            this.jdeSalesOrderDetailsRouteCode = _data["jdeSalesOrderDetailsRouteCode"];
            this.jdeSalesOrderDetailsTurnoverDate = _data["jdeSalesOrderDetailsTurnoverDate"] ? new Date(_data["jdeSalesOrderDetailsTurnoverDate"].toString()) : <any>undefined;
            this.jdeSalesOrderDetailsMethodOfTransportation = _data["jdeSalesOrderDetailsMethodOfTransportation"];
            this.jdeItemCrossReferencesContractDate = _data["jdeItemCrossReferencesContractDate"] ? new Date(_data["jdeItemCrossReferencesContractDate"].toString()) : <any>undefined;
            this.jdeItemCrossReferenceContractNumber = _data["jdeItemCrossReferenceContractNumber"];
            this.jdeShipmentDataWaybillNumber = _data["jdeShipmentDataWaybillNumber"];
            this.jdeShipmentDataDeliveryWaybillDate = _data["jdeShipmentDataDeliveryWaybillDate"] ? new Date(_data["jdeShipmentDataDeliveryWaybillDate"].toString()) : <any>undefined;
            this.jdeShipmentDataDepartureDate = _data["jdeShipmentDataDepartureDate"] ? new Date(_data["jdeShipmentDataDepartureDate"].toString()) : <any>undefined;
            this.jdeAddressTaxRate1 = _data["jdeAddressTaxRate1"];
            this.jdeTermsOfPayment = _data["jdeTermsOfPayment"];
            this.jdeUnitOfMeasure = _data["jdeUnitOfMeasure"];
            this.esfInvoiceFullDto = _data["esfInvoiceFullDto"] ? InvoiceFullDto.fromJS(_data["esfInvoiceFullDto"]) : <any>undefined;
            if (Array.isArray(_data["jdeArInvoceDetails"])) {
                this.jdeArInvoceDetails = [] as any;
                for (let item of _data["jdeArInvoceDetails"])
                    this.jdeArInvoceDetails!.push(JdeArInvoiceDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JdeArInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new JdeArInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jdeArF03B11DocumentNumber"] = this.jdeArF03B11DocumentNumber;
        data["jdeArF03B11DocumentType"] = this.jdeArF03B11DocumentType;
        data["jdeArF03B11DocumentCompany"] = this.jdeArF03B11DocumentCompany;
        data["jdeArF03B11AddressNumber"] = this.jdeArF03B11AddressNumber;
        data["jdeArF03B11InvoiceDate"] = this.jdeArF03B11InvoiceDate ? this.jdeArF03B11InvoiceDate.toYearMonthDateString() : <any>undefined;
        data["jdeArF03B11VoidFlag"] = this.jdeArF03B11VoidFlag;
        data["jdeArF03B11UserReservedDate"] = this.jdeArF03B11UserReservedDate ? this.jdeArF03B11UserReservedDate.toYearMonthDateString() : <any>undefined;
        data["jdeArF03B11UserReservedReference"] = this.jdeArF03B11UserReservedReference;
        data["jdeArF03B11StatementDate"] = this.jdeArF03B11StatementDate ? this.jdeArF03B11StatementDate.toYearMonthDateString() : <any>undefined;
        data["jdeArF03B11Reference"] = this.jdeArF03B11Reference;
        data["jdeArF03B11CurrencyCodeFrom"] = this.jdeArF03B11CurrencyCodeFrom;
        data["jdeArF03B11NonTaxableAmount"] = this.jdeArF03B11NonTaxableAmount;
        data["jdeArF03B11ForeignNonTaxableAmount"] = this.jdeArF03B11ForeignNonTaxableAmount;
        data["jdeArF03B11AmountTaxable"] = this.jdeArF03B11AmountTaxable;
        data["jdeArF03B11ForeignTaxableAmount"] = this.jdeArF03B11ForeignTaxableAmount;
        data["jdeArF03B11ForeignTaxAmount"] = this.jdeArF03B11ForeignTaxAmount;
        data["jdeArF03B11CurrencyAmount"] = this.jdeArF03B11CurrencyAmount;
        data["jdeArF03B11GlDate"] = this.jdeArF03B11GlDate ? this.jdeArF03B11GlDate.toYearMonthDateString() : <any>undefined;
        data["jdeArF03B11TaxArea"] = this.jdeArF03B11TaxArea;
        data["jdeArF03B11TaxAmount"] = this.jdeArF03B11TaxAmount;
        data["jdeArF03B11ToCurrency"] = this.jdeArF03B11ToCurrency;
        data["jdeArF03B11ExchangeRateEffectiveDate"] = this.jdeArF03B11ExchangeRateEffectiveDate ? this.jdeArF03B11ExchangeRateEffectiveDate.toYearMonthDateString() : <any>undefined;
        data["jdeArF03B11CurrencyConversionRate"] = this.jdeArF03B11CurrencyConversionRate;
        data["jdeArF03B11DeliveryCondition"] = this.jdeArF03B11DeliveryCondition;
        data["jdeArF03B11PaymentTermCode"] = this.jdeArF03B11PaymentTermCode;
        data["jdeGeneralLedgerBatchNumber"] = this.jdeGeneralLedgerBatchNumber;
        data["jdeGeneralLedgerBatchDate"] = this.jdeGeneralLedgerBatchDate ? this.jdeGeneralLedgerBatchDate.toYearMonthDateString() : <any>undefined;
        data["jdeGeneralLedgerBatchType"] = this.jdeGeneralLedgerBatchType;
        data["jdeGeneralLedgerInvoiceDate"] = this.jdeGeneralLedgerInvoiceDate ? this.jdeGeneralLedgerInvoiceDate.toYearMonthDateString() : <any>undefined;
        data["jdeGeneralLedgerCompany"] = this.jdeGeneralLedgerCompany;
        data["jdeGeneralLedgerBatchStatus"] = this.jdeGeneralLedgerBatchStatus;
        data["jdeAddressBookTaxId"] = this.jdeAddressBookTaxId;
        data["jdeAddressBookNameAlpha"] = this.jdeAddressBookNameAlpha;
        data["jdeAddressBookTaxExemptionCertificate"] = this.jdeAddressBookTaxExemptionCertificate;
        data["jdeAddressBookAddressLine1"] = this.jdeAddressBookAddressLine1;
        data["jdeAddressBookAddressLine2"] = this.jdeAddressBookAddressLine2;
        data["jdeAddressBookAddressLine3"] = this.jdeAddressBookAddressLine3;
        data["jdeAddressBookAddressLine4"] = this.jdeAddressBookAddressLine4;
        data["jdeAddressBookCity"] = this.jdeAddressBookCity;
        data["jdeAddressBookCountry"] = this.jdeAddressBookCountry;
        data["jdeAddressBookPostalCode"] = this.jdeAddressBookPostalCode;
        data["jdeAddressBookIncoterm"] = this.jdeAddressBookIncoterm;
        data["jdeAddressBookDestination"] = this.jdeAddressBookDestination;
        data["jdeAddressBookDeliveryCondition"] = this.jdeAddressBookDeliveryCondition;
        data["jdeCurrencyExchangeRateF0115CurrencyCodeFrom"] = this.jdeCurrencyExchangeRateF0115CurrencyCodeFrom;
        data["jdeCurrencyExchangeRateF0115ToCurrency"] = this.jdeCurrencyExchangeRateF0115ToCurrency;
        data["jdeCurrencyExchangeRateF0115ExchangeRateEffectiveDate"] = this.jdeCurrencyExchangeRateF0115ExchangeRateEffectiveDate ? this.jdeCurrencyExchangeRateF0115ExchangeRateEffectiveDate.toYearMonthDateString() : <any>undefined;
        data["jdeCurrencyExchangeRateF0115CurrencyConversionRate"] = this.jdeCurrencyExchangeRateF0115CurrencyConversionRate;
        data["jdeSalesOrderDetailsShipToNumber"] = this.jdeSalesOrderDetailsShipToNumber;
        data["jdeSalesOrderDetailsRouteCode"] = this.jdeSalesOrderDetailsRouteCode;
        data["jdeSalesOrderDetailsTurnoverDate"] = this.jdeSalesOrderDetailsTurnoverDate ? this.jdeSalesOrderDetailsTurnoverDate.toYearMonthDateString() : <any>undefined;
        data["jdeSalesOrderDetailsMethodOfTransportation"] = this.jdeSalesOrderDetailsMethodOfTransportation;
        data["jdeItemCrossReferencesContractDate"] = this.jdeItemCrossReferencesContractDate ? this.jdeItemCrossReferencesContractDate.toYearMonthDateString() : <any>undefined;
        data["jdeItemCrossReferenceContractNumber"] = this.jdeItemCrossReferenceContractNumber;
        data["jdeShipmentDataWaybillNumber"] = this.jdeShipmentDataWaybillNumber;
        data["jdeShipmentDataDeliveryWaybillDate"] = this.jdeShipmentDataDeliveryWaybillDate ? this.jdeShipmentDataDeliveryWaybillDate.toYearMonthDateString() : <any>undefined;
        data["jdeShipmentDataDepartureDate"] = this.jdeShipmentDataDepartureDate ? this.jdeShipmentDataDepartureDate.toYearMonthDateString() : <any>undefined;
        data["jdeAddressTaxRate1"] = this.jdeAddressTaxRate1;
        data["jdeTermsOfPayment"] = this.jdeTermsOfPayment;
        data["jdeUnitOfMeasure"] = this.jdeUnitOfMeasure;
        data["esfInvoiceFullDto"] = this.esfInvoiceFullDto ? this.esfInvoiceFullDto.toJSON() : <any>undefined;
        if (Array.isArray(this.jdeArInvoceDetails)) {
            data["jdeArInvoceDetails"] = [];
            for (let item of this.jdeArInvoceDetails)
                data["jdeArInvoceDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface IJdeArInvoiceDto {
    id: number;
    jdeArF03B11DocumentNumber?: string | undefined;
    jdeArF03B11DocumentType?: string | undefined;
    jdeArF03B11DocumentCompany?: string | undefined;
    jdeArF03B11AddressNumber: number;
    jdeArF03B11InvoiceDate: Date;
    jdeArF03B11VoidFlag?: boolean | undefined;
    jdeArF03B11UserReservedDate?: Date | undefined;
    jdeArF03B11UserReservedReference?: string | undefined;
    jdeArF03B11StatementDate?: Date | undefined;
    jdeArF03B11Reference?: string | undefined;
    jdeArF03B11CurrencyCodeFrom?: string | undefined;
    jdeArF03B11NonTaxableAmount: number;
    jdeArF03B11ForeignNonTaxableAmount: number;
    jdeArF03B11AmountTaxable: number;
    jdeArF03B11ForeignTaxableAmount: number;
    jdeArF03B11ForeignTaxAmount: number;
    jdeArF03B11CurrencyAmount: number;
    jdeArF03B11GlDate?: Date | undefined;
    jdeArF03B11TaxArea?: string | undefined;
    jdeArF03B11TaxAmount: number;
    jdeArF03B11ToCurrency?: string | undefined;
    jdeArF03B11ExchangeRateEffectiveDate?: Date | undefined;
    jdeArF03B11CurrencyConversionRate: number;
    jdeArF03B11DeliveryCondition?: string | undefined;
    jdeArF03B11PaymentTermCode?: string | undefined;
    jdeGeneralLedgerBatchNumber: number;
    jdeGeneralLedgerBatchDate?: Date | undefined;
    jdeGeneralLedgerBatchType?: string | undefined;
    jdeGeneralLedgerInvoiceDate?: Date | undefined;
    jdeGeneralLedgerCompany?: string | undefined;
    jdeGeneralLedgerBatchStatus?: string | undefined;
    jdeAddressBookTaxId?: string | undefined;
    jdeAddressBookNameAlpha?: string | undefined;
    jdeAddressBookTaxExemptionCertificate?: string | undefined;
    jdeAddressBookAddressLine1?: string | undefined;
    jdeAddressBookAddressLine2?: string | undefined;
    jdeAddressBookAddressLine3?: string | undefined;
    jdeAddressBookAddressLine4?: string | undefined;
    jdeAddressBookCity?: string | undefined;
    jdeAddressBookCountry?: string | undefined;
    jdeAddressBookPostalCode?: string | undefined;
    jdeAddressBookIncoterm?: string | undefined;
    jdeAddressBookDestination?: string | undefined;
    jdeAddressBookDeliveryCondition?: string | undefined;
    jdeCurrencyExchangeRateF0115CurrencyCodeFrom?: string | undefined;
    jdeCurrencyExchangeRateF0115ToCurrency?: string | undefined;
    jdeCurrencyExchangeRateF0115ExchangeRateEffectiveDate?: Date | undefined;
    jdeCurrencyExchangeRateF0115CurrencyConversionRate: number;
    jdeSalesOrderDetailsShipToNumber?: string | undefined;
    jdeSalesOrderDetailsRouteCode?: string | undefined;
    jdeSalesOrderDetailsTurnoverDate?: Date | undefined;
    jdeSalesOrderDetailsMethodOfTransportation?: string | undefined;
    jdeItemCrossReferencesContractDate?: Date | undefined;
    jdeItemCrossReferenceContractNumber?: string | undefined;
    jdeShipmentDataWaybillNumber?: string | undefined;
    jdeShipmentDataDeliveryWaybillDate?: Date | undefined;
    jdeShipmentDataDepartureDate?: Date | undefined;
    jdeAddressTaxRate1: number;
    jdeTermsOfPayment?: string | undefined;
    jdeUnitOfMeasure?: string | undefined;
    esfInvoiceFullDto?: InvoiceFullDto | undefined;
    jdeArInvoceDetails?: JdeArInvoiceDetail[] | undefined;
}

export class JdeArInvoiceDetail implements IJdeArInvoiceDetail {
    id!: number;
    jdeArF03B11DocumentPayItem?: string | undefined;
    jdeArF03B11CurrencyCodeFrom?: string | undefined;
    jdeArF03B11UnitOfMeasure?: string | undefined;
    jdeArF03B11Units!: number;
    jdeArF03B11GrossAmount!: number;
    jdeArF03B11NonTaxableAmount!: number;
    jdeArF03B11ForeignNonTaxableAmount!: number;
    jdeArF03B11AmountTaxable!: number;
    jdeArF03B11ForeignTaxableAmount!: number;
    jdeArF03B11ForeignTaxAmount!: number;
    jdeArF03B11CurrencyAmount!: number;
    jdeArF03B11TaxArea?: string | undefined;
    jdeArF03B11TaxAmount!: number;
    jdeGeneralLedgerAccountId?: string | undefined;
    jdeGeneralLedgerAccountNumberInput?: string | undefined;
    jdeGeneralLedgerJdeLocalization?: string | undefined;
    jdeGeneralLedgerAccountDescription?: string | undefined;
    jdeGetUOMUserDefinedCode?: string | undefined;
    jdeGetUOMUserReservedReference?: string | undefined;
    jdeGetUOMDescription?: string | undefined;

    constructor(data?: IJdeArInvoiceDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jdeArF03B11DocumentPayItem = _data["jdeArF03B11DocumentPayItem"];
            this.jdeArF03B11CurrencyCodeFrom = _data["jdeArF03B11CurrencyCodeFrom"];
            this.jdeArF03B11UnitOfMeasure = _data["jdeArF03B11UnitOfMeasure"];
            this.jdeArF03B11Units = _data["jdeArF03B11Units"];
            this.jdeArF03B11GrossAmount = _data["jdeArF03B11GrossAmount"];
            this.jdeArF03B11NonTaxableAmount = _data["jdeArF03B11NonTaxableAmount"];
            this.jdeArF03B11ForeignNonTaxableAmount = _data["jdeArF03B11ForeignNonTaxableAmount"];
            this.jdeArF03B11AmountTaxable = _data["jdeArF03B11AmountTaxable"];
            this.jdeArF03B11ForeignTaxableAmount = _data["jdeArF03B11ForeignTaxableAmount"];
            this.jdeArF03B11ForeignTaxAmount = _data["jdeArF03B11ForeignTaxAmount"];
            this.jdeArF03B11CurrencyAmount = _data["jdeArF03B11CurrencyAmount"];
            this.jdeArF03B11TaxArea = _data["jdeArF03B11TaxArea"];
            this.jdeArF03B11TaxAmount = _data["jdeArF03B11TaxAmount"];
            this.jdeGeneralLedgerAccountId = _data["jdeGeneralLedgerAccountId"];
            this.jdeGeneralLedgerAccountNumberInput = _data["jdeGeneralLedgerAccountNumberInput"];
            this.jdeGeneralLedgerJdeLocalization = _data["jdeGeneralLedgerJdeLocalization"];
            this.jdeGeneralLedgerAccountDescription = _data["jdeGeneralLedgerAccountDescription"];
            this.jdeGetUOMUserDefinedCode = _data["jdeGetUOMUserDefinedCode"];
            this.jdeGetUOMUserReservedReference = _data["jdeGetUOMUserReservedReference"];
            this.jdeGetUOMDescription = _data["jdeGetUOMDescription"];
        }
    }

    static fromJS(data: any): JdeArInvoiceDetail {
        data = typeof data === 'object' ? data : {};
        let result = new JdeArInvoiceDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jdeArF03B11DocumentPayItem"] = this.jdeArF03B11DocumentPayItem;
        data["jdeArF03B11CurrencyCodeFrom"] = this.jdeArF03B11CurrencyCodeFrom;
        data["jdeArF03B11UnitOfMeasure"] = this.jdeArF03B11UnitOfMeasure;
        data["jdeArF03B11Units"] = this.jdeArF03B11Units;
        data["jdeArF03B11GrossAmount"] = this.jdeArF03B11GrossAmount;
        data["jdeArF03B11NonTaxableAmount"] = this.jdeArF03B11NonTaxableAmount;
        data["jdeArF03B11ForeignNonTaxableAmount"] = this.jdeArF03B11ForeignNonTaxableAmount;
        data["jdeArF03B11AmountTaxable"] = this.jdeArF03B11AmountTaxable;
        data["jdeArF03B11ForeignTaxableAmount"] = this.jdeArF03B11ForeignTaxableAmount;
        data["jdeArF03B11ForeignTaxAmount"] = this.jdeArF03B11ForeignTaxAmount;
        data["jdeArF03B11CurrencyAmount"] = this.jdeArF03B11CurrencyAmount;
        data["jdeArF03B11TaxArea"] = this.jdeArF03B11TaxArea;
        data["jdeArF03B11TaxAmount"] = this.jdeArF03B11TaxAmount;
        data["jdeGeneralLedgerAccountId"] = this.jdeGeneralLedgerAccountId;
        data["jdeGeneralLedgerAccountNumberInput"] = this.jdeGeneralLedgerAccountNumberInput;
        data["jdeGeneralLedgerJdeLocalization"] = this.jdeGeneralLedgerJdeLocalization;
        data["jdeGeneralLedgerAccountDescription"] = this.jdeGeneralLedgerAccountDescription;
        data["jdeGetUOMUserDefinedCode"] = this.jdeGetUOMUserDefinedCode;
        data["jdeGetUOMUserReservedReference"] = this.jdeGetUOMUserReservedReference;
        data["jdeGetUOMDescription"] = this.jdeGetUOMDescription;
        return data;
    }
}

export interface IJdeArInvoiceDetail {
    id: number;
    jdeArF03B11DocumentPayItem?: string | undefined;
    jdeArF03B11CurrencyCodeFrom?: string | undefined;
    jdeArF03B11UnitOfMeasure?: string | undefined;
    jdeArF03B11Units: number;
    jdeArF03B11GrossAmount: number;
    jdeArF03B11NonTaxableAmount: number;
    jdeArF03B11ForeignNonTaxableAmount: number;
    jdeArF03B11AmountTaxable: number;
    jdeArF03B11ForeignTaxableAmount: number;
    jdeArF03B11ForeignTaxAmount: number;
    jdeArF03B11CurrencyAmount: number;
    jdeArF03B11TaxArea?: string | undefined;
    jdeArF03B11TaxAmount: number;
    jdeGeneralLedgerAccountId?: string | undefined;
    jdeGeneralLedgerAccountNumberInput?: string | undefined;
    jdeGeneralLedgerJdeLocalization?: string | undefined;
    jdeGeneralLedgerAccountDescription?: string | undefined;
    jdeGetUOMUserDefinedCode?: string | undefined;
    jdeGetUOMUserReservedReference?: string | undefined;
    jdeGetUOMDescription?: string | undefined;
}

export class GetJdeArMatchesResponseDto implements IGetJdeArMatchesResponseDto {
    matches?: EsfJdeArMatchDto[] | undefined;
    paging?: PagingModel | undefined;

    constructor(data?: IGetJdeArMatchesResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(EsfJdeArMatchDto.fromJS(item));
            }
            this.paging = _data["paging"] ? PagingModel.fromJS(_data["paging"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetJdeArMatchesResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetJdeArMatchesResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item.toJSON());
        }
        data["paging"] = this.paging ? this.paging.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetJdeArMatchesResponseDto {
    matches?: EsfJdeArMatchDto[] | undefined;
    paging?: PagingModel | undefined;
}

export class EsfJdeArMatchDto implements IEsfJdeArMatchDto {
    id!: number;
    jdeType?: string | undefined;
    jdeStatus?: string | undefined;
    jdeNumber?: string | undefined;
    jdeIinBin?: string | undefined;
    jdeCustomer?: string | undefined;
    jdeContractNumber?: string | undefined;
    jdeContractDate?: Date | undefined;
    jdeCurrency?: string | undefined;
    jdeTaxableAmount?: number | undefined;
    jdeTaxRate?: number | undefined;
    jdeTaxAmount?: number | undefined;
    jdeGrossAmount?: number | undefined;
    jdeVoidFlag?: boolean | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    esfRegistrationNumber?: string | undefined;
    esfType?: InvoiceType | undefined;
    esfStatus?: InvoiceStatus | undefined;
    esfNumber?: string | undefined;
    esfIinBin?: string | undefined;
    esfCustomer?: string | undefined;
    esfContractNumber?: string | undefined;
    esfContractDate?: Date | undefined;
    esfCurrency?: string | undefined;
    esfTaxableAmount?: number | undefined;
    esfTaxRate?: number | undefined;
    esfTaxAmount?: number | undefined;
    esfGrossAmount?: number | undefined;
    esfLastUpdatedDate?: Date | undefined;
    reconciliationStatus!: ReconciliationStatus;
    esfJdeArMatchItems?: EsfJdeArMatchItemDto[] | undefined;

    constructor(data?: IEsfJdeArMatchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jdeType = _data["jdeType"];
            this.jdeStatus = _data["jdeStatus"];
            this.jdeNumber = _data["jdeNumber"];
            this.jdeIinBin = _data["jdeIinBin"];
            this.jdeCustomer = _data["jdeCustomer"];
            this.jdeContractNumber = _data["jdeContractNumber"];
            this.jdeContractDate = _data["jdeContractDate"] ? new Date(_data["jdeContractDate"].toString()) : <any>undefined;
            this.jdeCurrency = _data["jdeCurrency"];
            this.jdeTaxableAmount = _data["jdeTaxableAmount"];
            this.jdeTaxRate = _data["jdeTaxRate"];
            this.jdeTaxAmount = _data["jdeTaxAmount"];
            this.jdeGrossAmount = _data["jdeGrossAmount"];
            this.jdeVoidFlag = _data["jdeVoidFlag"];
            this.jdeLastUpdatedDate = _data["jdeLastUpdatedDate"] ? new Date(_data["jdeLastUpdatedDate"].toString()) : <any>undefined;
            this.jdeInvoiceId = _data["jdeInvoiceId"];
            this.esfRegistrationNumber = _data["esfRegistrationNumber"];
            this.esfType = _data["esfType"];
            this.esfStatus = _data["esfStatus"];
            this.esfNumber = _data["esfNumber"];
            this.esfIinBin = _data["esfIinBin"];
            this.esfCustomer = _data["esfCustomer"];
            this.esfContractNumber = _data["esfContractNumber"];
            this.esfContractDate = _data["esfContractDate"] ? new Date(_data["esfContractDate"].toString()) : <any>undefined;
            this.esfCurrency = _data["esfCurrency"];
            this.esfTaxableAmount = _data["esfTaxableAmount"];
            this.esfTaxRate = _data["esfTaxRate"];
            this.esfTaxAmount = _data["esfTaxAmount"];
            this.esfGrossAmount = _data["esfGrossAmount"];
            this.esfLastUpdatedDate = _data["esfLastUpdatedDate"] ? new Date(_data["esfLastUpdatedDate"].toString()) : <any>undefined;
            this.reconciliationStatus = _data["reconciliationStatus"];
            if (Array.isArray(_data["esfJdeArMatchItems"])) {
                this.esfJdeArMatchItems = [] as any;
                for (let item of _data["esfJdeArMatchItems"])
                    this.esfJdeArMatchItems!.push(EsfJdeArMatchItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EsfJdeArMatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new EsfJdeArMatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jdeType"] = this.jdeType;
        data["jdeStatus"] = this.jdeStatus;
        data["jdeNumber"] = this.jdeNumber;
        data["jdeIinBin"] = this.jdeIinBin;
        data["jdeCustomer"] = this.jdeCustomer;
        data["jdeContractNumber"] = this.jdeContractNumber;
        data["jdeContractDate"] = this.jdeContractDate ? this.jdeContractDate.toYearMonthDateString() : <any>undefined;
        data["jdeCurrency"] = this.jdeCurrency;
        data["jdeTaxableAmount"] = this.jdeTaxableAmount;
        data["jdeTaxRate"] = this.jdeTaxRate;
        data["jdeTaxAmount"] = this.jdeTaxAmount;
        data["jdeGrossAmount"] = this.jdeGrossAmount;
        data["jdeVoidFlag"] = this.jdeVoidFlag;
        data["jdeLastUpdatedDate"] = this.jdeLastUpdatedDate ? this.jdeLastUpdatedDate.toYearMonthDateString() : <any>undefined;
        data["jdeInvoiceId"] = this.jdeInvoiceId;
        data["esfRegistrationNumber"] = this.esfRegistrationNumber;
        data["esfType"] = this.esfType;
        data["esfStatus"] = this.esfStatus;
        data["esfNumber"] = this.esfNumber;
        data["esfIinBin"] = this.esfIinBin;
        data["esfCustomer"] = this.esfCustomer;
        data["esfContractNumber"] = this.esfContractNumber;
        data["esfContractDate"] = this.esfContractDate ? this.esfContractDate.toYearMonthDateString() : <any>undefined;
        data["esfCurrency"] = this.esfCurrency;
        data["esfTaxableAmount"] = this.esfTaxableAmount;
        data["esfTaxRate"] = this.esfTaxRate;
        data["esfTaxAmount"] = this.esfTaxAmount;
        data["esfGrossAmount"] = this.esfGrossAmount;
        data["esfLastUpdatedDate"] = this.esfLastUpdatedDate ? this.esfLastUpdatedDate.toYearMonthDateString() : <any>undefined;
        data["reconciliationStatus"] = this.reconciliationStatus;
        if (Array.isArray(this.esfJdeArMatchItems)) {
            data["esfJdeArMatchItems"] = [];
            for (let item of this.esfJdeArMatchItems)
                data["esfJdeArMatchItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEsfJdeArMatchDto {
    id: number;
    jdeType?: string | undefined;
    jdeStatus?: string | undefined;
    jdeNumber?: string | undefined;
    jdeIinBin?: string | undefined;
    jdeCustomer?: string | undefined;
    jdeContractNumber?: string | undefined;
    jdeContractDate?: Date | undefined;
    jdeCurrency?: string | undefined;
    jdeTaxableAmount?: number | undefined;
    jdeTaxRate?: number | undefined;
    jdeTaxAmount?: number | undefined;
    jdeGrossAmount?: number | undefined;
    jdeVoidFlag?: boolean | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    esfRegistrationNumber?: string | undefined;
    esfType?: InvoiceType | undefined;
    esfStatus?: InvoiceStatus | undefined;
    esfNumber?: string | undefined;
    esfIinBin?: string | undefined;
    esfCustomer?: string | undefined;
    esfContractNumber?: string | undefined;
    esfContractDate?: Date | undefined;
    esfCurrency?: string | undefined;
    esfTaxableAmount?: number | undefined;
    esfTaxRate?: number | undefined;
    esfTaxAmount?: number | undefined;
    esfGrossAmount?: number | undefined;
    esfLastUpdatedDate?: Date | undefined;
    reconciliationStatus: ReconciliationStatus;
    esfJdeArMatchItems?: EsfJdeArMatchItemDto[] | undefined;
}

export enum ReconciliationStatus {
    NotReconciled = "NotReconciled",
    Reconciled = "Reconciled",
    NoMatch = "NoMatch",
}

export class EsfJdeArMatchItemDto implements IEsfJdeArMatchItemDto {
    id!: number;
    jdeType?: string | undefined;
    jdeStatus?: string | undefined;
    jdeDate?: Date | undefined;
    jdeTurnoverDate?: Date | undefined;
    jdeNumber?: string | undefined;
    jdeDocumentType?: string | undefined;
    jdeDocumentPayItem?: string | undefined;
    jdeIinBin?: string | undefined;
    jdeCustomer?: string | undefined;
    jdeContractNumber?: string | undefined;
    jdeContractDate?: Date | undefined;
    jdeCurrency?: string | undefined;
    jdeTaxableAmount?: number | undefined;
    jdeTaxRate?: number | undefined;
    jdeTaxAmount?: number | undefined;
    jdeGrossAmount?: number | undefined;
    jdeVoidFlag?: boolean | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    esfRegistrationNumber?: string | undefined;
    esfType?: InvoiceType | undefined;
    esfStatus?: InvoiceStatus | undefined;
    esfDate?: Date | undefined;
    esfTurnoverDate?: Date | undefined;
    esfNumber?: string | undefined;
    esfIinBin?: string | undefined;
    esfCustomer?: string | undefined;
    esfContractNumber?: string | undefined;
    esfContractDate?: Date | undefined;
    esfCurrency?: string | undefined;
    esfTaxableAmount?: number | undefined;
    esfTaxRate?: number | undefined;
    esfTaxAmount?: number | undefined;
    esfGrossAmount?: number | undefined;
    esfInvoiceId?: number | undefined;
    esfLastUpdatedDate?: Date | undefined;
    invoiceStatus?: InvoiceStatus | undefined;

    constructor(data?: IEsfJdeArMatchItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jdeType = _data["jdeType"];
            this.jdeStatus = _data["jdeStatus"];
            this.jdeDate = _data["jdeDate"] ? new Date(_data["jdeDate"].toString()) : <any>undefined;
            this.jdeTurnoverDate = _data["jdeTurnoverDate"] ? new Date(_data["jdeTurnoverDate"].toString()) : <any>undefined;
            this.jdeNumber = _data["jdeNumber"];
            this.jdeDocumentType = _data["jdeDocumentType"];
            this.jdeDocumentPayItem = _data["jdeDocumentPayItem"];
            this.jdeIinBin = _data["jdeIinBin"];
            this.jdeCustomer = _data["jdeCustomer"];
            this.jdeContractNumber = _data["jdeContractNumber"];
            this.jdeContractDate = _data["jdeContractDate"] ? new Date(_data["jdeContractDate"].toString()) : <any>undefined;
            this.jdeCurrency = _data["jdeCurrency"];
            this.jdeTaxableAmount = _data["jdeTaxableAmount"];
            this.jdeTaxRate = _data["jdeTaxRate"];
            this.jdeTaxAmount = _data["jdeTaxAmount"];
            this.jdeGrossAmount = _data["jdeGrossAmount"];
            this.jdeVoidFlag = _data["jdeVoidFlag"];
            this.jdeLastUpdatedDate = _data["jdeLastUpdatedDate"] ? new Date(_data["jdeLastUpdatedDate"].toString()) : <any>undefined;
            this.jdeInvoiceId = _data["jdeInvoiceId"];
            this.esfRegistrationNumber = _data["esfRegistrationNumber"];
            this.esfType = _data["esfType"];
            this.esfStatus = _data["esfStatus"];
            this.esfDate = _data["esfDate"] ? new Date(_data["esfDate"].toString()) : <any>undefined;
            this.esfTurnoverDate = _data["esfTurnoverDate"] ? new Date(_data["esfTurnoverDate"].toString()) : <any>undefined;
            this.esfNumber = _data["esfNumber"];
            this.esfIinBin = _data["esfIinBin"];
            this.esfCustomer = _data["esfCustomer"];
            this.esfContractNumber = _data["esfContractNumber"];
            this.esfContractDate = _data["esfContractDate"] ? new Date(_data["esfContractDate"].toString()) : <any>undefined;
            this.esfCurrency = _data["esfCurrency"];
            this.esfTaxableAmount = _data["esfTaxableAmount"];
            this.esfTaxRate = _data["esfTaxRate"];
            this.esfTaxAmount = _data["esfTaxAmount"];
            this.esfGrossAmount = _data["esfGrossAmount"];
            this.esfInvoiceId = _data["esfInvoiceId"];
            this.esfLastUpdatedDate = _data["esfLastUpdatedDate"] ? new Date(_data["esfLastUpdatedDate"].toString()) : <any>undefined;
            this.invoiceStatus = _data["invoiceStatus"];
        }
    }

    static fromJS(data: any): EsfJdeArMatchItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new EsfJdeArMatchItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jdeType"] = this.jdeType;
        data["jdeStatus"] = this.jdeStatus;
        data["jdeDate"] = this.jdeDate ? this.jdeDate.toYearMonthDateString() : <any>undefined;
        data["jdeTurnoverDate"] = this.jdeTurnoverDate ? this.jdeTurnoverDate.toYearMonthDateString() : <any>undefined;
        data["jdeNumber"] = this.jdeNumber;
        data["jdeDocumentType"] = this.jdeDocumentType;
        data["jdeDocumentPayItem"] = this.jdeDocumentPayItem;
        data["jdeIinBin"] = this.jdeIinBin;
        data["jdeCustomer"] = this.jdeCustomer;
        data["jdeContractNumber"] = this.jdeContractNumber;
        data["jdeContractDate"] = this.jdeContractDate ? this.jdeContractDate.toYearMonthDateString() : <any>undefined;
        data["jdeCurrency"] = this.jdeCurrency;
        data["jdeTaxableAmount"] = this.jdeTaxableAmount;
        data["jdeTaxRate"] = this.jdeTaxRate;
        data["jdeTaxAmount"] = this.jdeTaxAmount;
        data["jdeGrossAmount"] = this.jdeGrossAmount;
        data["jdeVoidFlag"] = this.jdeVoidFlag;
        data["jdeLastUpdatedDate"] = this.jdeLastUpdatedDate ? this.jdeLastUpdatedDate.toYearMonthDateString() : <any>undefined;
        data["jdeInvoiceId"] = this.jdeInvoiceId;
        data["esfRegistrationNumber"] = this.esfRegistrationNumber;
        data["esfType"] = this.esfType;
        data["esfStatus"] = this.esfStatus;
        data["esfDate"] = this.esfDate ? this.esfDate.toYearMonthDateString() : <any>undefined;
        data["esfTurnoverDate"] = this.esfTurnoverDate ? this.esfTurnoverDate.toYearMonthDateString() : <any>undefined;
        data["esfNumber"] = this.esfNumber;
        data["esfIinBin"] = this.esfIinBin;
        data["esfCustomer"] = this.esfCustomer;
        data["esfContractNumber"] = this.esfContractNumber;
        data["esfContractDate"] = this.esfContractDate ? this.esfContractDate.toYearMonthDateString() : <any>undefined;
        data["esfCurrency"] = this.esfCurrency;
        data["esfTaxableAmount"] = this.esfTaxableAmount;
        data["esfTaxRate"] = this.esfTaxRate;
        data["esfTaxAmount"] = this.esfTaxAmount;
        data["esfGrossAmount"] = this.esfGrossAmount;
        data["esfInvoiceId"] = this.esfInvoiceId;
        data["esfLastUpdatedDate"] = this.esfLastUpdatedDate ? this.esfLastUpdatedDate.toYearMonthDateString() : <any>undefined;
        data["invoiceStatus"] = this.invoiceStatus;
        return data;
    }
}

export interface IEsfJdeArMatchItemDto {
    id: number;
    jdeType?: string | undefined;
    jdeStatus?: string | undefined;
    jdeDate?: Date | undefined;
    jdeTurnoverDate?: Date | undefined;
    jdeNumber?: string | undefined;
    jdeDocumentType?: string | undefined;
    jdeDocumentPayItem?: string | undefined;
    jdeIinBin?: string | undefined;
    jdeCustomer?: string | undefined;
    jdeContractNumber?: string | undefined;
    jdeContractDate?: Date | undefined;
    jdeCurrency?: string | undefined;
    jdeTaxableAmount?: number | undefined;
    jdeTaxRate?: number | undefined;
    jdeTaxAmount?: number | undefined;
    jdeGrossAmount?: number | undefined;
    jdeVoidFlag?: boolean | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    esfRegistrationNumber?: string | undefined;
    esfType?: InvoiceType | undefined;
    esfStatus?: InvoiceStatus | undefined;
    esfDate?: Date | undefined;
    esfTurnoverDate?: Date | undefined;
    esfNumber?: string | undefined;
    esfIinBin?: string | undefined;
    esfCustomer?: string | undefined;
    esfContractNumber?: string | undefined;
    esfContractDate?: Date | undefined;
    esfCurrency?: string | undefined;
    esfTaxableAmount?: number | undefined;
    esfTaxRate?: number | undefined;
    esfTaxAmount?: number | undefined;
    esfGrossAmount?: number | undefined;
    esfInvoiceId?: number | undefined;
    esfLastUpdatedDate?: Date | undefined;
    invoiceStatus?: InvoiceStatus | undefined;
}

export class GetJdePoMatchesResponseDto implements IGetJdePoMatchesResponseDto {
    matches?: EsfJdeApPoMatchDto[] | undefined;
    paging?: PagingModel | undefined;

    constructor(data?: IGetJdePoMatchesResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(EsfJdeApPoMatchDto.fromJS(item));
            }
            this.paging = _data["paging"] ? PagingModel.fromJS(_data["paging"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetJdePoMatchesResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetJdePoMatchesResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item.toJSON());
        }
        data["paging"] = this.paging ? this.paging.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetJdePoMatchesResponseDto {
    matches?: EsfJdeApPoMatchDto[] | undefined;
    paging?: PagingModel | undefined;
}

export class EsfJdeApMatchBaseDto implements IEsfJdeApMatchBaseDto {
    esfJdeApMatchItems?: EsfJdeApMatchItemBaseDto[] | undefined;
    reconciliationStatus!: ApReconciliationStatus;
    esfStatus?: InvoiceStatus | undefined;
    esfGrossAmount?: number | undefined;
    jdeGrossAmount?: number | undefined;
    esfTaxAmount?: number | undefined;
    jdeTaxAmount?: number | undefined;
    esfRegistrationNumber?: string | undefined;
    esfCurrency?: string | undefined;
    esfLastUpdatedDate?: Date | undefined;
    jdeStatus?: string | undefined;
    jdeSellerName?: string | undefined;
    esfSellerName?: string | undefined;
    esfSellerTin?: string | undefined;
    jdeIinBin?: string | undefined;
    manualReconciliationComment!: ManualReconciliationCommentType;
    manualReconciliationCommentUpdateDate?: Date | undefined;
    commentUpdatedUserFullName?: string | undefined;

    constructor(data?: IEsfJdeApMatchBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["esfJdeApMatchItems"])) {
                this.esfJdeApMatchItems = [] as any;
                for (let item of _data["esfJdeApMatchItems"])
                    this.esfJdeApMatchItems!.push(EsfJdeApMatchItemBaseDto.fromJS(item));
            }
            this.reconciliationStatus = _data["reconciliationStatus"];
            this.esfStatus = _data["esfStatus"];
            this.esfGrossAmount = _data["esfGrossAmount"];
            this.jdeGrossAmount = _data["jdeGrossAmount"];
            this.esfTaxAmount = _data["esfTaxAmount"];
            this.jdeTaxAmount = _data["jdeTaxAmount"];
            this.esfRegistrationNumber = _data["esfRegistrationNumber"];
            this.esfCurrency = _data["esfCurrency"];
            this.esfLastUpdatedDate = _data["esfLastUpdatedDate"] ? new Date(_data["esfLastUpdatedDate"].toString()) : <any>undefined;
            this.jdeStatus = _data["jdeStatus"];
            this.jdeSellerName = _data["jdeSellerName"];
            this.esfSellerName = _data["esfSellerName"];
            this.esfSellerTin = _data["esfSellerTin"];
            this.jdeIinBin = _data["jdeIinBin"];
            this.manualReconciliationComment = _data["manualReconciliationComment"];
            this.manualReconciliationCommentUpdateDate = _data["manualReconciliationCommentUpdateDate"] ? new Date(_data["manualReconciliationCommentUpdateDate"].toString()) : <any>undefined;
            this.commentUpdatedUserFullName = _data["commentUpdatedUserFullName"];
        }
    }

    static fromJS(data: any): EsfJdeApMatchBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EsfJdeApMatchBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.esfJdeApMatchItems)) {
            data["esfJdeApMatchItems"] = [];
            for (let item of this.esfJdeApMatchItems)
                data["esfJdeApMatchItems"].push(item.toJSON());
        }
        data["reconciliationStatus"] = this.reconciliationStatus;
        data["esfStatus"] = this.esfStatus;
        data["esfGrossAmount"] = this.esfGrossAmount;
        data["jdeGrossAmount"] = this.jdeGrossAmount;
        data["esfTaxAmount"] = this.esfTaxAmount;
        data["jdeTaxAmount"] = this.jdeTaxAmount;
        data["esfRegistrationNumber"] = this.esfRegistrationNumber;
        data["esfCurrency"] = this.esfCurrency;
        data["esfLastUpdatedDate"] = this.esfLastUpdatedDate ? this.esfLastUpdatedDate.toYearMonthDateString() : <any>undefined;
        data["jdeStatus"] = this.jdeStatus;
        data["jdeSellerName"] = this.jdeSellerName;
        data["esfSellerName"] = this.esfSellerName;
        data["esfSellerTin"] = this.esfSellerTin;
        data["jdeIinBin"] = this.jdeIinBin;
        data["manualReconciliationComment"] = this.manualReconciliationComment;
        data["manualReconciliationCommentUpdateDate"] = this.manualReconciliationCommentUpdateDate ? this.manualReconciliationCommentUpdateDate.toYearMonthDateString() : <any>undefined;
        data["commentUpdatedUserFullName"] = this.commentUpdatedUserFullName;
        return data;
    }
}

export interface IEsfJdeApMatchBaseDto {
    esfJdeApMatchItems?: EsfJdeApMatchItemBaseDto[] | undefined;
    reconciliationStatus: ApReconciliationStatus;
    esfStatus?: InvoiceStatus | undefined;
    esfGrossAmount?: number | undefined;
    jdeGrossAmount?: number | undefined;
    esfTaxAmount?: number | undefined;
    jdeTaxAmount?: number | undefined;
    esfRegistrationNumber?: string | undefined;
    esfCurrency?: string | undefined;
    esfLastUpdatedDate?: Date | undefined;
    jdeStatus?: string | undefined;
    jdeSellerName?: string | undefined;
    esfSellerName?: string | undefined;
    esfSellerTin?: string | undefined;
    jdeIinBin?: string | undefined;
    manualReconciliationComment: ManualReconciliationCommentType;
    manualReconciliationCommentUpdateDate?: Date | undefined;
    commentUpdatedUserFullName?: string | undefined;
}

export class EsfJdeApPoMatchDto extends EsfJdeApMatchBaseDto implements IEsfJdeApPoMatchDto {
    id!: number;
    jdeType?: string | undefined;
    jdeSupplierNumber?: string | undefined;
    jdeDate?: Date | undefined;
    jdeContractNumber?: string | undefined;
    jdeCurrency?: string | undefined;
    jdeNetAmount?: number | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    jdeDocumentNumber?: string | undefined;
    jdeAddressNumber?: string | undefined;
    esfType?: InvoiceType | undefined;
    esfDate?: Date | undefined;
    esfNumber?: string | undefined;
    esfContractNumber?: string | undefined;
    esfNetAmount?: number | undefined;
    esfJdeApMatchItems?: EsfJdeApPoMatchItemDto[] | undefined;

    constructor(data?: IEsfJdeApPoMatchDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.jdeType = _data["jdeType"];
            this.jdeSupplierNumber = _data["jdeSupplierNumber"];
            this.jdeDate = _data["jdeDate"] ? new Date(_data["jdeDate"].toString()) : <any>undefined;
            this.jdeContractNumber = _data["jdeContractNumber"];
            this.jdeCurrency = _data["jdeCurrency"];
            this.jdeNetAmount = _data["jdeNetAmount"];
            this.jdeLastUpdatedDate = _data["jdeLastUpdatedDate"] ? new Date(_data["jdeLastUpdatedDate"].toString()) : <any>undefined;
            this.jdeInvoiceId = _data["jdeInvoiceId"];
            this.jdeDocumentNumber = _data["jdeDocumentNumber"];
            this.jdeAddressNumber = _data["jdeAddressNumber"];
            this.esfType = _data["esfType"];
            this.esfDate = _data["esfDate"] ? new Date(_data["esfDate"].toString()) : <any>undefined;
            this.esfNumber = _data["esfNumber"];
            this.esfContractNumber = _data["esfContractNumber"];
            this.esfNetAmount = _data["esfNetAmount"];
            if (Array.isArray(_data["esfJdeApMatchItems"])) {
                this.esfJdeApMatchItems = [] as any;
                for (let item of _data["esfJdeApMatchItems"])
                    this.esfJdeApMatchItems!.push(EsfJdeApPoMatchItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EsfJdeApPoMatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new EsfJdeApPoMatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jdeType"] = this.jdeType;
        data["jdeSupplierNumber"] = this.jdeSupplierNumber;
        data["jdeDate"] = this.jdeDate ? this.jdeDate.toYearMonthDateString() : <any>undefined;
        data["jdeContractNumber"] = this.jdeContractNumber;
        data["jdeCurrency"] = this.jdeCurrency;
        data["jdeNetAmount"] = this.jdeNetAmount;
        data["jdeLastUpdatedDate"] = this.jdeLastUpdatedDate ? this.jdeLastUpdatedDate.toYearMonthDateString() : <any>undefined;
        data["jdeInvoiceId"] = this.jdeInvoiceId;
        data["jdeDocumentNumber"] = this.jdeDocumentNumber;
        data["jdeAddressNumber"] = this.jdeAddressNumber;
        data["esfType"] = this.esfType;
        data["esfDate"] = this.esfDate ? this.esfDate.toYearMonthDateString() : <any>undefined;
        data["esfNumber"] = this.esfNumber;
        data["esfContractNumber"] = this.esfContractNumber;
        data["esfNetAmount"] = this.esfNetAmount;
        if (Array.isArray(this.esfJdeApMatchItems)) {
            data["esfJdeApMatchItems"] = [];
            for (let item of this.esfJdeApMatchItems)
                data["esfJdeApMatchItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IEsfJdeApPoMatchDto extends IEsfJdeApMatchBaseDto {
    id: number;
    jdeType?: string | undefined;
    jdeSupplierNumber?: string | undefined;
    jdeDate?: Date | undefined;
    jdeContractNumber?: string | undefined;
    jdeCurrency?: string | undefined;
    jdeNetAmount?: number | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    jdeDocumentNumber?: string | undefined;
    jdeAddressNumber?: string | undefined;
    esfType?: InvoiceType | undefined;
    esfDate?: Date | undefined;
    esfNumber?: string | undefined;
    esfContractNumber?: string | undefined;
    esfNetAmount?: number | undefined;
    esfJdeApMatchItems?: EsfJdeApPoMatchItemDto[] | undefined;
}

export class EsfJdeApMatchItemBaseDto implements IEsfJdeApMatchItemBaseDto {
    jdeStatus?: string | undefined;
    jdeSupplierNumber?: string | undefined;
    jdeTaxAmount?: number | undefined;
    jdeGrossAmount?: number | undefined;
    jdeDate?: Date | undefined;
    jdeDocumentNumber?: string | undefined;
    jdeType?: string | undefined;
    esfDate?: Date | undefined;
    esfLastUpdatedDate?: Date | undefined;
    esfCurrency?: string | undefined;
    esfTaxAmount?: number | undefined;
    esfGrossAmount?: number | undefined;
    esfRegistrationNumber?: string | undefined;
    esfNumber?: string | undefined;
    esfStatus?: InvoiceStatus | undefined;
    esfType?: InvoiceType | undefined;

    constructor(data?: IEsfJdeApMatchItemBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jdeStatus = _data["jdeStatus"];
            this.jdeSupplierNumber = _data["jdeSupplierNumber"];
            this.jdeTaxAmount = _data["jdeTaxAmount"];
            this.jdeGrossAmount = _data["jdeGrossAmount"];
            this.jdeDate = _data["jdeDate"] ? new Date(_data["jdeDate"].toString()) : <any>undefined;
            this.jdeDocumentNumber = _data["jdeDocumentNumber"];
            this.jdeType = _data["jdeType"];
            this.esfDate = _data["esfDate"] ? new Date(_data["esfDate"].toString()) : <any>undefined;
            this.esfLastUpdatedDate = _data["esfLastUpdatedDate"] ? new Date(_data["esfLastUpdatedDate"].toString()) : <any>undefined;
            this.esfCurrency = _data["esfCurrency"];
            this.esfTaxAmount = _data["esfTaxAmount"];
            this.esfGrossAmount = _data["esfGrossAmount"];
            this.esfRegistrationNumber = _data["esfRegistrationNumber"];
            this.esfNumber = _data["esfNumber"];
            this.esfStatus = _data["esfStatus"];
            this.esfType = _data["esfType"];
        }
    }

    static fromJS(data: any): EsfJdeApMatchItemBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EsfJdeApMatchItemBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jdeStatus"] = this.jdeStatus;
        data["jdeSupplierNumber"] = this.jdeSupplierNumber;
        data["jdeTaxAmount"] = this.jdeTaxAmount;
        data["jdeGrossAmount"] = this.jdeGrossAmount;
        data["jdeDate"] = this.jdeDate ? this.jdeDate.toYearMonthDateString() : <any>undefined;
        data["jdeDocumentNumber"] = this.jdeDocumentNumber;
        data["jdeType"] = this.jdeType;
        data["esfDate"] = this.esfDate ? this.esfDate.toYearMonthDateString() : <any>undefined;
        data["esfLastUpdatedDate"] = this.esfLastUpdatedDate ? this.esfLastUpdatedDate.toYearMonthDateString() : <any>undefined;
        data["esfCurrency"] = this.esfCurrency;
        data["esfTaxAmount"] = this.esfTaxAmount;
        data["esfGrossAmount"] = this.esfGrossAmount;
        data["esfRegistrationNumber"] = this.esfRegistrationNumber;
        data["esfNumber"] = this.esfNumber;
        data["esfStatus"] = this.esfStatus;
        data["esfType"] = this.esfType;
        return data;
    }
}

export interface IEsfJdeApMatchItemBaseDto {
    jdeStatus?: string | undefined;
    jdeSupplierNumber?: string | undefined;
    jdeTaxAmount?: number | undefined;
    jdeGrossAmount?: number | undefined;
    jdeDate?: Date | undefined;
    jdeDocumentNumber?: string | undefined;
    jdeType?: string | undefined;
    esfDate?: Date | undefined;
    esfLastUpdatedDate?: Date | undefined;
    esfCurrency?: string | undefined;
    esfTaxAmount?: number | undefined;
    esfGrossAmount?: number | undefined;
    esfRegistrationNumber?: string | undefined;
    esfNumber?: string | undefined;
    esfStatus?: InvoiceStatus | undefined;
    esfType?: InvoiceType | undefined;
}

export class EsfJdeApPoMatchItemDto extends EsfJdeApMatchItemBaseDto implements IEsfJdeApPoMatchItemDto {
    jdeIinBin?: string | undefined;
    jdeSellerName?: string | undefined;
    jdeContractNumber?: string | undefined;
    jdeCurrency?: string | undefined;
    jdeNetAmount?: number | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    jdeAddressNumber?: string | undefined;
    esfSellerTin?: string | undefined;
    esfSellerName?: string | undefined;
    esfContractNumber?: string | undefined;
    esfNetAmount?: number | undefined;

    constructor(data?: IEsfJdeApPoMatchItemDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.jdeIinBin = _data["jdeIinBin"];
            this.jdeSellerName = _data["jdeSellerName"];
            this.jdeContractNumber = _data["jdeContractNumber"];
            this.jdeCurrency = _data["jdeCurrency"];
            this.jdeNetAmount = _data["jdeNetAmount"];
            this.jdeLastUpdatedDate = _data["jdeLastUpdatedDate"] ? new Date(_data["jdeLastUpdatedDate"].toString()) : <any>undefined;
            this.jdeInvoiceId = _data["jdeInvoiceId"];
            this.jdeAddressNumber = _data["jdeAddressNumber"];
            this.esfSellerTin = _data["esfSellerTin"];
            this.esfSellerName = _data["esfSellerName"];
            this.esfContractNumber = _data["esfContractNumber"];
            this.esfNetAmount = _data["esfNetAmount"];
        }
    }

    static fromJS(data: any): EsfJdeApPoMatchItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new EsfJdeApPoMatchItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jdeIinBin"] = this.jdeIinBin;
        data["jdeSellerName"] = this.jdeSellerName;
        data["jdeContractNumber"] = this.jdeContractNumber;
        data["jdeCurrency"] = this.jdeCurrency;
        data["jdeNetAmount"] = this.jdeNetAmount;
        data["jdeLastUpdatedDate"] = this.jdeLastUpdatedDate ? this.jdeLastUpdatedDate.toYearMonthDateString() : <any>undefined;
        data["jdeInvoiceId"] = this.jdeInvoiceId;
        data["jdeAddressNumber"] = this.jdeAddressNumber;
        data["esfSellerTin"] = this.esfSellerTin;
        data["esfSellerName"] = this.esfSellerName;
        data["esfContractNumber"] = this.esfContractNumber;
        data["esfNetAmount"] = this.esfNetAmount;
        super.toJSON(data);
        return data;
    }
}

export interface IEsfJdeApPoMatchItemDto extends IEsfJdeApMatchItemBaseDto {
    jdeIinBin?: string | undefined;
    jdeSellerName?: string | undefined;
    jdeContractNumber?: string | undefined;
    jdeCurrency?: string | undefined;
    jdeNetAmount?: number | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    jdeAddressNumber?: string | undefined;
    esfSellerTin?: string | undefined;
    esfSellerName?: string | undefined;
    esfContractNumber?: string | undefined;
    esfNetAmount?: number | undefined;
}

export enum ApReconciliationStatus {
    NoMatch = "NoMatch",
    MatchReconciled = "MatchReconciled",
    AllMatchReconciled = "AllMatchReconciled",
    MatchDiffCurrency = "MatchDiffCurrency",
    AllMatchDiffCurrency = "AllMatchDiffCurrency",
    MatchNotReconciled = "MatchNotReconciled",
    AllMatchNotReconciled = "AllMatchNotReconciled",
}

export enum ManualReconciliationCommentType {
    UnderReview = "UnderReview",
    Reconciled = "Reconciled",
    NotReconciled = "NotReconciled",
}

export class GetJdeNcMatchesResponseDto implements IGetJdeNcMatchesResponseDto {
    matches?: EsfJdeApNcMatchDto[] | undefined;
    paging?: PagingModel | undefined;

    constructor(data?: IGetJdeNcMatchesResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(EsfJdeApNcMatchDto.fromJS(item));
            }
            this.paging = _data["paging"] ? PagingModel.fromJS(_data["paging"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetJdeNcMatchesResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetJdeNcMatchesResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item.toJSON());
        }
        data["paging"] = this.paging ? this.paging.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetJdeNcMatchesResponseDto {
    matches?: EsfJdeApNcMatchDto[] | undefined;
    paging?: PagingModel | undefined;
}

export class EsfJdeApNcMatchDto extends EsfJdeApMatchBaseDto implements IEsfJdeApNcMatchDto {
    id!: number;
    jdeType?: string | undefined;
    jdeSupplierNumber?: string | undefined;
    jdeDate?: Date | undefined;
    jdeCurrency?: string | undefined;
    jdeNetAmount?: number | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    jdeDocumentNumber?: string | undefined;
    jdeAddressNumber?: string | undefined;
    esfType?: InvoiceType | undefined;
    esfDate?: Date | undefined;
    esfNumber?: string | undefined;
    esfNetAmount?: number | undefined;
    esfJdeApMatchItems?: EsfJdeApNcMatchItemDto[] | undefined;

    constructor(data?: IEsfJdeApNcMatchDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.jdeType = _data["jdeType"];
            this.jdeSupplierNumber = _data["jdeSupplierNumber"];
            this.jdeDate = _data["jdeDate"] ? new Date(_data["jdeDate"].toString()) : <any>undefined;
            this.jdeCurrency = _data["jdeCurrency"];
            this.jdeNetAmount = _data["jdeNetAmount"];
            this.jdeLastUpdatedDate = _data["jdeLastUpdatedDate"] ? new Date(_data["jdeLastUpdatedDate"].toString()) : <any>undefined;
            this.jdeInvoiceId = _data["jdeInvoiceId"];
            this.jdeDocumentNumber = _data["jdeDocumentNumber"];
            this.jdeAddressNumber = _data["jdeAddressNumber"];
            this.esfType = _data["esfType"];
            this.esfDate = _data["esfDate"] ? new Date(_data["esfDate"].toString()) : <any>undefined;
            this.esfNumber = _data["esfNumber"];
            this.esfNetAmount = _data["esfNetAmount"];
            if (Array.isArray(_data["esfJdeApMatchItems"])) {
                this.esfJdeApMatchItems = [] as any;
                for (let item of _data["esfJdeApMatchItems"])
                    this.esfJdeApMatchItems!.push(EsfJdeApNcMatchItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EsfJdeApNcMatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new EsfJdeApNcMatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jdeType"] = this.jdeType;
        data["jdeSupplierNumber"] = this.jdeSupplierNumber;
        data["jdeDate"] = this.jdeDate ? this.jdeDate.toYearMonthDateString() : <any>undefined;
        data["jdeCurrency"] = this.jdeCurrency;
        data["jdeNetAmount"] = this.jdeNetAmount;
        data["jdeLastUpdatedDate"] = this.jdeLastUpdatedDate ? this.jdeLastUpdatedDate.toYearMonthDateString() : <any>undefined;
        data["jdeInvoiceId"] = this.jdeInvoiceId;
        data["jdeDocumentNumber"] = this.jdeDocumentNumber;
        data["jdeAddressNumber"] = this.jdeAddressNumber;
        data["esfType"] = this.esfType;
        data["esfDate"] = this.esfDate ? this.esfDate.toYearMonthDateString() : <any>undefined;
        data["esfNumber"] = this.esfNumber;
        data["esfNetAmount"] = this.esfNetAmount;
        if (Array.isArray(this.esfJdeApMatchItems)) {
            data["esfJdeApMatchItems"] = [];
            for (let item of this.esfJdeApMatchItems)
                data["esfJdeApMatchItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IEsfJdeApNcMatchDto extends IEsfJdeApMatchBaseDto {
    id: number;
    jdeType?: string | undefined;
    jdeSupplierNumber?: string | undefined;
    jdeDate?: Date | undefined;
    jdeCurrency?: string | undefined;
    jdeNetAmount?: number | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    jdeDocumentNumber?: string | undefined;
    jdeAddressNumber?: string | undefined;
    esfType?: InvoiceType | undefined;
    esfDate?: Date | undefined;
    esfNumber?: string | undefined;
    esfNetAmount?: number | undefined;
    esfJdeApMatchItems?: EsfJdeApNcMatchItemDto[] | undefined;
}

export class EsfJdeApNcMatchItemDto extends EsfJdeApMatchItemBaseDto implements IEsfJdeApNcMatchItemDto {
    jdeIinBin?: string | undefined;
    jdeSellerName?: string | undefined;
    jdeCurrency?: string | undefined;
    jdeNetAmount?: number | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    jdeAddressNumber?: string | undefined;
    esfSellerTin?: string | undefined;
    esfSellerName?: string | undefined;
    esfNetAmount?: number | undefined;

    constructor(data?: IEsfJdeApNcMatchItemDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.jdeIinBin = _data["jdeIinBin"];
            this.jdeSellerName = _data["jdeSellerName"];
            this.jdeCurrency = _data["jdeCurrency"];
            this.jdeNetAmount = _data["jdeNetAmount"];
            this.jdeLastUpdatedDate = _data["jdeLastUpdatedDate"] ? new Date(_data["jdeLastUpdatedDate"].toString()) : <any>undefined;
            this.jdeInvoiceId = _data["jdeInvoiceId"];
            this.jdeAddressNumber = _data["jdeAddressNumber"];
            this.esfSellerTin = _data["esfSellerTin"];
            this.esfSellerName = _data["esfSellerName"];
            this.esfNetAmount = _data["esfNetAmount"];
        }
    }

    static fromJS(data: any): EsfJdeApNcMatchItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new EsfJdeApNcMatchItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jdeIinBin"] = this.jdeIinBin;
        data["jdeSellerName"] = this.jdeSellerName;
        data["jdeCurrency"] = this.jdeCurrency;
        data["jdeNetAmount"] = this.jdeNetAmount;
        data["jdeLastUpdatedDate"] = this.jdeLastUpdatedDate ? this.jdeLastUpdatedDate.toYearMonthDateString() : <any>undefined;
        data["jdeInvoiceId"] = this.jdeInvoiceId;
        data["jdeAddressNumber"] = this.jdeAddressNumber;
        data["esfSellerTin"] = this.esfSellerTin;
        data["esfSellerName"] = this.esfSellerName;
        data["esfNetAmount"] = this.esfNetAmount;
        super.toJSON(data);
        return data;
    }
}

export interface IEsfJdeApNcMatchItemDto extends IEsfJdeApMatchItemBaseDto {
    jdeIinBin?: string | undefined;
    jdeSellerName?: string | undefined;
    jdeCurrency?: string | undefined;
    jdeNetAmount?: number | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    jdeAddressNumber?: string | undefined;
    esfSellerTin?: string | undefined;
    esfSellerName?: string | undefined;
    esfNetAmount?: number | undefined;
}

export class GetJdeSoMatchesResponseDto implements IGetJdeSoMatchesResponseDto {
    matches?: EsfJdeApSoMatchDto[] | undefined;
    paging?: PagingModel | undefined;

    constructor(data?: IGetJdeSoMatchesResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(EsfJdeApSoMatchDto.fromJS(item));
            }
            this.paging = _data["paging"] ? PagingModel.fromJS(_data["paging"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetJdeSoMatchesResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetJdeSoMatchesResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item.toJSON());
        }
        data["paging"] = this.paging ? this.paging.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetJdeSoMatchesResponseDto {
    matches?: EsfJdeApSoMatchDto[] | undefined;
    paging?: PagingModel | undefined;
}

export class EsfJdeApSoMatchDto extends EsfJdeApMatchBaseDto implements IEsfJdeApSoMatchDto {
    id!: number;
    jdeType?: string | undefined;
    jdeDate?: Date | undefined;
    jdeSupplierNumber?: string | undefined;
    jdeContractNumber?: string | undefined;
    jdeCurrency?: string | undefined;
    jdeNetAmount?: number | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    jdeDocumentNumber?: string | undefined;
    jdeAddressNumber?: string | undefined;
    esfType?: InvoiceType | undefined;
    esfDate?: Date | undefined;
    esfNumber?: string | undefined;
    esfContractNumber?: string | undefined;
    esfNetAmount?: number | undefined;
    esfJdeApMatchItems?: EsfJdeApSoMatchItemDto[] | undefined;

    constructor(data?: IEsfJdeApSoMatchDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.jdeType = _data["jdeType"];
            this.jdeDate = _data["jdeDate"] ? new Date(_data["jdeDate"].toString()) : <any>undefined;
            this.jdeSupplierNumber = _data["jdeSupplierNumber"];
            this.jdeContractNumber = _data["jdeContractNumber"];
            this.jdeCurrency = _data["jdeCurrency"];
            this.jdeNetAmount = _data["jdeNetAmount"];
            this.jdeLastUpdatedDate = _data["jdeLastUpdatedDate"] ? new Date(_data["jdeLastUpdatedDate"].toString()) : <any>undefined;
            this.jdeInvoiceId = _data["jdeInvoiceId"];
            this.jdeDocumentNumber = _data["jdeDocumentNumber"];
            this.jdeAddressNumber = _data["jdeAddressNumber"];
            this.esfType = _data["esfType"];
            this.esfDate = _data["esfDate"] ? new Date(_data["esfDate"].toString()) : <any>undefined;
            this.esfNumber = _data["esfNumber"];
            this.esfContractNumber = _data["esfContractNumber"];
            this.esfNetAmount = _data["esfNetAmount"];
            if (Array.isArray(_data["esfJdeApMatchItems"])) {
                this.esfJdeApMatchItems = [] as any;
                for (let item of _data["esfJdeApMatchItems"])
                    this.esfJdeApMatchItems!.push(EsfJdeApSoMatchItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EsfJdeApSoMatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new EsfJdeApSoMatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jdeType"] = this.jdeType;
        data["jdeDate"] = this.jdeDate ? this.jdeDate.toYearMonthDateString() : <any>undefined;
        data["jdeSupplierNumber"] = this.jdeSupplierNumber;
        data["jdeContractNumber"] = this.jdeContractNumber;
        data["jdeCurrency"] = this.jdeCurrency;
        data["jdeNetAmount"] = this.jdeNetAmount;
        data["jdeLastUpdatedDate"] = this.jdeLastUpdatedDate ? this.jdeLastUpdatedDate.toYearMonthDateString() : <any>undefined;
        data["jdeInvoiceId"] = this.jdeInvoiceId;
        data["jdeDocumentNumber"] = this.jdeDocumentNumber;
        data["jdeAddressNumber"] = this.jdeAddressNumber;
        data["esfType"] = this.esfType;
        data["esfDate"] = this.esfDate ? this.esfDate.toYearMonthDateString() : <any>undefined;
        data["esfNumber"] = this.esfNumber;
        data["esfContractNumber"] = this.esfContractNumber;
        data["esfNetAmount"] = this.esfNetAmount;
        if (Array.isArray(this.esfJdeApMatchItems)) {
            data["esfJdeApMatchItems"] = [];
            for (let item of this.esfJdeApMatchItems)
                data["esfJdeApMatchItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IEsfJdeApSoMatchDto extends IEsfJdeApMatchBaseDto {
    id: number;
    jdeType?: string | undefined;
    jdeDate?: Date | undefined;
    jdeSupplierNumber?: string | undefined;
    jdeContractNumber?: string | undefined;
    jdeCurrency?: string | undefined;
    jdeNetAmount?: number | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    jdeDocumentNumber?: string | undefined;
    jdeAddressNumber?: string | undefined;
    esfType?: InvoiceType | undefined;
    esfDate?: Date | undefined;
    esfNumber?: string | undefined;
    esfContractNumber?: string | undefined;
    esfNetAmount?: number | undefined;
    esfJdeApMatchItems?: EsfJdeApSoMatchItemDto[] | undefined;
}

export class EsfJdeApSoMatchItemDto extends EsfJdeApMatchItemBaseDto implements IEsfJdeApSoMatchItemDto {
    id!: number;
    jdeIinBin?: string | undefined;
    jdeSellerName?: string | undefined;
    jdeContractNumber?: string | undefined;
    jdeCurrency?: string | undefined;
    jdeNetAmount?: number | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    jdeAddressNumber?: string | undefined;
    esfSellerTin?: string | undefined;
    esfSellerName?: string | undefined;
    esfContractNumber?: string | undefined;
    esfNetAmount?: number | undefined;

    constructor(data?: IEsfJdeApSoMatchItemDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.jdeIinBin = _data["jdeIinBin"];
            this.jdeSellerName = _data["jdeSellerName"];
            this.jdeContractNumber = _data["jdeContractNumber"];
            this.jdeCurrency = _data["jdeCurrency"];
            this.jdeNetAmount = _data["jdeNetAmount"];
            this.jdeLastUpdatedDate = _data["jdeLastUpdatedDate"] ? new Date(_data["jdeLastUpdatedDate"].toString()) : <any>undefined;
            this.jdeInvoiceId = _data["jdeInvoiceId"];
            this.jdeAddressNumber = _data["jdeAddressNumber"];
            this.esfSellerTin = _data["esfSellerTin"];
            this.esfSellerName = _data["esfSellerName"];
            this.esfContractNumber = _data["esfContractNumber"];
            this.esfNetAmount = _data["esfNetAmount"];
        }
    }

    static fromJS(data: any): EsfJdeApSoMatchItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new EsfJdeApSoMatchItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jdeIinBin"] = this.jdeIinBin;
        data["jdeSellerName"] = this.jdeSellerName;
        data["jdeContractNumber"] = this.jdeContractNumber;
        data["jdeCurrency"] = this.jdeCurrency;
        data["jdeNetAmount"] = this.jdeNetAmount;
        data["jdeLastUpdatedDate"] = this.jdeLastUpdatedDate ? this.jdeLastUpdatedDate.toYearMonthDateString() : <any>undefined;
        data["jdeInvoiceId"] = this.jdeInvoiceId;
        data["jdeAddressNumber"] = this.jdeAddressNumber;
        data["esfSellerTin"] = this.esfSellerTin;
        data["esfSellerName"] = this.esfSellerName;
        data["esfContractNumber"] = this.esfContractNumber;
        data["esfNetAmount"] = this.esfNetAmount;
        super.toJSON(data);
        return data;
    }
}

export interface IEsfJdeApSoMatchItemDto extends IEsfJdeApMatchItemBaseDto {
    id: number;
    jdeIinBin?: string | undefined;
    jdeSellerName?: string | undefined;
    jdeContractNumber?: string | undefined;
    jdeCurrency?: string | undefined;
    jdeNetAmount?: number | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    jdeAddressNumber?: string | undefined;
    esfSellerTin?: string | undefined;
    esfSellerName?: string | undefined;
    esfContractNumber?: string | undefined;
    esfNetAmount?: number | undefined;
}

export class GetJdeUndistributedMatchesResponseDto implements IGetJdeUndistributedMatchesResponseDto {
    matches?: EsfJdeApUndistributedMatchDto[] | undefined;
    paging?: PagingModel | undefined;

    constructor(data?: IGetJdeUndistributedMatchesResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(EsfJdeApUndistributedMatchDto.fromJS(item));
            }
            this.paging = _data["paging"] ? PagingModel.fromJS(_data["paging"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetJdeUndistributedMatchesResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetJdeUndistributedMatchesResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item.toJSON());
        }
        data["paging"] = this.paging ? this.paging.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetJdeUndistributedMatchesResponseDto {
    matches?: EsfJdeApUndistributedMatchDto[] | undefined;
    paging?: PagingModel | undefined;
}

export class EsfJdeApUndistributedMatchDto extends EsfJdeApMatchBaseDto implements IEsfJdeApUndistributedMatchDto {
    id!: number;
    jdeType?: string | undefined;
    jdeDate?: Date | undefined;
    jdeSupplierNumber?: string | undefined;
    jdeContractNumber?: string | undefined;
    jdeCurrency?: string | undefined;
    jdeNetAmount?: number | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    jdeDocumentNumber?: string | undefined;
    jdeAddressNumber?: string | undefined;
    esfType?: InvoiceType | undefined;
    esfDate?: Date | undefined;
    esfNumber?: string | undefined;
    esfContractNumber?: string | undefined;
    esfNetAmount?: number | undefined;
    apMatchType!: ApMatchType;
    esfJdeApMatchItems?: EsfJdeApUndistributedMatchItemDto[] | undefined;

    constructor(data?: IEsfJdeApUndistributedMatchDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.jdeType = _data["jdeType"];
            this.jdeDate = _data["jdeDate"] ? new Date(_data["jdeDate"].toString()) : <any>undefined;
            this.jdeSupplierNumber = _data["jdeSupplierNumber"];
            this.jdeContractNumber = _data["jdeContractNumber"];
            this.jdeCurrency = _data["jdeCurrency"];
            this.jdeNetAmount = _data["jdeNetAmount"];
            this.jdeLastUpdatedDate = _data["jdeLastUpdatedDate"] ? new Date(_data["jdeLastUpdatedDate"].toString()) : <any>undefined;
            this.jdeInvoiceId = _data["jdeInvoiceId"];
            this.jdeDocumentNumber = _data["jdeDocumentNumber"];
            this.jdeAddressNumber = _data["jdeAddressNumber"];
            this.esfType = _data["esfType"];
            this.esfDate = _data["esfDate"] ? new Date(_data["esfDate"].toString()) : <any>undefined;
            this.esfNumber = _data["esfNumber"];
            this.esfContractNumber = _data["esfContractNumber"];
            this.esfNetAmount = _data["esfNetAmount"];
            this.apMatchType = _data["apMatchType"];
            if (Array.isArray(_data["esfJdeApMatchItems"])) {
                this.esfJdeApMatchItems = [] as any;
                for (let item of _data["esfJdeApMatchItems"])
                    this.esfJdeApMatchItems!.push(EsfJdeApUndistributedMatchItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EsfJdeApUndistributedMatchDto {
        data = typeof data === 'object' ? data : {};
        let result = new EsfJdeApUndistributedMatchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jdeType"] = this.jdeType;
        data["jdeDate"] = this.jdeDate ? this.jdeDate.toYearMonthDateString() : <any>undefined;
        data["jdeSupplierNumber"] = this.jdeSupplierNumber;
        data["jdeContractNumber"] = this.jdeContractNumber;
        data["jdeCurrency"] = this.jdeCurrency;
        data["jdeNetAmount"] = this.jdeNetAmount;
        data["jdeLastUpdatedDate"] = this.jdeLastUpdatedDate ? this.jdeLastUpdatedDate.toYearMonthDateString() : <any>undefined;
        data["jdeInvoiceId"] = this.jdeInvoiceId;
        data["jdeDocumentNumber"] = this.jdeDocumentNumber;
        data["jdeAddressNumber"] = this.jdeAddressNumber;
        data["esfType"] = this.esfType;
        data["esfDate"] = this.esfDate ? this.esfDate.toYearMonthDateString() : <any>undefined;
        data["esfNumber"] = this.esfNumber;
        data["esfContractNumber"] = this.esfContractNumber;
        data["esfNetAmount"] = this.esfNetAmount;
        data["apMatchType"] = this.apMatchType;
        if (Array.isArray(this.esfJdeApMatchItems)) {
            data["esfJdeApMatchItems"] = [];
            for (let item of this.esfJdeApMatchItems)
                data["esfJdeApMatchItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IEsfJdeApUndistributedMatchDto extends IEsfJdeApMatchBaseDto {
    id: number;
    jdeType?: string | undefined;
    jdeDate?: Date | undefined;
    jdeSupplierNumber?: string | undefined;
    jdeContractNumber?: string | undefined;
    jdeCurrency?: string | undefined;
    jdeNetAmount?: number | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    jdeDocumentNumber?: string | undefined;
    jdeAddressNumber?: string | undefined;
    esfType?: InvoiceType | undefined;
    esfDate?: Date | undefined;
    esfNumber?: string | undefined;
    esfContractNumber?: string | undefined;
    esfNetAmount?: number | undefined;
    apMatchType: ApMatchType;
    esfJdeApMatchItems?: EsfJdeApUndistributedMatchItemDto[] | undefined;
}

export enum ApMatchType {
    ApNcMatch = "ApNcMatch",
    ApPoMatch = "ApPoMatch",
    ApSoMatch = "ApSoMatch",
}

export class EsfJdeApUndistributedMatchItemDto extends EsfJdeApMatchItemBaseDto implements IEsfJdeApUndistributedMatchItemDto {
    jdeIinBin?: string | undefined;
    jdeSellerName?: string | undefined;
    jdeContractNumber?: string | undefined;
    jdeCurrency?: string | undefined;
    jdeNetAmount?: number | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    jdeAddressNumber?: string | undefined;
    esfSellerTin?: string | undefined;
    esfSellerName?: string | undefined;
    esfContractNumber?: string | undefined;
    esfNetAmount?: number | undefined;

    constructor(data?: IEsfJdeApUndistributedMatchItemDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.jdeIinBin = _data["jdeIinBin"];
            this.jdeSellerName = _data["jdeSellerName"];
            this.jdeContractNumber = _data["jdeContractNumber"];
            this.jdeCurrency = _data["jdeCurrency"];
            this.jdeNetAmount = _data["jdeNetAmount"];
            this.jdeLastUpdatedDate = _data["jdeLastUpdatedDate"] ? new Date(_data["jdeLastUpdatedDate"].toString()) : <any>undefined;
            this.jdeInvoiceId = _data["jdeInvoiceId"];
            this.jdeAddressNumber = _data["jdeAddressNumber"];
            this.esfSellerTin = _data["esfSellerTin"];
            this.esfSellerName = _data["esfSellerName"];
            this.esfContractNumber = _data["esfContractNumber"];
            this.esfNetAmount = _data["esfNetAmount"];
        }
    }

    static fromJS(data: any): EsfJdeApUndistributedMatchItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new EsfJdeApUndistributedMatchItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jdeIinBin"] = this.jdeIinBin;
        data["jdeSellerName"] = this.jdeSellerName;
        data["jdeContractNumber"] = this.jdeContractNumber;
        data["jdeCurrency"] = this.jdeCurrency;
        data["jdeNetAmount"] = this.jdeNetAmount;
        data["jdeLastUpdatedDate"] = this.jdeLastUpdatedDate ? this.jdeLastUpdatedDate.toYearMonthDateString() : <any>undefined;
        data["jdeInvoiceId"] = this.jdeInvoiceId;
        data["jdeAddressNumber"] = this.jdeAddressNumber;
        data["esfSellerTin"] = this.esfSellerTin;
        data["esfSellerName"] = this.esfSellerName;
        data["esfContractNumber"] = this.esfContractNumber;
        data["esfNetAmount"] = this.esfNetAmount;
        super.toJSON(data);
        return data;
    }
}

export interface IEsfJdeApUndistributedMatchItemDto extends IEsfJdeApMatchItemBaseDto {
    jdeIinBin?: string | undefined;
    jdeSellerName?: string | undefined;
    jdeContractNumber?: string | undefined;
    jdeCurrency?: string | undefined;
    jdeNetAmount?: number | undefined;
    jdeLastUpdatedDate?: Date | undefined;
    jdeInvoiceId?: number | undefined;
    jdeAddressNumber?: string | undefined;
    esfSellerTin?: string | undefined;
    esfSellerName?: string | undefined;
    esfContractNumber?: string | undefined;
    esfNetAmount?: number | undefined;
}

export class GetSuppliersResultDto implements IGetSuppliersResultDto {
    name?: string | undefined;
    tin?: string | undefined;

    constructor(data?: IGetSuppliersResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.tin = _data["tin"];
        }
    }

    static fromJS(data: any): GetSuppliersResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSuppliersResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["tin"] = this.tin;
        return data;
    }
}

export interface IGetSuppliersResultDto {
    name?: string | undefined;
    tin?: string | undefined;
}

export class GetArLastUpdateDatesDto implements IGetArLastUpdateDatesDto {
    jdeArLastUpdateDate!: Date;
    jdeArLastSyncDate!: Date;
    esfLastSyncDate!: Date;
    esfLastUpdateDate!: Date;

    constructor(data?: IGetArLastUpdateDatesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jdeArLastUpdateDate = _data["jdeArLastUpdateDate"] ? new Date(_data["jdeArLastUpdateDate"].toString()) : <any>undefined;
            this.jdeArLastSyncDate = _data["jdeArLastSyncDate"] ? new Date(_data["jdeArLastSyncDate"].toString()) : <any>undefined;
            this.esfLastSyncDate = _data["esfLastSyncDate"] ? new Date(_data["esfLastSyncDate"].toString()) : <any>undefined;
            this.esfLastUpdateDate = _data["esfLastUpdateDate"] ? new Date(_data["esfLastUpdateDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetArLastUpdateDatesDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetArLastUpdateDatesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jdeArLastUpdateDate"] = this.jdeArLastUpdateDate ? this.jdeArLastUpdateDate.toYearMonthDateString() : <any>undefined;
        data["jdeArLastSyncDate"] = this.jdeArLastSyncDate ? this.jdeArLastSyncDate.toYearMonthDateString() : <any>undefined;
        data["esfLastSyncDate"] = this.esfLastSyncDate ? this.esfLastSyncDate.toYearMonthDateString() : <any>undefined;
        data["esfLastUpdateDate"] = this.esfLastUpdateDate ? this.esfLastUpdateDate.toYearMonthDateString() : <any>undefined;
        return data;
    }
}

export interface IGetArLastUpdateDatesDto {
    jdeArLastUpdateDate: Date;
    jdeArLastSyncDate: Date;
    esfLastSyncDate: Date;
    esfLastUpdateDate: Date;
}

export class GetApLastUpdateDatesDto implements IGetApLastUpdateDatesDto {
    jdeApLastUpdateDate!: Date;
    jdeApLastSyncDate!: Date;
    esfLastSyncDate!: Date;
    esfLastUpdateDate!: Date;

    constructor(data?: IGetApLastUpdateDatesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jdeApLastUpdateDate = _data["jdeApLastUpdateDate"] ? new Date(_data["jdeApLastUpdateDate"].toString()) : <any>undefined;
            this.jdeApLastSyncDate = _data["jdeApLastSyncDate"] ? new Date(_data["jdeApLastSyncDate"].toString()) : <any>undefined;
            this.esfLastSyncDate = _data["esfLastSyncDate"] ? new Date(_data["esfLastSyncDate"].toString()) : <any>undefined;
            this.esfLastUpdateDate = _data["esfLastUpdateDate"] ? new Date(_data["esfLastUpdateDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetApLastUpdateDatesDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetApLastUpdateDatesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jdeApLastUpdateDate"] = this.jdeApLastUpdateDate ? this.jdeApLastUpdateDate.toYearMonthDateString() : <any>undefined;
        data["jdeApLastSyncDate"] = this.jdeApLastSyncDate ? this.jdeApLastSyncDate.toYearMonthDateString() : <any>undefined;
        data["esfLastSyncDate"] = this.esfLastSyncDate ? this.esfLastSyncDate.toYearMonthDateString() : <any>undefined;
        data["esfLastUpdateDate"] = this.esfLastUpdateDate ? this.esfLastUpdateDate.toYearMonthDateString() : <any>undefined;
        return data;
    }
}

export interface IGetApLastUpdateDatesDto {
    jdeApLastUpdateDate: Date;
    jdeApLastSyncDate: Date;
    esfLastSyncDate: Date;
    esfLastUpdateDate: Date;
}

export class ChangeManualReconciliationCommentResponseDto implements IChangeManualReconciliationCommentResponseDto {
    id!: number;
    manualReconciliationCommentUpdateDate!: Date;
    manualReconciliationComment!: ManualReconciliationCommentType;
    commentUpdatedUserFullName?: string | undefined;

    constructor(data?: IChangeManualReconciliationCommentResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.manualReconciliationCommentUpdateDate = _data["manualReconciliationCommentUpdateDate"] ? new Date(_data["manualReconciliationCommentUpdateDate"].toString()) : <any>undefined;
            this.manualReconciliationComment = _data["manualReconciliationComment"];
            this.commentUpdatedUserFullName = _data["commentUpdatedUserFullName"];
        }
    }

    static fromJS(data: any): ChangeManualReconciliationCommentResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeManualReconciliationCommentResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["manualReconciliationCommentUpdateDate"] = this.manualReconciliationCommentUpdateDate ? this.manualReconciliationCommentUpdateDate.toYearMonthDateString() : <any>undefined;
        data["manualReconciliationComment"] = this.manualReconciliationComment;
        data["commentUpdatedUserFullName"] = this.commentUpdatedUserFullName;
        return data;
    }
}

export interface IChangeManualReconciliationCommentResponseDto {
    id: number;
    manualReconciliationCommentUpdateDate: Date;
    manualReconciliationComment: ManualReconciliationCommentType;
    commentUpdatedUserFullName?: string | undefined;
}

export class ChangeManualReconciliationCommentDto implements IChangeManualReconciliationCommentDto {
    id!: number;
    apMatch!: ApMatchType;
    manualReconciliationCommentType!: ManualReconciliationCommentType;

    constructor(data?: IChangeManualReconciliationCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.apMatch = _data["apMatch"];
            this.manualReconciliationCommentType = _data["manualReconciliationCommentType"];
        }
    }

    static fromJS(data: any): ChangeManualReconciliationCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeManualReconciliationCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["apMatch"] = this.apMatch;
        data["manualReconciliationCommentType"] = this.manualReconciliationCommentType;
        return data;
    }
}

export interface IChangeManualReconciliationCommentDto {
    id: number;
    apMatch: ApMatchType;
    manualReconciliationCommentType: ManualReconciliationCommentType;
}

export class SntListResponseDto implements ISntListResponseDto {
    snts?: SntSimpleDto[] | undefined;
    paging?: PagingModel | undefined;

    constructor(data?: ISntListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["snts"])) {
                this.snts = [] as any;
                for (let item of _data["snts"])
                    this.snts!.push(SntSimpleDto.fromJS(item));
            }
            this.paging = _data["paging"] ? PagingModel.fromJS(_data["paging"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SntListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.snts)) {
            data["snts"] = [];
            for (let item of this.snts)
                data["snts"].push(item.toJSON());
        }
        data["paging"] = this.paging ? this.paging.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISntListResponseDto {
    snts?: SntSimpleDto[] | undefined;
    paging?: PagingModel | undefined;
}

export class SntSimpleDto implements ISntSimpleDto {
    id!: number;
    externalId?: number | undefined;
    registrationNumber?: string | undefined;
    number?: string | undefined;
    date?: Date | undefined;
    senderTin?: string | undefined;
    senderName?: string | undefined;
    senderNonResident!: boolean;
    recipientTin?: string | undefined;
    recipientNonResident!: boolean;
    status!: SntStatus;
    lastUpdateDate!: Date;
    inputDate!: Date;
    cancelReason?: string | undefined;
    sntType!: SntType;
    customerTaxpareStoreId?: number | undefined;
    sellerTaxpareStoreId?: number | undefined;

    constructor(data?: ISntSimpleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.registrationNumber = _data["registrationNumber"];
            this.number = _data["number"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.senderTin = _data["senderTin"];
            this.senderName = _data["senderName"];
            this.senderNonResident = _data["senderNonResident"];
            this.recipientTin = _data["recipientTin"];
            this.recipientNonResident = _data["recipientNonResident"];
            this.status = _data["status"];
            this.lastUpdateDate = _data["lastUpdateDate"] ? new Date(_data["lastUpdateDate"].toString()) : <any>undefined;
            this.inputDate = _data["inputDate"] ? new Date(_data["inputDate"].toString()) : <any>undefined;
            this.cancelReason = _data["cancelReason"];
            this.sntType = _data["sntType"];
            this.customerTaxpareStoreId = _data["customerTaxpareStoreId"];
            this.sellerTaxpareStoreId = _data["sellerTaxpareStoreId"];
        }
    }

    static fromJS(data: any): SntSimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntSimpleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["registrationNumber"] = this.registrationNumber;
        data["number"] = this.number;
        data["date"] = this.date ? this.date.toYearMonthDateString() : <any>undefined;
        data["senderTin"] = this.senderTin;
        data["senderName"] = this.senderName;
        data["senderNonResident"] = this.senderNonResident;
        data["recipientTin"] = this.recipientTin;
        data["recipientNonResident"] = this.recipientNonResident;
        data["status"] = this.status;
        data["lastUpdateDate"] = this.lastUpdateDate ? this.lastUpdateDate.toYearMonthDateString() : <any>undefined;
        data["inputDate"] = this.inputDate ? this.inputDate.toYearMonthDateString() : <any>undefined;
        data["cancelReason"] = this.cancelReason;
        data["sntType"] = this.sntType;
        data["customerTaxpareStoreId"] = this.customerTaxpareStoreId;
        data["sellerTaxpareStoreId"] = this.sellerTaxpareStoreId;
        return data;
    }
}

export interface ISntSimpleDto {
    id: number;
    externalId?: number | undefined;
    registrationNumber?: string | undefined;
    number?: string | undefined;
    date?: Date | undefined;
    senderTin?: string | undefined;
    senderName?: string | undefined;
    senderNonResident: boolean;
    recipientTin?: string | undefined;
    recipientNonResident: boolean;
    status: SntStatus;
    lastUpdateDate: Date;
    inputDate: Date;
    cancelReason?: string | undefined;
    sntType: SntType;
    customerTaxpareStoreId?: number | undefined;
    sellerTaxpareStoreId?: number | undefined;
}

export enum SntStatus {
    DRAFT = "DRAFT",
    NOT_VIEWED = "NOT_VIEWED",
    DELIVERED = "DELIVERED",
    CREATED = "CREATED",
    IMPORTED = "IMPORTED",
    FAILED = "FAILED",
    CONFIRMED = "CONFIRMED",
    DECLINED = "DECLINED",
    CONFIRMED_BY_OGD = "CONFIRMED_BY_OGD",
    DECLINED_BY_OGD = "DECLINED_BY_OGD",
    CANCELED = "CANCELED",
    REVOKED = "REVOKED",
}

export enum SntType {
    PRIMARY_SNT = "PRIMARY_SNT",
    RETURNED_SNT = "RETURNED_SNT",
    FIXED_SNT = "FIXED_SNT",
}

export enum SntFilterType {
    PRIMARY_SNT = "PRIMARY_SNT",
    RETURNED_SNT = "RETURNED_SNT",
    FIXED_SNT = "FIXED_SNT",
    EXPORT_SNT = "EXPORT_SNT",
    TRANSFER_SNT = "TRANSFER_SNT",
    IS_PAPER_SNT = "IS_PAPER_SNT",
}

export enum SntImportType {
    IMPORT = "IMPORT",
    IMPORT_FOR_PROCESSING = "IMPORT_FOR_PROCESSING",
    TEMPORARY_IMPORT = "TEMPORARY_IMPORT",
    IMPORT_OF_TEMPORARY_EXPORTED_PRODUCT = "IMPORT_OF_TEMPORARY_EXPORTED_PRODUCT",
    IMPORT_IN_SEZ = "IMPORT_IN_SEZ",
}

export enum SntExportType {
    EXPORT = "EXPORT",
    EXPORT_FOR_PROCESSING = "EXPORT_FOR_PROCESSING",
    TEMPORARY_EXPORT = "TEMPORARY_EXPORT",
    EXPORT_OF_TEMPORARY_IMPORTED_PRODUCT = "EXPORT_OF_TEMPORARY_IMPORTED_PRODUCT",
    EXPORT_FROM_SEZ = "EXPORT_FROM_SEZ",
    AIRCRAFT_REFUELING = "AIRCRAFT_REFUELING",
}

export enum SntTransferType {
    ONE_PERSON_IN_KZ = "ONE_PERSON_IN_KZ",
    ONE_PERSON_IN_EAEU = "ONE_PERSON_IN_EAEU",
    OTHER = "OTHER",
}

export enum SntCategory {
    INBOUND = "INBOUND",
    OUTBOUND = "OUTBOUND",
    INPROGRESS = "INPROGRESS",
}

export class GetSntProductBySntIdResponseDto implements IGetSntProductBySntIdResponseDto {
    sntDate!: Date;
    registrationNumber?: string | undefined;
    customerTin?: string | undefined;
    customerCountryCode?: string | undefined;
    customerNonResident!: boolean;
    customerStatuses?: SntParticipantType[] | undefined;
    consigneeTin?: string | undefined;
    consigneeCountryCode?: string | undefined;
    exportType?: SntExportType | undefined;
    sellerStatuses?: SntParticipantType[] | undefined;
    isContract!: boolean;
    contractNumber?: string | undefined;
    contractDate?: Date | undefined;
    contractDeliveryCondition?: string | undefined;
    termOfContractPayment?: string | undefined;
    transportType?: string | undefined;
    powerOfAttorneyNumber?: string | undefined;
    powerOfAttorneyDate?: Date | undefined;
    products?: SntProductFullDto[] | undefined;
    oilProducts?: SntOilProductDto[] | undefined;

    constructor(data?: IGetSntProductBySntIdResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sntDate = _data["sntDate"] ? new Date(_data["sntDate"].toString()) : <any>undefined;
            this.registrationNumber = _data["registrationNumber"];
            this.customerTin = _data["customerTin"];
            this.customerCountryCode = _data["customerCountryCode"];
            this.customerNonResident = _data["customerNonResident"];
            if (Array.isArray(_data["customerStatuses"])) {
                this.customerStatuses = [] as any;
                for (let item of _data["customerStatuses"])
                    this.customerStatuses!.push(item);
            }
            this.consigneeTin = _data["consigneeTin"];
            this.consigneeCountryCode = _data["consigneeCountryCode"];
            this.exportType = _data["exportType"];
            if (Array.isArray(_data["sellerStatuses"])) {
                this.sellerStatuses = [] as any;
                for (let item of _data["sellerStatuses"])
                    this.sellerStatuses!.push(item);
            }
            this.isContract = _data["isContract"];
            this.contractNumber = _data["contractNumber"];
            this.contractDate = _data["contractDate"] ? new Date(_data["contractDate"].toString()) : <any>undefined;
            this.contractDeliveryCondition = _data["contractDeliveryCondition"];
            this.termOfContractPayment = _data["termOfContractPayment"];
            this.transportType = _data["transportType"];
            this.powerOfAttorneyNumber = _data["powerOfAttorneyNumber"];
            this.powerOfAttorneyDate = _data["powerOfAttorneyDate"] ? new Date(_data["powerOfAttorneyDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(SntProductFullDto.fromJS(item));
            }
            if (Array.isArray(_data["oilProducts"])) {
                this.oilProducts = [] as any;
                for (let item of _data["oilProducts"])
                    this.oilProducts!.push(SntOilProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSntProductBySntIdResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSntProductBySntIdResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sntDate"] = this.sntDate ? this.sntDate.toYearMonthDateString() : <any>undefined;
        data["registrationNumber"] = this.registrationNumber;
        data["customerTin"] = this.customerTin;
        data["customerCountryCode"] = this.customerCountryCode;
        data["customerNonResident"] = this.customerNonResident;
        if (Array.isArray(this.customerStatuses)) {
            data["customerStatuses"] = [];
            for (let item of this.customerStatuses)
                data["customerStatuses"].push(item);
        }
        data["consigneeTin"] = this.consigneeTin;
        data["consigneeCountryCode"] = this.consigneeCountryCode;
        data["exportType"] = this.exportType;
        if (Array.isArray(this.sellerStatuses)) {
            data["sellerStatuses"] = [];
            for (let item of this.sellerStatuses)
                data["sellerStatuses"].push(item);
        }
        data["isContract"] = this.isContract;
        data["contractNumber"] = this.contractNumber;
        data["contractDate"] = this.contractDate ? this.contractDate.toYearMonthDateString() : <any>undefined;
        data["contractDeliveryCondition"] = this.contractDeliveryCondition;
        data["termOfContractPayment"] = this.termOfContractPayment;
        data["transportType"] = this.transportType;
        data["powerOfAttorneyNumber"] = this.powerOfAttorneyNumber;
        data["powerOfAttorneyDate"] = this.powerOfAttorneyDate ? this.powerOfAttorneyDate.toYearMonthDateString() : <any>undefined;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        if (Array.isArray(this.oilProducts)) {
            data["oilProducts"] = [];
            for (let item of this.oilProducts)
                data["oilProducts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetSntProductBySntIdResponseDto {
    sntDate: Date;
    registrationNumber?: string | undefined;
    customerTin?: string | undefined;
    customerCountryCode?: string | undefined;
    customerNonResident: boolean;
    customerStatuses?: SntParticipantType[] | undefined;
    consigneeTin?: string | undefined;
    consigneeCountryCode?: string | undefined;
    exportType?: SntExportType | undefined;
    sellerStatuses?: SntParticipantType[] | undefined;
    isContract: boolean;
    contractNumber?: string | undefined;
    contractDate?: Date | undefined;
    contractDeliveryCondition?: string | undefined;
    termOfContractPayment?: string | undefined;
    transportType?: string | undefined;
    powerOfAttorneyNumber?: string | undefined;
    powerOfAttorneyDate?: Date | undefined;
    products?: SntProductFullDto[] | undefined;
    oilProducts?: SntOilProductDto[] | undefined;
}

export enum SntParticipantType {
    LAWYER = "LAWYER",
    NOTARY = "NOTARY",
    MEDIATOR = "MEDIATOR",
    BAILIFF = "BAILIFF",
    INDIVIDUAL = "INDIVIDUAL",
    RETAIL = "RETAIL",
    RETAILER = "RETAILER",
    PHARMACEUTIC_PRODUCER = "PHARMACEUTIC_PRODUCER",
    LESSEE = "LESSEE",
    LESSOR = "LESSOR",
    PRINCIPAL = "PRINCIPAL",
    COMMITTENT = "COMMITTENT",
    BROKER = "BROKER",
    SHARING_AGREEMENT_PARTICIPANT = "SHARING_AGREEMENT_PARTICIPANT",
    JOINT_ACTIVITY_PARTICIPANT = "JOINT_ACTIVITY_PARTICIPANT",
    SMALL_RETAIL_OUTLET = "SMALL_RETAIL_OUTLET",
}

export abstract class SntProductDtoBase implements ISntProductDtoBase {
    /** Признак происхождения товара (G1 2, G2 2, G3 2, G4 2, G5 2, G6 2, G7 2, G8 2, G9 2, G10 2) */
    truOriginCode!: number;
    /** Наименование товара (G1 3) */
    productName!: string;
    /** Id остатка на складе */
    balanceId?: number | undefined;
    /** Id товара в справочнике ГСВС */
    gsvsId?: number | undefined;
    /** Id единицы измерения */
    measureUnitId?: number | undefined;
    /** Количество (объем) (G1 6) */
    quantity!: number;
    /** Цена за единицу товара (G1 7) */
    price!: number;
    /** Ставка акциза (G1 9/1, G2 9/2, G3 9/1, G4 13/1, G5 12/2, G6 10/1, G7 9/1, G8 12/1, G9 9/1, G10 12/1) */
    exciseRate?: number | undefined;
    /** Сумма НДС (G1 11, G2 11, G3 11, G4 15, G5 14, G6 12, G7 11, G8 14, G9 11, G10 14) */
    ndsAmount?: number | undefined;
    /** Ставка НДС (G1 10, G2 10, G3 10, G4 14, G5 13, G6 11, G7 10, G8 13, G9 10, G10 13) */
    ndsRate?: number | undefined;
    /** Дополнительная информация (G1 17, G2 17, G3 17, G4 21, G5 19, G6 17, G7 16, G8 20, G9 16, G10 19) */
    additionalInfo?: string | undefined;
    /** Идентификатор товара в ИС ЭСФ  (G1 13, G2 13, G3 13, G4 17, G5 15, G6 14, G7 13, G8 16, G9 13, G10 16) */
    productId?: string | undefined;
    /** Стоимость товара без косвенных налогов (G1 8, G2 8, G3 8, G4 12, G5 11, G6 9, G7 8, G8 11, G9 8, G10 11) */
    priceWithoutTax!: number;
    /** Общая стоимость  товара с косвенными налогами (G1 12, G2 12, G3 12, G4 16, G5 15, G6 13, G7 12, G8 15, G9 12, G10 15) */
    priceWithTax!: number;
    /** Вес нетто (G, G1, G10) */
    netWeight?: number | undefined;

    constructor(data?: ISntProductDtoBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.truOriginCode = _data["truOriginCode"];
            this.productName = _data["productName"];
            this.balanceId = _data["balanceId"];
            this.gsvsId = _data["gsvsId"];
            this.measureUnitId = _data["measureUnitId"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.exciseRate = _data["exciseRate"];
            this.ndsAmount = _data["ndsAmount"];
            this.ndsRate = _data["ndsRate"];
            this.additionalInfo = _data["additionalInfo"];
            this.productId = _data["productId"];
            this.priceWithoutTax = _data["priceWithoutTax"];
            this.priceWithTax = _data["priceWithTax"];
            this.netWeight = _data["netWeight"];
        }
    }

    static fromJS(data: any): SntProductDtoBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'SntProductDtoBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["truOriginCode"] = this.truOriginCode;
        data["productName"] = this.productName;
        data["balanceId"] = this.balanceId;
        data["gsvsId"] = this.gsvsId;
        data["measureUnitId"] = this.measureUnitId;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["exciseRate"] = this.exciseRate;
        data["ndsAmount"] = this.ndsAmount;
        data["ndsRate"] = this.ndsRate;
        data["additionalInfo"] = this.additionalInfo;
        data["productId"] = this.productId;
        data["priceWithoutTax"] = this.priceWithoutTax;
        data["priceWithTax"] = this.priceWithTax;
        data["netWeight"] = this.netWeight;
        return data;
    }
}

export interface ISntProductDtoBase {
    /** Признак происхождения товара (G1 2, G2 2, G3 2, G4 2, G5 2, G6 2, G7 2, G8 2, G9 2, G10 2) */
    truOriginCode: number;
    /** Наименование товара (G1 3) */
    productName: string;
    /** Id остатка на складе */
    balanceId?: number | undefined;
    /** Id товара в справочнике ГСВС */
    gsvsId?: number | undefined;
    /** Id единицы измерения */
    measureUnitId?: number | undefined;
    /** Количество (объем) (G1 6) */
    quantity: number;
    /** Цена за единицу товара (G1 7) */
    price: number;
    /** Ставка акциза (G1 9/1, G2 9/2, G3 9/1, G4 13/1, G5 12/2, G6 10/1, G7 9/1, G8 12/1, G9 9/1, G10 12/1) */
    exciseRate?: number | undefined;
    /** Сумма НДС (G1 11, G2 11, G3 11, G4 15, G5 14, G6 12, G7 11, G8 14, G9 11, G10 14) */
    ndsAmount?: number | undefined;
    /** Ставка НДС (G1 10, G2 10, G3 10, G4 14, G5 13, G6 11, G7 10, G8 13, G9 10, G10 13) */
    ndsRate?: number | undefined;
    /** Дополнительная информация (G1 17, G2 17, G3 17, G4 21, G5 19, G6 17, G7 16, G8 20, G9 16, G10 19) */
    additionalInfo?: string | undefined;
    /** Идентификатор товара в ИС ЭСФ  (G1 13, G2 13, G3 13, G4 17, G5 15, G6 14, G7 13, G8 16, G9 13, G10 16) */
    productId?: string | undefined;
    /** Стоимость товара без косвенных налогов (G1 8, G2 8, G3 8, G4 12, G5 11, G6 9, G7 8, G8 11, G9 8, G10 11) */
    priceWithoutTax: number;
    /** Общая стоимость  товара с косвенными налогами (G1 12, G2 12, G3 12, G4 16, G5 15, G6 13, G7 12, G8 15, G9 12, G10 15) */
    priceWithTax: number;
    /** Вес нетто (G, G1, G10) */
    netWeight?: number | undefined;
}

export class SntProductFullDto extends SntProductDtoBase implements ISntProductFullDto {
    /** Код товара (GTIN) (G1 16) */
    gtinCode?: string | undefined;
    /** Код ТНВЭД ЕАЭС */
    tnvedCode?: string | undefined;
    /** Наименование единицы измерения */
    measureUnitName?: string | undefined;

    constructor(data?: ISntProductFullDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.gtinCode = _data["gtinCode"];
            this.tnvedCode = _data["tnvedCode"];
            this.measureUnitName = _data["measureUnitName"];
        }
    }

    static fromJS(data: any): SntProductFullDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntProductFullDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gtinCode"] = this.gtinCode;
        data["tnvedCode"] = this.tnvedCode;
        data["measureUnitName"] = this.measureUnitName;
        super.toJSON(data);
        return data;
    }
}

export interface ISntProductFullDto extends ISntProductDtoBase {
    /** Код товара (GTIN) (G1 16) */
    gtinCode?: string | undefined;
    /** Код ТНВЭД ЕАЭС */
    tnvedCode?: string | undefined;
    /** Наименование единицы измерения */
    measureUnitName?: string | undefined;
}

export class SntOilProductDto extends SntProductDtoBase implements ISntOilProductDto {
    /** Код ТНВЭД ЕАЭС */
    tnvedCode?: string | undefined;
    /** Наименование единицы измерения */
    measureUnitName?: string | undefined;
    /** ПИН-код (G6 3) */
    pinCode?: string | undefined;

    constructor(data?: ISntOilProductDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tnvedCode = _data["tnvedCode"];
            this.measureUnitName = _data["measureUnitName"];
            this.pinCode = _data["pinCode"];
        }
    }

    static fromJS(data: any): SntOilProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntOilProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tnvedCode"] = this.tnvedCode;
        data["measureUnitName"] = this.measureUnitName;
        data["pinCode"] = this.pinCode;
        super.toJSON(data);
        return data;
    }
}

export interface ISntOilProductDto extends ISntProductDtoBase {
    /** Код ТНВЭД ЕАЭС */
    tnvedCode?: string | undefined;
    /** Наименование единицы измерения */
    measureUnitName?: string | undefined;
    /** ПИН-код (G6 3) */
    pinCode?: string | undefined;
}

export enum InvoiceDirection {
    INBOUND = "INBOUND",
    OUTBOUND = "OUTBOUND",
}

export class ResponsibleAccountantDto implements IResponsibleAccountantDto {
    id!: number;
    accountNumber?: string | undefined;
    accountantObjectId!: string;
    accountantFullname?: string | undefined;
    supervisorObjectId!: string;
    supervisorFullname?: string | undefined;

    constructor(data?: IResponsibleAccountantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accountNumber = _data["accountNumber"];
            this.accountantObjectId = _data["accountantObjectId"];
            this.accountantFullname = _data["accountantFullname"];
            this.supervisorObjectId = _data["supervisorObjectId"];
            this.supervisorFullname = _data["supervisorFullname"];
        }
    }

    static fromJS(data: any): ResponsibleAccountantDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponsibleAccountantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountNumber"] = this.accountNumber;
        data["accountantObjectId"] = this.accountantObjectId;
        data["accountantFullname"] = this.accountantFullname;
        data["supervisorObjectId"] = this.supervisorObjectId;
        data["supervisorFullname"] = this.supervisorFullname;
        return data;
    }
}

export interface IResponsibleAccountantDto {
    id: number;
    accountNumber?: string | undefined;
    accountantObjectId: string;
    accountantFullname?: string | undefined;
    supervisorObjectId: string;
    supervisorFullname?: string | undefined;
}

export class MsGraphUser implements IMsGraphUser {
    id!: string;
    email?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;

    constructor(data?: IMsGraphUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.name = _data["name"];
            this.surname = _data["surname"];
        }
    }

    static fromJS(data: any): MsGraphUser {
        data = typeof data === 'object' ? data : {};
        let result = new MsGraphUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["name"] = this.name;
        data["surname"] = this.surname;
        return data;
    }
}

export interface IMsGraphUser {
    id: string;
    email?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
}

export class BalancesListResponseDto implements IBalancesListResponseDto {
    paging?: PagingModel | undefined;
    balances?: BalanceSimpleDto[] | undefined;

    constructor(data?: IBalancesListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paging = _data["paging"] ? PagingModel.fromJS(_data["paging"]) : <any>undefined;
            if (Array.isArray(_data["balances"])) {
                this.balances = [] as any;
                for (let item of _data["balances"])
                    this.balances!.push(BalanceSimpleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BalancesListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new BalancesListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paging"] = this.paging ? this.paging.toJSON() : <any>undefined;
        if (Array.isArray(this.balances)) {
            data["balances"] = [];
            for (let item of this.balances)
                data["balances"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBalancesListResponseDto {
    paging?: PagingModel | undefined;
    balances?: BalanceSimpleDto[] | undefined;
}

export class BalanceSimpleDto implements IBalanceSimpleDto {
    id!: number;
    /** Имя склада */
    taxpayerStoreName!: string;
    /** Код проекта */
    projectCode?: number | undefined;
    /** Наименование ТРУ из учетной Системы НП */
    name!: string;
    /** Код КПВЭД */
    kpvedCode!: string;
    /** Код ТНВЭД ЕАЭС */
    tnvedCode!: string;
    /** Код GTIN */
    gtinCode?: string | undefined;
    /** Сквозной идентификатор товара в пределах НП */
    productId!: number;
    /** Id единицы измерения */
    measureUnitId!: number;
    /** Код единицы измерения */
    measureUnitName!: string;
    /** Цена за единицу */
    unitPrice!: number;
    /** № документа производства/импорта (ДТ, ФНО 328.00, CT-KZ, CT-1) */
    manufactureOrImportDocNumber?: string | undefined;
    /** Номер товарной позиции из документа импорта (ДТ или ФНО 328.00) */
    productNumberInImportDoc?: string | undefined;
    /** Наименование товаров в соответствии с документом импорта (ДТ или ФНО 328.00) */
    productNameInImportDoc?: string | undefined;
    /** Физическая метка */
    physicalLabel?: string | undefined;
    /** Пин-код */
    pinCode?: string | undefined;
    /** Крепость (% содержания спирта) */
    spiritPercent?: number | undefined;
    /** Признак экспортируемости товара: возможен экспорт */
    canExport!: boolean;
    /** Количество */
    quantity!: number;
    /** Количество товаров в резерве */
    reserveQuantity?: number | undefined;
    /** Код страны */
    countryCode?: string | undefined;
    /** Тип обязанности */
    dutyType?: BalanceDutyType | undefined;
    /** Код происхождения */
    originCode?: string | undefined;

    constructor(data?: IBalanceSimpleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.taxpayerStoreName = _data["taxpayerStoreName"];
            this.projectCode = _data["projectCode"];
            this.name = _data["name"];
            this.kpvedCode = _data["kpvedCode"];
            this.tnvedCode = _data["tnvedCode"];
            this.gtinCode = _data["gtinCode"];
            this.productId = _data["productId"];
            this.measureUnitId = _data["measureUnitId"];
            this.measureUnitName = _data["measureUnitName"];
            this.unitPrice = _data["unitPrice"];
            this.manufactureOrImportDocNumber = _data["manufactureOrImportDocNumber"];
            this.productNumberInImportDoc = _data["productNumberInImportDoc"];
            this.productNameInImportDoc = _data["productNameInImportDoc"];
            this.physicalLabel = _data["physicalLabel"];
            this.pinCode = _data["pinCode"];
            this.spiritPercent = _data["spiritPercent"];
            this.canExport = _data["canExport"];
            this.quantity = _data["quantity"];
            this.reserveQuantity = _data["reserveQuantity"];
            this.countryCode = _data["countryCode"];
            this.dutyType = _data["dutyType"];
            this.originCode = _data["originCode"];
        }
    }

    static fromJS(data: any): BalanceSimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceSimpleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["taxpayerStoreName"] = this.taxpayerStoreName;
        data["projectCode"] = this.projectCode;
        data["name"] = this.name;
        data["kpvedCode"] = this.kpvedCode;
        data["tnvedCode"] = this.tnvedCode;
        data["gtinCode"] = this.gtinCode;
        data["productId"] = this.productId;
        data["measureUnitId"] = this.measureUnitId;
        data["measureUnitName"] = this.measureUnitName;
        data["unitPrice"] = this.unitPrice;
        data["manufactureOrImportDocNumber"] = this.manufactureOrImportDocNumber;
        data["productNumberInImportDoc"] = this.productNumberInImportDoc;
        data["productNameInImportDoc"] = this.productNameInImportDoc;
        data["physicalLabel"] = this.physicalLabel;
        data["pinCode"] = this.pinCode;
        data["spiritPercent"] = this.spiritPercent;
        data["canExport"] = this.canExport;
        data["quantity"] = this.quantity;
        data["reserveQuantity"] = this.reserveQuantity;
        data["countryCode"] = this.countryCode;
        data["dutyType"] = this.dutyType;
        data["originCode"] = this.originCode;
        return data;
    }
}

export interface IBalanceSimpleDto {
    id: number;
    /** Имя склада */
    taxpayerStoreName: string;
    /** Код проекта */
    projectCode?: number | undefined;
    /** Наименование ТРУ из учетной Системы НП */
    name: string;
    /** Код КПВЭД */
    kpvedCode: string;
    /** Код ТНВЭД ЕАЭС */
    tnvedCode: string;
    /** Код GTIN */
    gtinCode?: string | undefined;
    /** Сквозной идентификатор товара в пределах НП */
    productId: number;
    /** Id единицы измерения */
    measureUnitId: number;
    /** Код единицы измерения */
    measureUnitName: string;
    /** Цена за единицу */
    unitPrice: number;
    /** № документа производства/импорта (ДТ, ФНО 328.00, CT-KZ, CT-1) */
    manufactureOrImportDocNumber?: string | undefined;
    /** Номер товарной позиции из документа импорта (ДТ или ФНО 328.00) */
    productNumberInImportDoc?: string | undefined;
    /** Наименование товаров в соответствии с документом импорта (ДТ или ФНО 328.00) */
    productNameInImportDoc?: string | undefined;
    /** Физическая метка */
    physicalLabel?: string | undefined;
    /** Пин-код */
    pinCode?: string | undefined;
    /** Крепость (% содержания спирта) */
    spiritPercent?: number | undefined;
    /** Признак экспортируемости товара: возможен экспорт */
    canExport: boolean;
    /** Количество */
    quantity: number;
    /** Количество товаров в резерве */
    reserveQuantity?: number | undefined;
    /** Код страны */
    countryCode?: string | undefined;
    /** Тип обязанности */
    dutyType?: BalanceDutyType | undefined;
    /** Код происхождения */
    originCode?: string | undefined;
}

export enum BalanceDutyType {
    CCT = "CCT",
    WTO = "WTO",
    EAEU = "EAEU",
    NOT_INSTALLED = "NOT_INSTALLED",
}

export class ImportBalancesRegularResultDto implements IImportBalancesRegularResultDto {
    added!: number;
    updatedAndDeactivated!: number;
    notChanged!: number;

    constructor(data?: IImportBalancesRegularResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.added = _data["added"];
            this.updatedAndDeactivated = _data["updatedAndDeactivated"];
            this.notChanged = _data["notChanged"];
        }
    }

    static fromJS(data: any): ImportBalancesRegularResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportBalancesRegularResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["added"] = this.added;
        data["updatedAndDeactivated"] = this.updatedAndDeactivated;
        data["notChanged"] = this.notChanged;
        return data;
    }
}

export interface IImportBalancesRegularResultDto {
    added: number;
    updatedAndDeactivated: number;
    notChanged: number;
}

/** This fix should be removed after single run on production */
export class FixBalancesImportKeyResultDto implements IFixBalancesImportKeyResultDto {
    saved!: number;
    added!: number;

    constructor(data?: IFixBalancesImportKeyResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.saved = _data["saved"];
            this.added = _data["added"];
        }
    }

    static fromJS(data: any): FixBalancesImportKeyResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FixBalancesImportKeyResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["saved"] = this.saved;
        data["added"] = this.added;
        return data;
    }
}

/** This fix should be removed after single run on production */
export interface IFixBalancesImportKeyResultDto {
    saved: number;
    added: number;
}

export class ValidateBalanceDto implements IValidateBalanceDto {
    lastBlock!: boolean;
    currPage!: number;
    rsCount!: number;
    rows?: BalanceDto[] | undefined;

    constructor(data?: IValidateBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lastBlock = _data["lastBlock"];
            this.currPage = _data["currPage"];
            this.rsCount = _data["rsCount"];
            if (Array.isArray(_data["rows"])) {
                this.rows = [] as any;
                for (let item of _data["rows"])
                    this.rows!.push(BalanceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidateBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastBlock"] = this.lastBlock;
        data["currPage"] = this.currPage;
        data["rsCount"] = this.rsCount;
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        return data;
    }
}

export interface IValidateBalanceDto {
    lastBlock: boolean;
    currPage: number;
    rsCount: number;
    rows?: BalanceDto[] | undefined;
}

export class BalanceDto implements IBalanceDto {
    /** Compare */
    tin!: string;
    /** Compare */
    storeId!: number;
    /** Ignore, additional UI field */
    storeName!: string;
    /** Ignore, because not the key */
    projectCode?: number | undefined;
    /** Compare */
    name!: string;
    /** Ignore, not exists in internal model */
    originType?: string | undefined;
    /** Compare */
    kpvedCode!: string;
    /** Compare */
    tnvedCode!: string;
    /** Compare */
    gtinCode?: string | undefined;
    /** Compare */
    productId!: number;
    /** Ignore, not exists in internal model */
    receiptDocNumber?: string | undefined;
    /** Ignore, not exists in internal model */
    productNumberInReceiptDoc?: string | undefined;
    /** Ignore, not exists in internal model */
    dutyTypeCode?: string | undefined;
    /** Ignore, not exists in internal model */
    manufactureOrImportCountry?: string | undefined;
    /** Ignore, not exists in internal model */
    countryName?: string | undefined;
    /** Ignore, additional UI field */
    measureUnitId!: number;
    /** Compare */
    measureUnitCode!: string;
    /** Ignore, additional UI field */
    measureUnitName!: string;
    /** Compare */
    unitPrice!: number;
    /** Compare */
    manufactureOrImportDocNumber?: string | undefined;
    /** Compare */
    productNumberInImportDoc?: string | undefined;
    /** Compare */
    productNameInImportDoc?: string | undefined;
    /** Compare */
    physicalLabel?: string | undefined;
    /** Compare */
    pinCode?: string | undefined;
    /** Compare */
    spiritPercent?: number | undefined;
    /** Ignore, because not the key */
    canExport?: boolean | undefined;
    /** Compare */
    quantity!: number;
    /** Compare */
    reserveQuantity!: number;
    /** Ignore, not exists in internal model */
    confiscated!: boolean;
    /** Ignore, not exists in internal model */
    isUnique!: boolean;
    /** Ignore, not exists in internal model */
    isEverUsedInVstore!: boolean;
    /** Ignore, not exists in internal model */
    originTypeCode!: number;
    /** Ignore, additional UI field */
    gsvsCode!: string;
    /** Ignore, additional UI field */
    availableQuantity!: number;
    countryCode?: string | undefined;
    dutyType?: BalanceDutyType | undefined;

    constructor(data?: IBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tin = _data["tin"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.projectCode = _data["projectCode"];
            this.name = _data["name"];
            this.originType = _data["originType"];
            this.kpvedCode = _data["kpvedCode"];
            this.tnvedCode = _data["tnvedCode"];
            this.gtinCode = _data["gtinCode"];
            this.productId = _data["productId"];
            this.receiptDocNumber = _data["receiptDocNumber"];
            this.productNumberInReceiptDoc = _data["productNumberInReceiptDoc"];
            this.dutyTypeCode = _data["dutyTypeCode"];
            this.manufactureOrImportCountry = _data["manufactureOrImportCountry"];
            this.countryName = _data["countryName"];
            this.measureUnitId = _data["measureUnitId"];
            this.measureUnitCode = _data["measureUnitCode"];
            this.measureUnitName = _data["measureUnitName"];
            this.unitPrice = _data["unitPrice"];
            this.manufactureOrImportDocNumber = _data["manufactureOrImportDocNumber"];
            this.productNumberInImportDoc = _data["productNumberInImportDoc"];
            this.productNameInImportDoc = _data["productNameInImportDoc"];
            this.physicalLabel = _data["physicalLabel"];
            this.pinCode = _data["pinCode"];
            this.spiritPercent = _data["spiritPercent"];
            this.canExport = _data["canExport"];
            this.quantity = _data["quantity"];
            this.reserveQuantity = _data["reserveQuantity"];
            this.confiscated = _data["confiscated"];
            this.isUnique = _data["isUnique"];
            this.isEverUsedInVstore = _data["isEverUsedInVstore"];
            this.originTypeCode = _data["originTypeCode"];
            this.gsvsCode = _data["gsvsCode"];
            this.availableQuantity = _data["availableQuantity"];
            this.countryCode = _data["countryCode"];
            this.dutyType = _data["dutyType"];
        }
    }

    static fromJS(data: any): BalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tin"] = this.tin;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["projectCode"] = this.projectCode;
        data["name"] = this.name;
        data["originType"] = this.originType;
        data["kpvedCode"] = this.kpvedCode;
        data["tnvedCode"] = this.tnvedCode;
        data["gtinCode"] = this.gtinCode;
        data["productId"] = this.productId;
        data["receiptDocNumber"] = this.receiptDocNumber;
        data["productNumberInReceiptDoc"] = this.productNumberInReceiptDoc;
        data["dutyTypeCode"] = this.dutyTypeCode;
        data["manufactureOrImportCountry"] = this.manufactureOrImportCountry;
        data["countryName"] = this.countryName;
        data["measureUnitId"] = this.measureUnitId;
        data["measureUnitCode"] = this.measureUnitCode;
        data["measureUnitName"] = this.measureUnitName;
        data["unitPrice"] = this.unitPrice;
        data["manufactureOrImportDocNumber"] = this.manufactureOrImportDocNumber;
        data["productNumberInImportDoc"] = this.productNumberInImportDoc;
        data["productNameInImportDoc"] = this.productNameInImportDoc;
        data["physicalLabel"] = this.physicalLabel;
        data["pinCode"] = this.pinCode;
        data["spiritPercent"] = this.spiritPercent;
        data["canExport"] = this.canExport;
        data["quantity"] = this.quantity;
        data["reserveQuantity"] = this.reserveQuantity;
        data["confiscated"] = this.confiscated;
        data["isUnique"] = this.isUnique;
        data["isEverUsedInVstore"] = this.isEverUsedInVstore;
        data["originTypeCode"] = this.originTypeCode;
        data["gsvsCode"] = this.gsvsCode;
        data["availableQuantity"] = this.availableQuantity;
        data["countryCode"] = this.countryCode;
        data["dutyType"] = this.dutyType;
        return data;
    }
}

export interface IBalanceDto {
    /** Compare */
    tin: string;
    /** Compare */
    storeId: number;
    /** Ignore, additional UI field */
    storeName: string;
    /** Ignore, because not the key */
    projectCode?: number | undefined;
    /** Compare */
    name: string;
    /** Ignore, not exists in internal model */
    originType?: string | undefined;
    /** Compare */
    kpvedCode: string;
    /** Compare */
    tnvedCode: string;
    /** Compare */
    gtinCode?: string | undefined;
    /** Compare */
    productId: number;
    /** Ignore, not exists in internal model */
    receiptDocNumber?: string | undefined;
    /** Ignore, not exists in internal model */
    productNumberInReceiptDoc?: string | undefined;
    /** Ignore, not exists in internal model */
    dutyTypeCode?: string | undefined;
    /** Ignore, not exists in internal model */
    manufactureOrImportCountry?: string | undefined;
    /** Ignore, not exists in internal model */
    countryName?: string | undefined;
    /** Ignore, additional UI field */
    measureUnitId: number;
    /** Compare */
    measureUnitCode: string;
    /** Ignore, additional UI field */
    measureUnitName: string;
    /** Compare */
    unitPrice: number;
    /** Compare */
    manufactureOrImportDocNumber?: string | undefined;
    /** Compare */
    productNumberInImportDoc?: string | undefined;
    /** Compare */
    productNameInImportDoc?: string | undefined;
    /** Compare */
    physicalLabel?: string | undefined;
    /** Compare */
    pinCode?: string | undefined;
    /** Compare */
    spiritPercent?: number | undefined;
    /** Ignore, because not the key */
    canExport?: boolean | undefined;
    /** Compare */
    quantity: number;
    /** Compare */
    reserveQuantity: number;
    /** Ignore, not exists in internal model */
    confiscated: boolean;
    /** Ignore, not exists in internal model */
    isUnique: boolean;
    /** Ignore, not exists in internal model */
    isEverUsedInVstore: boolean;
    /** Ignore, not exists in internal model */
    originTypeCode: number;
    /** Ignore, additional UI field */
    gsvsCode: string;
    /** Ignore, additional UI field */
    availableQuantity: number;
    countryCode?: string | undefined;
    dutyType?: BalanceDutyType | undefined;
}

/** ГСВС */
export class FavoriteProductDto implements IFavoriteProductDto {
    /** Id */
    id!: number;
    /** Код КПВЭД/ТНВЭД/ГТИН */
    code!: string;
    /** Тип ГСВС */
    gsvsTypeCode!: GsvsType;
    /** Наименование ГСВС (КПВЭД/ТНВЭД/GTIN в зависимости от типа) на русском языке */
    name!: string;
    /** Составной код ГСВС  */
    compositeCode!: string;

    constructor(data?: IFavoriteProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.gsvsTypeCode = _data["gsvsTypeCode"];
            this.name = _data["name"];
            this.compositeCode = _data["compositeCode"];
        }
    }

    static fromJS(data: any): FavoriteProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new FavoriteProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["gsvsTypeCode"] = this.gsvsTypeCode;
        data["name"] = this.name;
        data["compositeCode"] = this.compositeCode;
        return data;
    }
}

/** ГСВС */
export interface IFavoriteProductDto {
    /** Id */
    id: number;
    /** Код КПВЭД/ТНВЭД/ГТИН */
    code: string;
    /** Тип ГСВС */
    gsvsTypeCode: GsvsType;
    /** Наименование ГСВС (КПВЭД/ТНВЭД/GTIN в зависимости от типа) на русском языке */
    name: string;
    /** Составной код ГСВС  */
    compositeCode: string;
}

export enum GsvsType {
    KPVED = "KPVED",
    TNVED = "TNVED",
    GTIN = "GTIN",
}

export class ImportErrorCodesResultDto implements IImportErrorCodesResultDto {
    total!: number;
    added!: number;
    removed!: number;

    constructor(data?: IImportErrorCodesResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            this.added = _data["added"];
            this.removed = _data["removed"];
        }
    }

    static fromJS(data: any): ImportErrorCodesResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportErrorCodesResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        data["added"] = this.added;
        data["removed"] = this.removed;
        return data;
    }
}

export interface IImportErrorCodesResultDto {
    total: number;
    added: number;
    removed: number;
}

/** ГСВС */
export class ProductDto implements IProductDto {
    /** Id */
    id!: number;
    /** Код КПВЭД/ТНВЭД/ГТИН */
    code!: string;
    /** Тип ГСВС */
    gsvsTypeCode!: GsvsType;
    /** Наименование ГСВС (КПВЭД/ТНВЭД/GTIN в зависимости от типа) на русском языке */
    name!: string;
    /** Id для построения дерева */
    fixedId!: number;
    /** Признак использования в ВС */
    isUseInVstore?: boolean | undefined;
    /** Признак уникальности товара */
    isUnique!: boolean;
    /** Признак товара изъятия */
    isWithdrawal?: boolean | undefined;
    /** Социально значимый продукт */
    isSociallySignificant!: boolean;
    /** Признак товара двойного назначения */
    isTwofoldPurpose!: boolean;
    /** Признак подакцизного товара */
    isExcisable!: boolean;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.gsvsTypeCode = _data["gsvsTypeCode"];
            this.name = _data["name"];
            this.fixedId = _data["fixedId"];
            this.isUseInVstore = _data["isUseInVstore"];
            this.isUnique = _data["isUnique"];
            this.isWithdrawal = _data["isWithdrawal"];
            this.isSociallySignificant = _data["isSociallySignificant"];
            this.isTwofoldPurpose = _data["isTwofoldPurpose"];
            this.isExcisable = _data["isExcisable"];
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["gsvsTypeCode"] = this.gsvsTypeCode;
        data["name"] = this.name;
        data["fixedId"] = this.fixedId;
        data["isUseInVstore"] = this.isUseInVstore;
        data["isUnique"] = this.isUnique;
        data["isWithdrawal"] = this.isWithdrawal;
        data["isSociallySignificant"] = this.isSociallySignificant;
        data["isTwofoldPurpose"] = this.isTwofoldPurpose;
        data["isExcisable"] = this.isExcisable;
        return data;
    }
}

/** ГСВС */
export interface IProductDto {
    /** Id */
    id: number;
    /** Код КПВЭД/ТНВЭД/ГТИН */
    code: string;
    /** Тип ГСВС */
    gsvsTypeCode: GsvsType;
    /** Наименование ГСВС (КПВЭД/ТНВЭД/GTIN в зависимости от типа) на русском языке */
    name: string;
    /** Id для построения дерева */
    fixedId: number;
    /** Признак использования в ВС */
    isUseInVstore?: boolean | undefined;
    /** Признак уникальности товара */
    isUnique: boolean;
    /** Признак товара изъятия */
    isWithdrawal?: boolean | undefined;
    /** Социально значимый продукт */
    isSociallySignificant: boolean;
    /** Признак товара двойного назначения */
    isTwofoldPurpose: boolean;
    /** Признак подакцизного товара */
    isExcisable: boolean;
}

/** СНТ */
export abstract class SntBaseDto implements ISntBaseDto {
    /** Идентификатор существующей СНТ или null для новой СНТ */
    id?: number | undefined;
    /** Регистрационный номер СНТ учетной системы (A 1) */
    number!: string;
    /** Регистрационный номер связанной СНТ */
    relatedRegistrationNumber?: string | undefined;
    /** Дата оформления СНТ на бумажном носителе (A 2.1) */
    datePaper?: Date | undefined;
    /** Причина выписки на бумажном носителе (A 2.1.1) */
    reasonPaper?: SntPaperReasonType | undefined;
    /** Дата отгрузки товара (A 3) */
    shippingDate?: Date | undefined;
    /** Регистрационный номер Акта/Уведомления по цифровой маркировке (A 4.2) */
    digitalMarkingNotificationNumber?: string | undefined;
    /** Дата Акта/Уведомления по цифровой маркировке (A 4.2.1) */
    digitalMarkingNotificationDate?: Date | undefined;
    /** Ввоз товаров на территорию РК (A 7) */
    importType?: SntImportType | undefined;
    /** Импорт: Код (идентификатор) территории СЭЗ (A 7.5.1) */
    externalImportSezCode?: number | undefined;
    /** Вывоз товаров с территории РК (A 8) */
    exportType?: SntExportType | undefined;
    /** Экспорт: Код (идентификатор) территории СЭЗ (A 8.5.1) */
    externalExportSezCode?: number | undefined;
    /** Перемещение товара (A 9) */
    transferType?: SntTransferType | undefined;
    /** Реквизиты поставщика (B) */
    seller!: SntSellerDto;
    /** Реквизиты получателя (C) */
    customer!: SntCustomerDto;
    /** Грузополучатель (D) */
    consignee!: SntConsignmentParticipantDto;
    /** Грузоотправитель (D) */
    consignor!: SntConsignmentParticipantDto;
    /** Сведения по перевозке (E) */
    shippingInfo?: SntShippingInfoDto | undefined;
    /** Договор (контракт) на поставку товара (F) */
    contract!: SntContractDto;
    /** Данные о грузе, перевозимом на автомобильном транспорте (K) */
    carCargoInfo?: SntCarCargoInfoDto | undefined;
    /** Код валюты (50) */
    currencyCode!: string;
    /** Курс валюты (51) */
    currencyRate?: number | undefined;
    /** Комментарий */
    comment?: string | undefined;
    /** Доп. данные по нефтепродуктам */
    oilSet?: SntOilSetDto | undefined;
    releaseGoodsInfo?: SntReleaseGoodsInfoDto | undefined;

    constructor(data?: ISntBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.seller = new SntSellerDto();
            this.customer = new SntCustomerDto();
            this.consignee = new SntConsignmentParticipantDto();
            this.consignor = new SntConsignmentParticipantDto();
            this.contract = new SntContractDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.number = _data["number"];
            this.relatedRegistrationNumber = _data["relatedRegistrationNumber"];
            this.datePaper = _data["datePaper"] ? new Date(_data["datePaper"].toString()) : <any>undefined;
            this.reasonPaper = _data["reasonPaper"];
            this.shippingDate = _data["shippingDate"] ? new Date(_data["shippingDate"].toString()) : <any>undefined;
            this.digitalMarkingNotificationNumber = _data["digitalMarkingNotificationNumber"];
            this.digitalMarkingNotificationDate = _data["digitalMarkingNotificationDate"] ? new Date(_data["digitalMarkingNotificationDate"].toString()) : <any>undefined;
            this.importType = _data["importType"];
            this.externalImportSezCode = _data["externalImportSezCode"];
            this.exportType = _data["exportType"];
            this.externalExportSezCode = _data["externalExportSezCode"];
            this.transferType = _data["transferType"];
            this.seller = _data["seller"] ? SntSellerDto.fromJS(_data["seller"]) : new SntSellerDto();
            this.customer = _data["customer"] ? SntCustomerDto.fromJS(_data["customer"]) : new SntCustomerDto();
            this.consignee = _data["consignee"] ? SntConsignmentParticipantDto.fromJS(_data["consignee"]) : new SntConsignmentParticipantDto();
            this.consignor = _data["consignor"] ? SntConsignmentParticipantDto.fromJS(_data["consignor"]) : new SntConsignmentParticipantDto();
            this.shippingInfo = _data["shippingInfo"] ? SntShippingInfoDto.fromJS(_data["shippingInfo"]) : <any>undefined;
            this.contract = _data["contract"] ? SntContractDto.fromJS(_data["contract"]) : new SntContractDto();
            this.carCargoInfo = _data["carCargoInfo"] ? SntCarCargoInfoDto.fromJS(_data["carCargoInfo"]) : <any>undefined;
            this.currencyCode = _data["currencyCode"];
            this.currencyRate = _data["currencyRate"];
            this.comment = _data["comment"];
            this.oilSet = _data["oilSet"] ? SntOilSetDto.fromJS(_data["oilSet"]) : <any>undefined;
            this.releaseGoodsInfo = _data["releaseGoodsInfo"] ? SntReleaseGoodsInfoDto.fromJS(_data["releaseGoodsInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SntBaseDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'SntBaseDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["relatedRegistrationNumber"] = this.relatedRegistrationNumber;
        data["datePaper"] = this.datePaper ? this.datePaper.toYearMonthDateString() : <any>undefined;
        data["reasonPaper"] = this.reasonPaper;
        data["shippingDate"] = this.shippingDate ? this.shippingDate.toYearMonthDateString() : <any>undefined;
        data["digitalMarkingNotificationNumber"] = this.digitalMarkingNotificationNumber;
        data["digitalMarkingNotificationDate"] = this.digitalMarkingNotificationDate ? this.digitalMarkingNotificationDate.toYearMonthDateString() : <any>undefined;
        data["importType"] = this.importType;
        data["externalImportSezCode"] = this.externalImportSezCode;
        data["exportType"] = this.exportType;
        data["externalExportSezCode"] = this.externalExportSezCode;
        data["transferType"] = this.transferType;
        data["seller"] = this.seller ? this.seller.toJSON() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["consignee"] = this.consignee ? this.consignee.toJSON() : <any>undefined;
        data["consignor"] = this.consignor ? this.consignor.toJSON() : <any>undefined;
        data["shippingInfo"] = this.shippingInfo ? this.shippingInfo.toJSON() : <any>undefined;
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        data["carCargoInfo"] = this.carCargoInfo ? this.carCargoInfo.toJSON() : <any>undefined;
        data["currencyCode"] = this.currencyCode;
        data["currencyRate"] = this.currencyRate;
        data["comment"] = this.comment;
        data["oilSet"] = this.oilSet ? this.oilSet.toJSON() : <any>undefined;
        data["releaseGoodsInfo"] = this.releaseGoodsInfo ? this.releaseGoodsInfo.toJSON() : <any>undefined;
        return data;
    }
}

/** СНТ */
export interface ISntBaseDto {
    /** Идентификатор существующей СНТ или null для новой СНТ */
    id?: number | undefined;
    /** Регистрационный номер СНТ учетной системы (A 1) */
    number: string;
    /** Регистрационный номер связанной СНТ */
    relatedRegistrationNumber?: string | undefined;
    /** Дата оформления СНТ на бумажном носителе (A 2.1) */
    datePaper?: Date | undefined;
    /** Причина выписки на бумажном носителе (A 2.1.1) */
    reasonPaper?: SntPaperReasonType | undefined;
    /** Дата отгрузки товара (A 3) */
    shippingDate?: Date | undefined;
    /** Регистрационный номер Акта/Уведомления по цифровой маркировке (A 4.2) */
    digitalMarkingNotificationNumber?: string | undefined;
    /** Дата Акта/Уведомления по цифровой маркировке (A 4.2.1) */
    digitalMarkingNotificationDate?: Date | undefined;
    /** Ввоз товаров на территорию РК (A 7) */
    importType?: SntImportType | undefined;
    /** Импорт: Код (идентификатор) территории СЭЗ (A 7.5.1) */
    externalImportSezCode?: number | undefined;
    /** Вывоз товаров с территории РК (A 8) */
    exportType?: SntExportType | undefined;
    /** Экспорт: Код (идентификатор) территории СЭЗ (A 8.5.1) */
    externalExportSezCode?: number | undefined;
    /** Перемещение товара (A 9) */
    transferType?: SntTransferType | undefined;
    /** Реквизиты поставщика (B) */
    seller: SntSellerDto;
    /** Реквизиты получателя (C) */
    customer: SntCustomerDto;
    /** Грузополучатель (D) */
    consignee: SntConsignmentParticipantDto;
    /** Грузоотправитель (D) */
    consignor: SntConsignmentParticipantDto;
    /** Сведения по перевозке (E) */
    shippingInfo?: SntShippingInfoDto | undefined;
    /** Договор (контракт) на поставку товара (F) */
    contract: SntContractDto;
    /** Данные о грузе, перевозимом на автомобильном транспорте (K) */
    carCargoInfo?: SntCarCargoInfoDto | undefined;
    /** Код валюты (50) */
    currencyCode: string;
    /** Курс валюты (51) */
    currencyRate?: number | undefined;
    /** Комментарий */
    comment?: string | undefined;
    /** Доп. данные по нефтепродуктам */
    oilSet?: SntOilSetDto | undefined;
    releaseGoodsInfo?: SntReleaseGoodsInfoDto | undefined;
}

export class SntFullDto extends SntBaseDto implements ISntFullDto {
    /** Регистрационный номер СНТ */
    registrationNumber?: string | undefined;
    /** Дата оформления / регистрации СНТ */
    date?: Date | undefined;
    /** Товары */
    products?: SntProductFullDto[] | undefined;
    /** Нефтепродукты */
    oilProducts?: SntOilProductDto[] | undefined;
    exportControlProducts?: SntExportControlProductlDto[] | undefined;

    constructor(data?: ISntFullDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.registrationNumber = _data["registrationNumber"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(SntProductFullDto.fromJS(item));
            }
            if (Array.isArray(_data["oilProducts"])) {
                this.oilProducts = [] as any;
                for (let item of _data["oilProducts"])
                    this.oilProducts!.push(SntOilProductDto.fromJS(item));
            }
            if (Array.isArray(_data["exportControlProducts"])) {
                this.exportControlProducts = [] as any;
                for (let item of _data["exportControlProducts"])
                    this.exportControlProducts!.push(SntExportControlProductlDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SntFullDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntFullDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registrationNumber"] = this.registrationNumber;
        data["date"] = this.date ? this.date.toYearMonthDateString() : <any>undefined;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        if (Array.isArray(this.oilProducts)) {
            data["oilProducts"] = [];
            for (let item of this.oilProducts)
                data["oilProducts"].push(item.toJSON());
        }
        if (Array.isArray(this.exportControlProducts)) {
            data["exportControlProducts"] = [];
            for (let item of this.exportControlProducts)
                data["exportControlProducts"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISntFullDto extends ISntBaseDto {
    /** Регистрационный номер СНТ */
    registrationNumber?: string | undefined;
    /** Дата оформления / регистрации СНТ */
    date?: Date | undefined;
    /** Товары */
    products?: SntProductFullDto[] | undefined;
    /** Нефтепродукты */
    oilProducts?: SntOilProductDto[] | undefined;
    exportControlProducts?: SntExportControlProductlDto[] | undefined;
}

export class SntExportControlProductlDto extends SntProductDtoBase implements ISntExportControlProductlDto {
    /** Код ТНВЭД ЕАЭС */
    tnvedCode?: string | undefined;
    /** Наименование единицы измерения */
    measureUnitName?: string | undefined;
    /** ПИН-код (G6 3) */
    pinCode?: string | undefined;

    constructor(data?: ISntExportControlProductlDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tnvedCode = _data["tnvedCode"];
            this.measureUnitName = _data["measureUnitName"];
            this.pinCode = _data["pinCode"];
        }
    }

    static fromJS(data: any): SntExportControlProductlDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntExportControlProductlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tnvedCode"] = this.tnvedCode;
        data["measureUnitName"] = this.measureUnitName;
        data["pinCode"] = this.pinCode;
        super.toJSON(data);
        return data;
    }
}

export interface ISntExportControlProductlDto extends ISntProductDtoBase {
    /** Код ТНВЭД ЕАЭС */
    tnvedCode?: string | undefined;
    /** Наименование единицы измерения */
    measureUnitName?: string | undefined;
    /** ПИН-код (G6 3) */
    pinCode?: string | undefined;
}

export enum SntPaperReasonType {
    DOWN_TIME = "DOWN_TIME",
    UNLAWFUL_REMOVAL_REGISTRATION = "UNLAWFUL_REMOVAL_REGISTRATION",
    MISSING_REQUIREMENT = "MISSING_REQUIREMENT",
}

export class SntParticipantDto implements ISntParticipantDto {
    /** ИИН/БИН поставщика/получателя (B 13, C 22) */
    tin?: string | undefined;
    /** Нерезидент (B 13.1, C 22.1) */
    nonResident!: boolean;
    /** Наименование поставщика/получателя (B 14, C 23) */
    name!: string;
    /** БИН структурного подразделения поставщика/получателя (B 15, C 24) */
    branchTin?: string | undefined;
    /** БИН реорганизованного лица (B 16, C 25) */
    reorganizedTin?: string | undefined;
    /** Код страны регистрации получателя (B 18, C 27) */
    registerCountryCode!: string;
    /** Код страны доставки/поставки (B 19, C 28) */
    countryCode!: string;
    /** Фактический адрес доставки/поставки (B 20, C 29) */
    actualAddress?: string | undefined;
    /** Идентификатор склада доставки/поставки (B 21, C 30) в ИС ЭСФ */
    taxpayerStoreId?: number | undefined;
    /** Категория поставщика (B 17) / Категория получателя (C 26)  */
    statuses?: SntParticipantType[] | undefined;

    constructor(data?: ISntParticipantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tin = _data["tin"];
            this.nonResident = _data["nonResident"];
            this.name = _data["name"];
            this.branchTin = _data["branchTin"];
            this.reorganizedTin = _data["reorganizedTin"];
            this.registerCountryCode = _data["registerCountryCode"];
            this.countryCode = _data["countryCode"];
            this.actualAddress = _data["actualAddress"];
            this.taxpayerStoreId = _data["taxpayerStoreId"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(item);
            }
        }
    }

    static fromJS(data: any): SntParticipantDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntParticipantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tin"] = this.tin;
        data["nonResident"] = this.nonResident;
        data["name"] = this.name;
        data["branchTin"] = this.branchTin;
        data["reorganizedTin"] = this.reorganizedTin;
        data["registerCountryCode"] = this.registerCountryCode;
        data["countryCode"] = this.countryCode;
        data["actualAddress"] = this.actualAddress;
        data["taxpayerStoreId"] = this.taxpayerStoreId;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item);
        }
        return data;
    }
}

export interface ISntParticipantDto {
    /** ИИН/БИН поставщика/получателя (B 13, C 22) */
    tin?: string | undefined;
    /** Нерезидент (B 13.1, C 22.1) */
    nonResident: boolean;
    /** Наименование поставщика/получателя (B 14, C 23) */
    name: string;
    /** БИН структурного подразделения поставщика/получателя (B 15, C 24) */
    branchTin?: string | undefined;
    /** БИН реорганизованного лица (B 16, C 25) */
    reorganizedTin?: string | undefined;
    /** Код страны регистрации получателя (B 18, C 27) */
    registerCountryCode: string;
    /** Код страны доставки/поставки (B 19, C 28) */
    countryCode: string;
    /** Фактический адрес доставки/поставки (B 20, C 29) */
    actualAddress?: string | undefined;
    /** Идентификатор склада доставки/поставки (B 21, C 30) в ИС ЭСФ */
    taxpayerStoreId?: number | undefined;
    /** Категория поставщика (B 17) / Категория получателя (C 26)  */
    statuses?: SntParticipantType[] | undefined;
}

export class SntSellerDto extends SntParticipantDto implements ISntSellerDto {

    constructor(data?: ISntSellerDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SntSellerDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntSellerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISntSellerDto extends ISntParticipantDto {
}

export class SntCustomerDto extends SntParticipantDto implements ISntCustomerDto {

    constructor(data?: ISntCustomerDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SntCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISntCustomerDto extends ISntParticipantDto {
}

export class SntConsignmentParticipantDto implements ISntConsignmentParticipantDto {
    /** ИИН/БИН (D 31, D 34) */
    tin?: string | undefined;
    /** Нерезидент (D 31.1, D 34.1) */
    nonResident!: boolean;
    /** Наименование грузоотправителя/грузополучателя (D 32, D 35) */
    name!: string;
    /** Код страны отправки/доставки (D 33, D 36) */
    countryCode!: string;

    constructor(data?: ISntConsignmentParticipantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tin = _data["tin"];
            this.nonResident = _data["nonResident"];
            this.name = _data["name"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): SntConsignmentParticipantDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntConsignmentParticipantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tin"] = this.tin;
        data["nonResident"] = this.nonResident;
        data["name"] = this.name;
        data["countryCode"] = this.countryCode;
        return data;
    }
}

export interface ISntConsignmentParticipantDto {
    /** ИИН/БИН (D 31, D 34) */
    tin?: string | undefined;
    /** Нерезидент (D 31.1, D 34.1) */
    nonResident: boolean;
    /** Наименование грузоотправителя/грузополучателя (D 32, D 35) */
    name: string;
    /** Код страны отправки/доставки (D 33, D 36) */
    countryCode: string;
}

export class SntShippingInfoDto implements ISntShippingInfoDto {
    /** Наименование перевозчика (E 37) */
    name?: string | undefined;
    /** Нерезидент (E 37.1) */
    nonResident!: boolean;
    /** ИИН/БИН (E 38) */
    tin?: string | undefined;
    /** Вид транспорта (E 39.1) */
    transportTypes?: SntTransporterTransportType[] | undefined;
    /** Гос. номер АТС (39.1 а1.1) */
    carStateNumber?: string | undefined;
    /** Гос. номер прицепа (39.1 а2.1) */
    trailerStateNumber?: string | undefined;
    /** Номер вагона (39.1 b1) */
    carriageNumber?: string | undefined;
    /** Номер борта (39.1 с1) */
    boardNumber?: string | undefined;
    /** Номер судна (39.1 d1) */
    shipNumber?: string | undefined;

    constructor(data?: ISntShippingInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nonResident = _data["nonResident"];
            this.tin = _data["tin"];
            if (Array.isArray(_data["transportTypes"])) {
                this.transportTypes = [] as any;
                for (let item of _data["transportTypes"])
                    this.transportTypes!.push(item);
            }
            this.carStateNumber = _data["carStateNumber"];
            this.trailerStateNumber = _data["trailerStateNumber"];
            this.carriageNumber = _data["carriageNumber"];
            this.boardNumber = _data["boardNumber"];
            this.shipNumber = _data["shipNumber"];
        }
    }

    static fromJS(data: any): SntShippingInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntShippingInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nonResident"] = this.nonResident;
        data["tin"] = this.tin;
        if (Array.isArray(this.transportTypes)) {
            data["transportTypes"] = [];
            for (let item of this.transportTypes)
                data["transportTypes"].push(item);
        }
        data["carStateNumber"] = this.carStateNumber;
        data["trailerStateNumber"] = this.trailerStateNumber;
        data["carriageNumber"] = this.carriageNumber;
        data["boardNumber"] = this.boardNumber;
        data["shipNumber"] = this.shipNumber;
        return data;
    }
}

export interface ISntShippingInfoDto {
    /** Наименование перевозчика (E 37) */
    name?: string | undefined;
    /** Нерезидент (E 37.1) */
    nonResident: boolean;
    /** ИИН/БИН (E 38) */
    tin?: string | undefined;
    /** Вид транспорта (E 39.1) */
    transportTypes?: SntTransporterTransportType[] | undefined;
    /** Гос. номер АТС (39.1 а1.1) */
    carStateNumber?: string | undefined;
    /** Гос. номер прицепа (39.1 а2.1) */
    trailerStateNumber?: string | undefined;
    /** Номер вагона (39.1 b1) */
    carriageNumber?: string | undefined;
    /** Номер борта (39.1 с1) */
    boardNumber?: string | undefined;
    /** Номер судна (39.1 d1) */
    shipNumber?: string | undefined;
}

export enum SntTransporterTransportType {
    AUTOMOBILE = "AUTOMOBILE",
    RAILWAY = "RAILWAY",
    AIR = "AIR",
    MARINE = "MARINE",
    PIPELINE = "PIPELINE",
    MULTIMODAL = "MULTIMODAL",
    OTHER = "OTHER",
}

export class SntContractDto implements ISntContractDto {
    /** Договор (контракт) или приложение к договору  (F 44.a, F 44.b) */
    isContract!: boolean;
    /** Номер (F 44.1) */
    number?: string | undefined;
    /** Дата (F 44.2) */
    date?: Date | undefined;
    /** Условия оплаты по договору (F 45) */
    termOfContractPayment?: string | undefined;
    /** Условия поставки (ИНКОТЕРМС) (F 45.1) */
    deliveryCondition?: string | undefined;

    constructor(data?: ISntContractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isContract = _data["isContract"];
            this.number = _data["number"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.termOfContractPayment = _data["termOfContractPayment"];
            this.deliveryCondition = _data["deliveryCondition"];
        }
    }

    static fromJS(data: any): SntContractDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntContractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isContract"] = this.isContract;
        data["number"] = this.number;
        data["date"] = this.date ? this.date.toYearMonthDateString() : <any>undefined;
        data["termOfContractPayment"] = this.termOfContractPayment;
        data["deliveryCondition"] = this.deliveryCondition;
        return data;
    }
}

export interface ISntContractDto {
    /** Договор (контракт) или приложение к договору  (F 44.a, F 44.b) */
    isContract: boolean;
    /** Номер (F 44.1) */
    number?: string | undefined;
    /** Дата (F 44.2) */
    date?: Date | undefined;
    /** Условия оплаты по договору (F 45) */
    termOfContractPayment?: string | undefined;
    /** Условия поставки (ИНКОТЕРМС) (F 45.1) */
    deliveryCondition?: string | undefined;
}

/** Данные о грузе, перевозимом на автомобильном транспорте (K) */
export class SntCarCargoInfoDto implements ISntCarCargoInfoDto {
    /** Ф.И.О. водителя */
    driverFio?: string | undefined;
    /** ИИН водителя */
    driverTin?: string | undefined;
    /** Номер оттиска пломбы */
    stampPrintNumber?: string | undefined;

    constructor(data?: ISntCarCargoInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.driverFio = _data["driverFio"];
            this.driverTin = _data["driverTin"];
            this.stampPrintNumber = _data["stampPrintNumber"];
        }
    }

    static fromJS(data: any): SntCarCargoInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntCarCargoInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["driverFio"] = this.driverFio;
        data["driverTin"] = this.driverTin;
        data["stampPrintNumber"] = this.stampPrintNumber;
        return data;
    }
}

/** Данные о грузе, перевозимом на автомобильном транспорте (K) */
export interface ISntCarCargoInfoDto {
    /** Ф.И.О. водителя */
    driverFio?: string | undefined;
    /** ИИН водителя */
    driverTin?: string | undefined;
    /** Номер оттиска пломбы */
    stampPrintNumber?: string | undefined;
}

export class SntOilSetDto implements ISntOilSetDto {
    /** Код ОГД адреса доставки/поставки (G7 72) */
    kogdOfRecipient?: string | undefined;
    /** Код ОГД адреса отправки/отгрузки (G7 71) */
    kogdOfSender?: string | undefined;
    /** Код операции (G7 69) */
    operationCode?: string | undefined;
    /** Тип поставщика (G7 70) */
    productSellerType?: string | undefined;

    constructor(data?: ISntOilSetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kogdOfRecipient = _data["kogdOfRecipient"];
            this.kogdOfSender = _data["kogdOfSender"];
            this.operationCode = _data["operationCode"];
            this.productSellerType = _data["productSellerType"];
        }
    }

    static fromJS(data: any): SntOilSetDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntOilSetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kogdOfRecipient"] = this.kogdOfRecipient;
        data["kogdOfSender"] = this.kogdOfSender;
        data["operationCode"] = this.operationCode;
        data["productSellerType"] = this.productSellerType;
        return data;
    }
}

export interface ISntOilSetDto {
    /** Код ОГД адреса доставки/поставки (G7 72) */
    kogdOfRecipient?: string | undefined;
    /** Код ОГД адреса отправки/отгрузки (G7 71) */
    kogdOfSender?: string | undefined;
    /** Код операции (G7 69) */
    operationCode?: string | undefined;
    /** Тип поставщика (G7 70) */
    productSellerType?: string | undefined;
}

export class SntReleaseGoodsInfoDto implements ISntReleaseGoodsInfoDto {
    /** Номер доверенности, по которой осуществляется отпуск товара (83.1) */
    powerOfAttorneyNumber?: string | undefined;
    /** Дата доверенности, по которой осуществляется отпуск товара (83.2) */
    powerOfAttorneyDate?: Date | undefined;

    constructor(data?: ISntReleaseGoodsInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.powerOfAttorneyNumber = _data["powerOfAttorneyNumber"];
            this.powerOfAttorneyDate = _data["powerOfAttorneyDate"] ? new Date(_data["powerOfAttorneyDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SntReleaseGoodsInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntReleaseGoodsInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["powerOfAttorneyNumber"] = this.powerOfAttorneyNumber;
        data["powerOfAttorneyDate"] = this.powerOfAttorneyDate ? this.powerOfAttorneyDate.toYearMonthDateString() : <any>undefined;
        return data;
    }
}

export interface ISntReleaseGoodsInfoDto {
    /** Номер доверенности, по которой осуществляется отпуск товара (83.1) */
    powerOfAttorneyNumber?: string | undefined;
    /** Дата доверенности, по которой осуществляется отпуск товара (83.2) */
    powerOfAttorneyDate?: Date | undefined;
}

export class SigningPageForSntResponseDto implements ISigningPageForSntResponseDto {
    urlToSign?: string | undefined;

    constructor(data?: ISigningPageForSntResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.urlToSign = _data["urlToSign"];
        }
    }

    static fromJS(data: any): SigningPageForSntResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SigningPageForSntResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["urlToSign"] = this.urlToSign;
        return data;
    }
}

export interface ISigningPageForSntResponseDto {
    urlToSign?: string | undefined;
}

export class SendSntDto implements ISendSntDto {
    /** Snt.Id */
    sntId!: number;
    /** Timezone offset from the client in minutes */
    localTimezoneOffsetMinutes!: number;

    constructor(data?: ISendSntDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sntId = _data["sntId"];
            this.localTimezoneOffsetMinutes = _data["localTimezoneOffsetMinutes"];
        }
    }

    static fromJS(data: any): SendSntDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendSntDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sntId"] = this.sntId;
        data["localTimezoneOffsetMinutes"] = this.localTimezoneOffsetMinutes;
        return data;
    }
}

export interface ISendSntDto {
    /** Snt.Id */
    sntId: number;
    /** Timezone offset from the client in minutes */
    localTimezoneOffsetMinutes: number;
}

export class SigningPageForChangeSntStatusResponseDto implements ISigningPageForChangeSntStatusResponseDto {
    urlToSign?: string | undefined;

    constructor(data?: ISigningPageForChangeSntStatusResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.urlToSign = _data["urlToSign"];
        }
    }

    static fromJS(data: any): SigningPageForChangeSntStatusResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SigningPageForChangeSntStatusResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["urlToSign"] = this.urlToSign;
        return data;
    }
}

export interface ISigningPageForChangeSntStatusResponseDto {
    urlToSign?: string | undefined;
}

/** Запрос на отзыв СНТ */
export class RevokeSntDto implements IRevokeSntDto {
    /** Идентификатор СНТ */
    sntId!: number;
    /** Причина отзыва */
    cause?: string | undefined;

    constructor(data?: IRevokeSntDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sntId = _data["sntId"];
            this.cause = _data["cause"];
        }
    }

    static fromJS(data: any): RevokeSntDto {
        data = typeof data === 'object' ? data : {};
        let result = new RevokeSntDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sntId"] = this.sntId;
        data["cause"] = this.cause;
        return data;
    }
}

/** Запрос на отзыв СНТ */
export interface IRevokeSntDto {
    /** Идентификатор СНТ */
    sntId: number;
    /** Причина отзыва */
    cause?: string | undefined;
}

/** Запрос на подтверждение СНТ */
export class ConfirmSntDto implements IConfirmSntDto {
    /** Идентификатор СНТ */
    sntId!: number;
    /** Дата документа доверенности приемки товара */
    powerOfAttorneyDate!: Date;
    /** Номер документа доверенности приемки товара */
    powerOfAttorneyNumber?: string | undefined;

    constructor(data?: IConfirmSntDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sntId = _data["sntId"];
            this.powerOfAttorneyDate = _data["powerOfAttorneyDate"] ? new Date(_data["powerOfAttorneyDate"].toString()) : <any>undefined;
            this.powerOfAttorneyNumber = _data["powerOfAttorneyNumber"];
        }
    }

    static fromJS(data: any): ConfirmSntDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmSntDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sntId"] = this.sntId;
        data["powerOfAttorneyDate"] = this.powerOfAttorneyDate ? this.powerOfAttorneyDate.toYearMonthDateString() : <any>undefined;
        data["powerOfAttorneyNumber"] = this.powerOfAttorneyNumber;
        return data;
    }
}

/** Запрос на подтверждение СНТ */
export interface IConfirmSntDto {
    /** Идентификатор СНТ */
    sntId: number;
    /** Дата документа доверенности приемки товара */
    powerOfAttorneyDate: Date;
    /** Номер документа доверенности приемки товара */
    powerOfAttorneyNumber?: string | undefined;
}

/** Запрос на отклонение СНТ */
export class DeclineSntDto implements IDeclineSntDto {
    /** Идентификатор СНТ */
    sntId!: number;
    /** Причина отклонения */
    cause?: string | undefined;

    constructor(data?: IDeclineSntDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sntId = _data["sntId"];
            this.cause = _data["cause"];
        }
    }

    static fromJS(data: any): DeclineSntDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeclineSntDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sntId"] = this.sntId;
        data["cause"] = this.cause;
        return data;
    }
}

/** Запрос на отклонение СНТ */
export interface IDeclineSntDto {
    /** Идентификатор СНТ */
    sntId: number;
    /** Причина отклонения */
    cause?: string | undefined;
}

export class ImportSntResultDto implements IImportSntResultDto {
    added!: number;
    updated!: number;

    constructor(data?: IImportSntResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.added = _data["added"];
            this.updated = _data["updated"];
        }
    }

    static fromJS(data: any): ImportSntResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportSntResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["added"] = this.added;
        data["updated"] = this.updated;
        return data;
    }
}

export interface IImportSntResultDto {
    added: number;
    updated: number;
}

/** Черновик СНТ */
export class SntDraftDto extends SntBaseDto implements ISntDraftDto {
    /** Товары */
    products?: SntDraftProductDto[] | undefined;
    /** Нефтепродукты */
    oilProducts?: SntDraftOilProductDto[] | undefined;
    /** Товары подлежащие экспортному (двойного назначения, военного назначения) (G10) */
    exportControlProducts?: SntDraftExportControlProductDto[] | undefined;

    constructor(data?: ISntDraftDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(SntDraftProductDto.fromJS(item));
            }
            if (Array.isArray(_data["oilProducts"])) {
                this.oilProducts = [] as any;
                for (let item of _data["oilProducts"])
                    this.oilProducts!.push(SntDraftOilProductDto.fromJS(item));
            }
            if (Array.isArray(_data["exportControlProducts"])) {
                this.exportControlProducts = [] as any;
                for (let item of _data["exportControlProducts"])
                    this.exportControlProducts!.push(SntDraftExportControlProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SntDraftDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntDraftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        if (Array.isArray(this.oilProducts)) {
            data["oilProducts"] = [];
            for (let item of this.oilProducts)
                data["oilProducts"].push(item.toJSON());
        }
        if (Array.isArray(this.exportControlProducts)) {
            data["exportControlProducts"] = [];
            for (let item of this.exportControlProducts)
                data["exportControlProducts"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Черновик СНТ */
export interface ISntDraftDto extends ISntBaseDto {
    /** Товары */
    products?: SntDraftProductDto[] | undefined;
    /** Нефтепродукты */
    oilProducts?: SntDraftOilProductDto[] | undefined;
    /** Товары подлежащие экспортному (двойного назначения, военного назначения) (G10) */
    exportControlProducts?: SntDraftExportControlProductDto[] | undefined;
}

export class SntDraftProductDto extends SntProductDtoBase implements ISntDraftProductDto {
    /** Код товара (GTIN) (G1 16) */
    gtinCode?: string | undefined;

    constructor(data?: ISntDraftProductDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.gtinCode = _data["gtinCode"];
        }
    }

    static fromJS(data: any): SntDraftProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntDraftProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gtinCode"] = this.gtinCode;
        super.toJSON(data);
        return data;
    }
}

export interface ISntDraftProductDto extends ISntProductDtoBase {
    /** Код товара (GTIN) (G1 16) */
    gtinCode?: string | undefined;
}

export class SntDraftOilProductDto extends SntProductDtoBase implements ISntDraftOilProductDto {

    constructor(data?: ISntDraftOilProductDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SntDraftOilProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntDraftOilProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISntDraftOilProductDto extends ISntProductDtoBase {
}

export class SntDraftExportControlProductDto extends SntProductDtoBase implements ISntDraftExportControlProductDto {

    constructor(data?: ISntDraftExportControlProductDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SntDraftExportControlProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntDraftExportControlProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISntDraftExportControlProductDto extends ISntProductDtoBase {
}

export class SntParticipantShortDto implements ISntParticipantShortDto {
    /** Фактический адрес доставки/поставки (B 20, C 29) */
    actualAddress?: string | undefined;
    /** Код страны доставки/поставки (B 19, C 28) */
    countryCode!: string;
    /** Нерезидент (B 13.1, C 22.1) */
    nonResident!: boolean;
    /** Код страны регистрации получателя (B 18, C 27) */
    registerCountryCode!: string;
    /** БИН реорганизованного лица (B 16, C 25) */
    reorganizedTin?: string | undefined;
    /** Категория поставщика (B 17) / Категория получателя (C 26)  */
    statuses?: SntParticipantType[] | undefined;
    /** БИН структурного подразделения поставщика/получателя (B 15, C 24) */
    branchTin?: string | undefined;
    /** Наименование поставщика/получателя (B 14, C 23) */
    name!: string;
    /** ИИН/БИН поставщика/получателя (B 13, C 22) */
    tin?: string | undefined;

    constructor(data?: ISntParticipantShortDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actualAddress = _data["actualAddress"];
            this.countryCode = _data["countryCode"];
            this.nonResident = _data["nonResident"];
            this.registerCountryCode = _data["registerCountryCode"];
            this.reorganizedTin = _data["reorganizedTin"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(item);
            }
            this.branchTin = _data["branchTin"];
            this.name = _data["name"];
            this.tin = _data["tin"];
        }
    }

    static fromJS(data: any): SntParticipantShortDto {
        data = typeof data === 'object' ? data : {};
        let result = new SntParticipantShortDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actualAddress"] = this.actualAddress;
        data["countryCode"] = this.countryCode;
        data["nonResident"] = this.nonResident;
        data["registerCountryCode"] = this.registerCountryCode;
        data["reorganizedTin"] = this.reorganizedTin;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item);
        }
        data["branchTin"] = this.branchTin;
        data["name"] = this.name;
        data["tin"] = this.tin;
        return data;
    }
}

export interface ISntParticipantShortDto {
    /** Фактический адрес доставки/поставки (B 20, C 29) */
    actualAddress?: string | undefined;
    /** Код страны доставки/поставки (B 19, C 28) */
    countryCode: string;
    /** Нерезидент (B 13.1, C 22.1) */
    nonResident: boolean;
    /** Код страны регистрации получателя (B 18, C 27) */
    registerCountryCode: string;
    /** БИН реорганизованного лица (B 16, C 25) */
    reorganizedTin?: string | undefined;
    /** Категория поставщика (B 17) / Категория получателя (C 26)  */
    statuses?: SntParticipantType[] | undefined;
    /** БИН структурного подразделения поставщика/получателя (B 15, C 24) */
    branchTin?: string | undefined;
    /** Наименование поставщика/получателя (B 14, C 23) */
    name: string;
    /** ИИН/БИН поставщика/получателя (B 13, C 22) */
    tin?: string | undefined;
}

/** Склад */
export class TaxpayerStoreSimpleDto implements ITaxpayerStoreSimpleDto {
    /** Идентификатор */
    id!: number;
    /** Идентификатор в ЕСФ */
    externalId!: number;
    /** Наименование склада */
    name!: string;
    /** Тип */
    type!: StoreType;
    /** Статус */
    status!: TaxpayerStoreStatus;
    /** Адрес */
    address?: string | undefined;
    /** Приоритетный склад */
    isDefault!: boolean;
    /** Признак оприходования товаров по ДТ */
    isPostingGoods!: boolean;
    /** Склад реорганизуемого лица */
    isInherited!: boolean;
    /** Склад УСД */
    isJointStore!: boolean;
    /** ИИН ответственного лица */
    responsiblePersonIin!: string;

    constructor(data?: ITaxpayerStoreSimpleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.address = _data["address"];
            this.isDefault = _data["isDefault"];
            this.isPostingGoods = _data["isPostingGoods"];
            this.isInherited = _data["isInherited"];
            this.isJointStore = _data["isJointStore"];
            this.responsiblePersonIin = _data["responsiblePersonIin"];
        }
    }

    static fromJS(data: any): TaxpayerStoreSimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaxpayerStoreSimpleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["status"] = this.status;
        data["address"] = this.address;
        data["isDefault"] = this.isDefault;
        data["isPostingGoods"] = this.isPostingGoods;
        data["isInherited"] = this.isInherited;
        data["isJointStore"] = this.isJointStore;
        data["responsiblePersonIin"] = this.responsiblePersonIin;
        return data;
    }
}

/** Склад */
export interface ITaxpayerStoreSimpleDto {
    /** Идентификатор */
    id: number;
    /** Идентификатор в ЕСФ */
    externalId: number;
    /** Наименование склада */
    name: string;
    /** Тип */
    type: StoreType;
    /** Статус */
    status: TaxpayerStoreStatus;
    /** Адрес */
    address?: string | undefined;
    /** Приоритетный склад */
    isDefault: boolean;
    /** Признак оприходования товаров по ДТ */
    isPostingGoods: boolean;
    /** Склад реорганизуемого лица */
    isInherited: boolean;
    /** Склад УСД */
    isJointStore: boolean;
    /** ИИН ответственного лица */
    responsiblePersonIin: string;
}

export enum StoreType {
    POINT_OF_SALE = "POINT_OF_SALE",
    STORE_HOUSE = "STORE_HOUSE",
    MOBILE_STORE = "MOBILE_STORE",
}

export enum TaxpayerStoreStatus {
    VALID = "VALID",
    INVALID = "INVALID",
}

export class ImportCustomerStoresCommand implements IImportCustomerStoresCommand {
    tin?: string | undefined;

    constructor(data?: IImportCustomerStoresCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tin = _data["tin"];
        }
    }

    static fromJS(data: any): ImportCustomerStoresCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ImportCustomerStoresCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tin"] = this.tin;
        return data;
    }
}

export interface IImportCustomerStoresCommand {
    tin?: string | undefined;
}

export class UFormListResponseDto implements IUFormListResponseDto {
    uforms?: UFormSimpleDto[] | undefined;
    paging?: PagingModel | undefined;

    constructor(data?: IUFormListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["uforms"])) {
                this.uforms = [] as any;
                for (let item of _data["uforms"])
                    this.uforms!.push(UFormSimpleDto.fromJS(item));
            }
            this.paging = _data["paging"] ? PagingModel.fromJS(_data["paging"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UFormListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UFormListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.uforms)) {
            data["uforms"] = [];
            for (let item of this.uforms)
                data["uforms"].push(item.toJSON());
        }
        data["paging"] = this.paging ? this.paging.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUFormListResponseDto {
    uforms?: UFormSimpleDto[] | undefined;
    paging?: PagingModel | undefined;
}

/** Универсальная форма */
export class UFormSimpleDto implements IUFormSimpleDto {
    /** Идентификатор */
    id!: number;
    /** Идентификатор в ЭСФ */
    externalId?: number | undefined;
    /** Дата выписки Универсальной Формы */
    date!: Date;
    /** Тип Универсальной Формы */
    type!: UFormType;
    /** Исходящий номер Универсальной Формы в бухгалтерии отправителя */
    number!: string;
    /** ИИН/БИН получателя Универсальной Формы */
    recipientTin?: string | undefined;
    /** Регистрационный номер Универсальной Формы */
    registrationNumber?: string | undefined;
    /** ИИН/БИН отправителя Универсальной Формы */
    senderTin!: string;
    /** Общая сумма */
    totalSum!: number;
    /** Cтатус Универсальной Формы в системе */
    status!: UFormStatusType;
    /** Причина аннулирования */
    cancelReason?: string | undefined;

    constructor(data?: IUFormSimpleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.number = _data["number"];
            this.recipientTin = _data["recipientTin"];
            this.registrationNumber = _data["registrationNumber"];
            this.senderTin = _data["senderTin"];
            this.totalSum = _data["totalSum"];
            this.status = _data["status"];
            this.cancelReason = _data["cancelReason"];
        }
    }

    static fromJS(data: any): UFormSimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UFormSimpleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["date"] = this.date ? this.date.toYearMonthDateString() : <any>undefined;
        data["type"] = this.type;
        data["number"] = this.number;
        data["recipientTin"] = this.recipientTin;
        data["registrationNumber"] = this.registrationNumber;
        data["senderTin"] = this.senderTin;
        data["totalSum"] = this.totalSum;
        data["status"] = this.status;
        data["cancelReason"] = this.cancelReason;
        return data;
    }
}

/** Универсальная форма */
export interface IUFormSimpleDto {
    /** Идентификатор */
    id: number;
    /** Идентификатор в ЭСФ */
    externalId?: number | undefined;
    /** Дата выписки Универсальной Формы */
    date: Date;
    /** Тип Универсальной Формы */
    type: UFormType;
    /** Исходящий номер Универсальной Формы в бухгалтерии отправителя */
    number: string;
    /** ИИН/БИН получателя Универсальной Формы */
    recipientTin?: string | undefined;
    /** Регистрационный номер Универсальной Формы */
    registrationNumber?: string | undefined;
    /** ИИН/БИН отправителя Универсальной Формы */
    senderTin: string;
    /** Общая сумма */
    totalSum: number;
    /** Cтатус Универсальной Формы в системе */
    status: UFormStatusType;
    /** Причина аннулирования */
    cancelReason?: string | undefined;
}

export enum UFormType {
    ESF = "ESF",
    KKM = "KKM",
    DT = "DT",
    FNO = "FNO",
    MANUFACTURE = "MANUFACTURE",
    BALANCE = "BALANCE",
    MOVEMENT = "MOVEMENT",
    WRITE_OFF = "WRITE_OFF",
    BALANCE_CORRECTION = "BALANCE_CORRECTION",
    DETAILING = "DETAILING",
    PHYSICAL_LABEL = "PHYSICAL_LABEL",
    REORGANIZATION = "REORGANIZATION",
    IMPORT_DETAILING = "IMPORT_DETAILING",
}

export enum UFormStatusType {
    CREATED = "CREATED",
    IN_PROCESSING = "IN_PROCESSING",
    PROCESSED = "PROCESSED",
    WAIT_INSTOCK = "WAIT_INSTOCK",
    WAIT_DOCUMENT = "WAIT_DOCUMENT",
    CANCELED = "CANCELED",
    FAILED = "FAILED",
    DRAFT = "DRAFT",
}

export class UFormFullDto implements IUFormFullDto {
    date!: Date;
    number?: string | undefined;
    sender?: UFormSenderDto | undefined;
    type!: UFormType;
    detailingType!: UFormDetailingType;
    totalSum!: number;
    products?: UFormProductDto[] | undefined;
    sourceProducts?: UFormProductDto[] | undefined;
    comment?: string | undefined;
    writeOffReason!: UFormWriteOffType;
    recipientTaxpayerStoreId!: number;
    uFormId!: number;
    inputDate?: Date | undefined;
    lastUpdateDate?: Date | undefined;
    status!: UFormStatusType;
    version?: string | undefined;
    registrationNumber?: string | undefined;

    constructor(data?: IUFormFullDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.number = _data["number"];
            this.sender = _data["sender"] ? UFormSenderDto.fromJS(_data["sender"]) : <any>undefined;
            this.type = _data["type"];
            this.detailingType = _data["detailingType"];
            this.totalSum = _data["totalSum"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(UFormProductDto.fromJS(item));
            }
            if (Array.isArray(_data["sourceProducts"])) {
                this.sourceProducts = [] as any;
                for (let item of _data["sourceProducts"])
                    this.sourceProducts!.push(UFormProductDto.fromJS(item));
            }
            this.comment = _data["comment"];
            this.writeOffReason = _data["writeOffReason"];
            this.recipientTaxpayerStoreId = _data["recipientTaxpayerStoreId"];
            this.uFormId = _data["uFormId"];
            this.inputDate = _data["inputDate"] ? new Date(_data["inputDate"].toString()) : <any>undefined;
            this.lastUpdateDate = _data["lastUpdateDate"] ? new Date(_data["lastUpdateDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.version = _data["version"];
            this.registrationNumber = _data["registrationNumber"];
        }
    }

    static fromJS(data: any): UFormFullDto {
        data = typeof data === 'object' ? data : {};
        let result = new UFormFullDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toYearMonthDateString() : <any>undefined;
        data["number"] = this.number;
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["detailingType"] = this.detailingType;
        data["totalSum"] = this.totalSum;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        if (Array.isArray(this.sourceProducts)) {
            data["sourceProducts"] = [];
            for (let item of this.sourceProducts)
                data["sourceProducts"].push(item.toJSON());
        }
        data["comment"] = this.comment;
        data["writeOffReason"] = this.writeOffReason;
        data["recipientTaxpayerStoreId"] = this.recipientTaxpayerStoreId;
        data["uFormId"] = this.uFormId;
        data["inputDate"] = this.inputDate ? this.inputDate.toYearMonthDateString() : <any>undefined;
        data["lastUpdateDate"] = this.lastUpdateDate ? this.lastUpdateDate.toYearMonthDateString() : <any>undefined;
        data["status"] = this.status;
        data["version"] = this.version;
        data["registrationNumber"] = this.registrationNumber;
        return data;
    }
}

export interface IUFormFullDto {
    date: Date;
    number?: string | undefined;
    sender?: UFormSenderDto | undefined;
    type: UFormType;
    detailingType: UFormDetailingType;
    totalSum: number;
    products?: UFormProductDto[] | undefined;
    sourceProducts?: UFormProductDto[] | undefined;
    comment?: string | undefined;
    writeOffReason: UFormWriteOffType;
    recipientTaxpayerStoreId: number;
    uFormId: number;
    inputDate?: Date | undefined;
    lastUpdateDate?: Date | undefined;
    status: UFormStatusType;
    version?: string | undefined;
    registrationNumber?: string | undefined;
}

export class UFormSenderDto implements IUFormSenderDto {
    address?: string | undefined;
    name?: string | undefined;
    storeId?: string | undefined;
    storeName?: string | undefined;
    tin?: string | undefined;

    constructor(data?: IUFormSenderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.name = _data["name"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.tin = _data["tin"];
        }
    }

    static fromJS(data: any): UFormSenderDto {
        data = typeof data === 'object' ? data : {};
        let result = new UFormSenderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["name"] = this.name;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["tin"] = this.tin;
        return data;
    }
}

export interface IUFormSenderDto {
    address?: string | undefined;
    name?: string | undefined;
    storeId?: string | undefined;
    storeName?: string | undefined;
    tin?: string | undefined;
}

export enum UFormDetailingType {
    CONVERSION = "CONVERSION",
    PACKING = "PACKING",
    UNPACKING = "UNPACKING",
    RE_SORTING = "RE_SORTING",
    EDITING = "EDITING",
}

export class UFormProductDto implements IUFormProductDto {
    gsvsCode?: string | undefined;
    measureUnitId!: number;
    name?: string | undefined;
    price!: number;
    productId?: number | undefined;
    balanceId?: number | undefined;
    quantity!: number;
    sum!: number;
    tnvedCode?: string | undefined;
    pinCode?: string | undefined;
    productNameInImportDoc?: string | undefined;
    productNumberInImportDoc?: string | undefined;
    dutyTypeCode?: UFormCustomsDutyType | undefined;
    manufactureOrImportCountry?: string | undefined;
    manufactureOrImportDocNumber?: string | undefined;
    originCode?: string | undefined;
    sectionType?: UFormSectionType | undefined;

    constructor(data?: IUFormProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gsvsCode = _data["gsvsCode"];
            this.measureUnitId = _data["measureUnitId"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.productId = _data["productId"];
            this.balanceId = _data["balanceId"];
            this.quantity = _data["quantity"];
            this.sum = _data["sum"];
            this.tnvedCode = _data["tnvedCode"];
            this.pinCode = _data["pinCode"];
            this.productNameInImportDoc = _data["productNameInImportDoc"];
            this.productNumberInImportDoc = _data["productNumberInImportDoc"];
            this.dutyTypeCode = _data["dutyTypeCode"];
            this.manufactureOrImportCountry = _data["manufactureOrImportCountry"];
            this.manufactureOrImportDocNumber = _data["manufactureOrImportDocNumber"];
            this.originCode = _data["originCode"];
            this.sectionType = _data["sectionType"];
        }
    }

    static fromJS(data: any): UFormProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new UFormProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gsvsCode"] = this.gsvsCode;
        data["measureUnitId"] = this.measureUnitId;
        data["name"] = this.name;
        data["price"] = this.price;
        data["productId"] = this.productId;
        data["balanceId"] = this.balanceId;
        data["quantity"] = this.quantity;
        data["sum"] = this.sum;
        data["tnvedCode"] = this.tnvedCode;
        data["pinCode"] = this.pinCode;
        data["productNameInImportDoc"] = this.productNameInImportDoc;
        data["productNumberInImportDoc"] = this.productNumberInImportDoc;
        data["dutyTypeCode"] = this.dutyTypeCode;
        data["manufactureOrImportCountry"] = this.manufactureOrImportCountry;
        data["manufactureOrImportDocNumber"] = this.manufactureOrImportDocNumber;
        data["originCode"] = this.originCode;
        data["sectionType"] = this.sectionType;
        return data;
    }
}

export interface IUFormProductDto {
    gsvsCode?: string | undefined;
    measureUnitId: number;
    name?: string | undefined;
    price: number;
    productId?: number | undefined;
    balanceId?: number | undefined;
    quantity: number;
    sum: number;
    tnvedCode?: string | undefined;
    pinCode?: string | undefined;
    productNameInImportDoc?: string | undefined;
    productNumberInImportDoc?: string | undefined;
    dutyTypeCode?: UFormCustomsDutyType | undefined;
    manufactureOrImportCountry?: string | undefined;
    manufactureOrImportDocNumber?: string | undefined;
    originCode?: string | undefined;
    sectionType?: UFormSectionType | undefined;
}

export enum UFormCustomsDutyType {
    CCT = "CCT",
    WTO = "WTO",
    EAEU = "EAEU",
    NOT_INSTALLED = "NOT_INSTALLED",
}

export enum UFormSectionType {
    SectionE1 = "SectionE1",
    SectionE2 = "SectionE2",
}

export enum UFormWriteOffType {
    MANUFACTURE = "MANUFACTURE",
    SOLD_IN_RETAIL_OR_COUPONS = "SOLD_IN_RETAIL_OR_COUPONS",
    DAMAGE = "DAMAGE",
    RECYCLING = "RECYCLING",
    RECLAMATION = "RECLAMATION",
    LOSS = "LOSS",
    IS_NOT_VSTORE = "IS_NOT_VSTORE",
    MEDICAL_NEEDS = "MEDICAL_NEEDS",
    TECHNICAL_NEEDS = "TECHNICAL_NEEDS",
    NATURAL_DECREASE_IN_NORM = "NATURAL_DECREASE_IN_NORM",
    NATURAL_DECREASE_OVER_NORM = "NATURAL_DECREASE_OVER_NORM",
    THEFT = "THEFT",
    WRITE_OFF_BY_GUILTY = "WRITE_OFF_BY_GUILTY",
    SOCIAL_PACKAGE = "SOCIAL_PACKAGE",
    NO_REQUIREMENTS_FOR_SNT = "NO_REQUIREMENTS_FOR_SNT",
    CONVERSION = "CONVERSION",
    SERVICE = "SERVICE",
    MISTAKE = "MISTAKE",
    ACCOUNTING_FIXED_ASSETS = "ACCOUNTING_FIXED_ASSETS",
    OTHER = "OTHER",
    COUPONS_OR_CARDS_PAYMENTS = "COUPONS_OR_CARDS_PAYMENTS",
}

export abstract class UFormDtoBase implements IUFormDtoBase {
    /** Идентификатор существующей формы или null для новой формы */
    id?: number | undefined;
    /** Дата выписки Универсальной Формы */
    date!: Date;
    /** Timezone offset from the client in minutes */
    localTimezoneOffsetMinutes!: number;
    /** Исходящий номер Универсальной Формы в бухгалтерии отправителя */
    number!: string;
    /** Id склада отправилетя */
    senderTaxpayerStoreId!: number;

    constructor(data?: IUFormDtoBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.localTimezoneOffsetMinutes = _data["localTimezoneOffsetMinutes"];
            this.number = _data["number"];
            this.senderTaxpayerStoreId = _data["senderTaxpayerStoreId"];
        }
    }

    static fromJS(data: any): UFormDtoBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'UFormDtoBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toYearMonthDateString() : <any>undefined;
        data["localTimezoneOffsetMinutes"] = this.localTimezoneOffsetMinutes;
        data["number"] = this.number;
        data["senderTaxpayerStoreId"] = this.senderTaxpayerStoreId;
        return data;
    }
}

export interface IUFormDtoBase {
    /** Идентификатор существующей формы или null для новой формы */
    id?: number | undefined;
    /** Дата выписки Универсальной Формы */
    date: Date;
    /** Timezone offset from the client in minutes */
    localTimezoneOffsetMinutes: number;
    /** Исходящий номер Универсальной Формы в бухгалтерии отправителя */
    number: string;
    /** Id склада отправилетя */
    senderTaxpayerStoreId: number;
}

export class ManufactureUFormDto extends UFormDtoBase implements IManufactureUFormDto {
    /** Товары */
    products!: ManufactureUFormProductDto[];

    constructor(data?: IManufactureUFormDto) {
        super(data);
        if (!data) {
            this.products = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ManufactureUFormProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ManufactureUFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ManufactureUFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IManufactureUFormDto extends IUFormDtoBase {
    /** Товары */
    products: ManufactureUFormProductDto[];
}

export abstract class UFormProductDtoBase implements IUFormProductDtoBase {
    price!: number;
    quantity!: number;

    constructor(data?: IUFormProductDtoBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.price = _data["price"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): UFormProductDtoBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'UFormProductDtoBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["price"] = this.price;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IUFormProductDtoBase {
    price: number;
    quantity: number;
}

export class ManufactureUFormProductDto extends UFormProductDtoBase implements IManufactureUFormProductDto {
    productId!: number;
    measureUnitId!: number;
    name!: string;

    constructor(data?: IManufactureUFormProductDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.productId = _data["productId"];
            this.measureUnitId = _data["measureUnitId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ManufactureUFormProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ManufactureUFormProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["measureUnitId"] = this.measureUnitId;
        data["name"] = this.name;
        super.toJSON(data);
        return data;
    }
}

export interface IManufactureUFormProductDto extends IUFormProductDtoBase {
    productId: number;
    measureUnitId: number;
    name: string;
}

export class WriteOffUFormDto extends UFormDtoBase implements IWriteOffUFormDto {
    comment?: string | undefined;
    writeOffReason!: UFormWriteOffType;
    /** Товары */
    products!: WriteOffUFormProductDto[];

    constructor(data?: IWriteOffUFormDto) {
        super(data);
        if (!data) {
            this.products = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.comment = _data["comment"];
            this.writeOffReason = _data["writeOffReason"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(WriteOffUFormProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WriteOffUFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new WriteOffUFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        data["writeOffReason"] = this.writeOffReason;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IWriteOffUFormDto extends IUFormDtoBase {
    comment?: string | undefined;
    writeOffReason: UFormWriteOffType;
    /** Товары */
    products: WriteOffUFormProductDto[];
}

export class WriteOffUFormProductDto extends UFormProductDtoBase implements IWriteOffUFormProductDto {
    balanceId!: number;

    constructor(data?: IWriteOffUFormProductDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.balanceId = _data["balanceId"];
        }
    }

    static fromJS(data: any): WriteOffUFormProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new WriteOffUFormProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["balanceId"] = this.balanceId;
        super.toJSON(data);
        return data;
    }
}

export interface IWriteOffUFormProductDto extends IUFormProductDtoBase {
    balanceId: number;
}

export class MovementUFormDto extends UFormDtoBase implements IMovementUFormDto {
    recipientTaxpayerStoreId!: number;
    /** Товары */
    products!: MovementUFormProductDto[];

    constructor(data?: IMovementUFormDto) {
        super(data);
        if (!data) {
            this.products = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.recipientTaxpayerStoreId = _data["recipientTaxpayerStoreId"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(MovementUFormProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MovementUFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new MovementUFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipientTaxpayerStoreId"] = this.recipientTaxpayerStoreId;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IMovementUFormDto extends IUFormDtoBase {
    recipientTaxpayerStoreId: number;
    /** Товары */
    products: MovementUFormProductDto[];
}

export class MovementUFormProductDto extends UFormProductDtoBase implements IMovementUFormProductDto {
    balanceId!: number;

    constructor(data?: IMovementUFormProductDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.balanceId = _data["balanceId"];
        }
    }

    static fromJS(data: any): MovementUFormProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new MovementUFormProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["balanceId"] = this.balanceId;
        super.toJSON(data);
        return data;
    }
}

export interface IMovementUFormProductDto extends IUFormProductDtoBase {
    balanceId: number;
}

export class BalanceUFormDto extends UFormDtoBase implements IBalanceUFormDto {
    /** Товары */
    products!: BalanceUFormProductDto[];

    constructor(data?: IBalanceUFormDto) {
        super(data);
        if (!data) {
            this.products = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(BalanceUFormProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BalanceUFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceUFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IBalanceUFormDto extends IUFormDtoBase {
    /** Товары */
    products: BalanceUFormProductDto[];
}

export class BalanceUFormProductDto extends UFormProductDtoBase implements IBalanceUFormProductDto {
    name!: string;
    gsvsId!: number;
    measureUnitId!: number;
    dutyTypeCode!: UFormCustomsDutyType;
    manufactureOrImportCountry!: string;
    manufactureOrImportDocNumber?: string | undefined;
    originCode!: number;
    productNumberInImportDoc?: string | undefined;
    productNameInImportDoc?: string | undefined;
    pinCode?: string | undefined;

    constructor(data?: IBalanceUFormProductDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.gsvsId = _data["gsvsId"];
            this.measureUnitId = _data["measureUnitId"];
            this.dutyTypeCode = _data["dutyTypeCode"];
            this.manufactureOrImportCountry = _data["manufactureOrImportCountry"];
            this.manufactureOrImportDocNumber = _data["manufactureOrImportDocNumber"];
            this.originCode = _data["originCode"];
            this.productNumberInImportDoc = _data["productNumberInImportDoc"];
            this.productNameInImportDoc = _data["productNameInImportDoc"];
            this.pinCode = _data["pinCode"];
        }
    }

    static fromJS(data: any): BalanceUFormProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceUFormProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["gsvsId"] = this.gsvsId;
        data["measureUnitId"] = this.measureUnitId;
        data["dutyTypeCode"] = this.dutyTypeCode;
        data["manufactureOrImportCountry"] = this.manufactureOrImportCountry;
        data["manufactureOrImportDocNumber"] = this.manufactureOrImportDocNumber;
        data["originCode"] = this.originCode;
        data["productNumberInImportDoc"] = this.productNumberInImportDoc;
        data["productNameInImportDoc"] = this.productNameInImportDoc;
        data["pinCode"] = this.pinCode;
        super.toJSON(data);
        return data;
    }
}

export interface IBalanceUFormProductDto extends IUFormProductDtoBase {
    name: string;
    gsvsId: number;
    measureUnitId: number;
    dutyTypeCode: UFormCustomsDutyType;
    manufactureOrImportCountry: string;
    manufactureOrImportDocNumber?: string | undefined;
    originCode: number;
    productNumberInImportDoc?: string | undefined;
    productNameInImportDoc?: string | undefined;
    pinCode?: string | undefined;
}

export class DetailingUFormDto extends UFormDtoBase implements IDetailingUFormDto {
    detailingType!: UFormDetailingType;
    /** Товары */
    products!: DetailingUFormProductDto[];

    constructor(data?: IDetailingUFormDto) {
        super(data);
        if (!data) {
            this.products = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.detailingType = _data["detailingType"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(DetailingUFormProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DetailingUFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new DetailingUFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["detailingType"] = this.detailingType;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IDetailingUFormDto extends IUFormDtoBase {
    detailingType: UFormDetailingType;
    /** Товары */
    products: DetailingUFormProductDto[];
}

export class DetailingUFormProductDto extends UFormProductDtoBase implements IDetailingUFormProductDto {
    name!: string;
    balanceId!: number;
    productId?: number | undefined;
    sectionType?: UFormSectionType | undefined;
    measureUnitId!: number;
    dutyTypeCode!: UFormCustomsDutyType;
    manufactureOrImportCountry!: string;
    manufactureOrImportDocNumber?: string | undefined;
    originCode!: number;
    productNumberInImportDoc?: string | undefined;
    productNameInImportDoc?: string | undefined;

    constructor(data?: IDetailingUFormProductDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.balanceId = _data["balanceId"];
            this.productId = _data["productId"];
            this.sectionType = _data["sectionType"];
            this.measureUnitId = _data["measureUnitId"];
            this.dutyTypeCode = _data["dutyTypeCode"];
            this.manufactureOrImportCountry = _data["manufactureOrImportCountry"];
            this.manufactureOrImportDocNumber = _data["manufactureOrImportDocNumber"];
            this.originCode = _data["originCode"];
            this.productNumberInImportDoc = _data["productNumberInImportDoc"];
            this.productNameInImportDoc = _data["productNameInImportDoc"];
        }
    }

    static fromJS(data: any): DetailingUFormProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new DetailingUFormProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["balanceId"] = this.balanceId;
        data["productId"] = this.productId;
        data["sectionType"] = this.sectionType;
        data["measureUnitId"] = this.measureUnitId;
        data["dutyTypeCode"] = this.dutyTypeCode;
        data["manufactureOrImportCountry"] = this.manufactureOrImportCountry;
        data["manufactureOrImportDocNumber"] = this.manufactureOrImportDocNumber;
        data["originCode"] = this.originCode;
        data["productNumberInImportDoc"] = this.productNumberInImportDoc;
        data["productNameInImportDoc"] = this.productNameInImportDoc;
        super.toJSON(data);
        return data;
    }
}

export interface IDetailingUFormProductDto extends IUFormProductDtoBase {
    name: string;
    balanceId: number;
    productId?: number | undefined;
    sectionType?: UFormSectionType | undefined;
    measureUnitId: number;
    dutyTypeCode: UFormCustomsDutyType;
    manufactureOrImportCountry: string;
    manufactureOrImportDocNumber?: string | undefined;
    originCode: number;
    productNumberInImportDoc?: string | undefined;
    productNameInImportDoc?: string | undefined;
}

export class SigningPageForUFormResponseDto implements ISigningPageForUFormResponseDto {
    urlToSign?: string | undefined;

    constructor(data?: ISigningPageForUFormResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.urlToSign = _data["urlToSign"];
        }
    }

    static fromJS(data: any): SigningPageForUFormResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SigningPageForUFormResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["urlToSign"] = this.urlToSign;
        return data;
    }
}

export interface ISigningPageForUFormResponseDto {
    urlToSign?: string | undefined;
}

export class ImportUFormsResultDto implements IImportUFormsResultDto {
    added!: number;
    updated!: number;

    constructor(data?: IImportUFormsResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.added = _data["added"];
            this.updated = _data["updated"];
        }
    }

    static fromJS(data: any): ImportUFormsResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportUFormsResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["added"] = this.added;
        data["updated"] = this.updated;
        return data;
    }
}

export interface IImportUFormsResultDto {
    added: number;
    updated: number;
}

export class AdGroupDto implements IAdGroupDto {
    id!: string;
    name!: string;

    constructor(data?: IAdGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AdGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IAdGroupDto {
    id: string;
    name: string;
}

export class GroupTaxpayerStoresDto implements IGroupTaxpayerStoresDto {
    group?: GroupDescriptionDto | undefined;
    taxpayerStores?: TaxpayerStoreDescriptionDto[] | undefined;

    constructor(data?: IGroupTaxpayerStoresDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"] ? GroupDescriptionDto.fromJS(_data["group"]) : <any>undefined;
            if (Array.isArray(_data["taxpayerStores"])) {
                this.taxpayerStores = [] as any;
                for (let item of _data["taxpayerStores"])
                    this.taxpayerStores!.push(TaxpayerStoreDescriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GroupTaxpayerStoresDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupTaxpayerStoresDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        if (Array.isArray(this.taxpayerStores)) {
            data["taxpayerStores"] = [];
            for (let item of this.taxpayerStores)
                data["taxpayerStores"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGroupTaxpayerStoresDto {
    group?: GroupDescriptionDto | undefined;
    taxpayerStores?: TaxpayerStoreDescriptionDto[] | undefined;
}

export class GroupDescriptionDto implements IGroupDescriptionDto {
    id!: string;
    name?: string | undefined;

    constructor(data?: IGroupDescriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GroupDescriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupDescriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IGroupDescriptionDto {
    id: string;
    name?: string | undefined;
}

export class TaxpayerStoreDescriptionDto implements ITaxpayerStoreDescriptionDto {
    /** Идентификатор */
    id!: number;
    /** Идентификатор в ЕСФ */
    externalId!: number;
    /** Наименование склада */
    name?: string | undefined;

    constructor(data?: ITaxpayerStoreDescriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TaxpayerStoreDescriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaxpayerStoreDescriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["name"] = this.name;
        return data;
    }
}

export interface ITaxpayerStoreDescriptionDto {
    /** Идентификатор */
    id: number;
    /** Идентификатор в ЕСФ */
    externalId: number;
    /** Наименование склада */
    name?: string | undefined;
}

export class GroupTaxpayerStoresIdsDto implements IGroupTaxpayerStoresIdsDto {
    groupId!: string;
    taxpayerStoreIds!: number[];

    constructor(data?: IGroupTaxpayerStoresIdsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.taxpayerStoreIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            if (Array.isArray(_data["taxpayerStoreIds"])) {
                this.taxpayerStoreIds = [] as any;
                for (let item of _data["taxpayerStoreIds"])
                    this.taxpayerStoreIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GroupTaxpayerStoresIdsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupTaxpayerStoresIdsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        if (Array.isArray(this.taxpayerStoreIds)) {
            data["taxpayerStoreIds"] = [];
            for (let item of this.taxpayerStoreIds)
                data["taxpayerStoreIds"].push(item);
        }
        return data;
    }
}

export interface IGroupTaxpayerStoresIdsDto {
    groupId: string;
    taxpayerStoreIds: number[];
}

export class GetRateResponseDto implements IGetRateResponseDto {
    rate?: number | undefined;
    isFound!: boolean;

    constructor(data?: IGetRateResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rate = _data["rate"];
            this.isFound = _data["isFound"];
        }
    }

    static fromJS(data: any): GetRateResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRateResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rate"] = this.rate;
        data["isFound"] = this.isFound;
        return data;
    }
}

export interface IGetRateResponseDto {
    rate?: number | undefined;
    isFound: boolean;
}

export class MeasureUnitDto implements IMeasureUnitDto {
    id!: number;
    code!: string;
    name!: string;

    constructor(data?: IMeasureUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): MeasureUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new MeasureUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }
}

export interface IMeasureUnitDto {
    id: number;
    code: string;
    name: string;
}

export class ImportMeasureUnitsResultDto implements IImportMeasureUnitsResultDto {
    added!: number;
    updated!: number;

    constructor(data?: IImportMeasureUnitsResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.added = _data["added"];
            this.updated = _data["updated"];
        }
    }

    static fromJS(data: any): ImportMeasureUnitsResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportMeasureUnitsResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["added"] = this.added;
        data["updated"] = this.updated;
        return data;
    }
}

export interface IImportMeasureUnitsResultDto {
    added: number;
    updated: number;
}

export class ImportPinCodesResultDto implements IImportPinCodesResultDto {
    added!: number;
    updated!: number;

    constructor(data?: IImportPinCodesResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.added = _data["added"];
            this.updated = _data["updated"];
        }
    }

    static fromJS(data: any): ImportPinCodesResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportPinCodesResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["added"] = this.added;
        data["updated"] = this.updated;
        return data;
    }
}

export interface IImportPinCodesResultDto {
    added: number;
    updated: number;
}

export class OilPinCodeDto implements IOilPinCodeDto {
    pinCode?: string | undefined;
    tin?: string | undefined;
    productName?: string | undefined;
    productionType?: string | undefined;

    constructor(data?: IOilPinCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pinCode = _data["pinCode"];
            this.tin = _data["tin"];
            this.productName = _data["productName"];
            this.productionType = _data["productionType"];
        }
    }

    static fromJS(data: any): OilPinCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new OilPinCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pinCode"] = this.pinCode;
        data["tin"] = this.tin;
        data["productName"] = this.productName;
        data["productionType"] = this.productionType;
        return data;
    }
}

export interface IOilPinCodeDto {
    pinCode?: string | undefined;
    tin?: string | undefined;
    productName?: string | undefined;
    productionType?: string | undefined;
}

export class CountryDto implements ICountryDto {
    id!: number;
    name?: string | undefined;
    code?: string | undefined;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface ICountryDto {
    id: number;
    name?: string | undefined;
    code?: string | undefined;
}

export class CurrencyDto implements ICurrencyDto {
    code?: string | undefined;
    rate?: number | undefined;

    constructor(data?: ICurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.rate = _data["rate"];
        }
    }

    static fromJS(data: any): CurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["rate"] = this.rate;
        return data;
    }
}

export interface ICurrencyDto {
    code?: string | undefined;
    rate?: number | undefined;
}

export class ImportExchangeRatesResultDto implements IImportExchangeRatesResultDto {
    added!: number;
    updated!: number;

    constructor(data?: IImportExchangeRatesResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.added = _data["added"];
            this.updated = _data["updated"];
        }
    }

    static fromJS(data: any): ImportExchangeRatesResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportExchangeRatesResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["added"] = this.added;
        data["updated"] = this.updated;
        return data;
    }
}

export interface IImportExchangeRatesResultDto {
    added: number;
    updated: number;
}

export class EsfUserProfileDto implements IEsfUserProfileDto {
    usernameSpecified!: boolean;
    passwordSpecified!: boolean;
    authCertificateUploaded!: boolean;
    signCertificateUploaded!: boolean;
    isGostCertificate!: boolean;
    readyForAuth!: boolean;
    readyForSign!: boolean;

    constructor(data?: IEsfUserProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.usernameSpecified = _data["usernameSpecified"];
            this.passwordSpecified = _data["passwordSpecified"];
            this.authCertificateUploaded = _data["authCertificateUploaded"];
            this.signCertificateUploaded = _data["signCertificateUploaded"];
            this.isGostCertificate = _data["isGostCertificate"];
            this.readyForAuth = _data["readyForAuth"];
            this.readyForSign = _data["readyForSign"];
        }
    }

    static fromJS(data: any): EsfUserProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new EsfUserProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usernameSpecified"] = this.usernameSpecified;
        data["passwordSpecified"] = this.passwordSpecified;
        data["authCertificateUploaded"] = this.authCertificateUploaded;
        data["signCertificateUploaded"] = this.signCertificateUploaded;
        data["isGostCertificate"] = this.isGostCertificate;
        data["readyForAuth"] = this.readyForAuth;
        data["readyForSign"] = this.readyForSign;
        return data;
    }
}

export interface IEsfUserProfileDto {
    usernameSpecified: boolean;
    passwordSpecified: boolean;
    authCertificateUploaded: boolean;
    signCertificateUploaded: boolean;
    isGostCertificate: boolean;
    readyForAuth: boolean;
    readyForSign: boolean;
}

export class TestConnectionResponseDto implements ITestConnectionResponseDto {
    isSuccess!: boolean;
    errorMessage?: string | undefined;

    constructor(data?: ITestConnectionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): TestConnectionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TestConnectionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface ITestConnectionResponseDto {
    isSuccess: boolean;
    errorMessage?: string | undefined;
}

export class SetCredentialCommand implements ISetCredentialCommand {
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: ISetCredentialCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): SetCredentialCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetCredentialCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface ISetCredentialCommand {
    userName?: string | undefined;
    password?: string | undefined;
}

export class NegotiationResponse implements INegotiationResponse {
    url?: string | undefined;
    accessToken?: string | undefined;
    connectionId?: string | undefined;
    connectionToken?: string | undefined;
    version!: number;
    availableTransports?: AvailableTransport[] | undefined;
    error?: string | undefined;
    useStatefulReconnect!: boolean;

    constructor(data?: INegotiationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.accessToken = _data["accessToken"];
            this.connectionId = _data["connectionId"];
            this.connectionToken = _data["connectionToken"];
            this.version = _data["version"];
            if (Array.isArray(_data["availableTransports"])) {
                this.availableTransports = [] as any;
                for (let item of _data["availableTransports"])
                    this.availableTransports!.push(AvailableTransport.fromJS(item));
            }
            this.error = _data["error"];
            this.useStatefulReconnect = _data["useStatefulReconnect"];
        }
    }

    static fromJS(data: any): NegotiationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NegotiationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["accessToken"] = this.accessToken;
        data["connectionId"] = this.connectionId;
        data["connectionToken"] = this.connectionToken;
        data["version"] = this.version;
        if (Array.isArray(this.availableTransports)) {
            data["availableTransports"] = [];
            for (let item of this.availableTransports)
                data["availableTransports"].push(item.toJSON());
        }
        data["error"] = this.error;
        data["useStatefulReconnect"] = this.useStatefulReconnect;
        return data;
    }
}

export interface INegotiationResponse {
    url?: string | undefined;
    accessToken?: string | undefined;
    connectionId?: string | undefined;
    connectionToken?: string | undefined;
    version: number;
    availableTransports?: AvailableTransport[] | undefined;
    error?: string | undefined;
    useStatefulReconnect: boolean;
}

export class AvailableTransport implements IAvailableTransport {
    transport?: string | undefined;
    transferFormats?: string[] | undefined;

    constructor(data?: IAvailableTransport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transport = _data["transport"];
            if (Array.isArray(_data["transferFormats"])) {
                this.transferFormats = [] as any;
                for (let item of _data["transferFormats"])
                    this.transferFormats!.push(item);
            }
        }
    }

    static fromJS(data: any): AvailableTransport {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableTransport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transport"] = this.transport;
        if (Array.isArray(this.transferFormats)) {
            data["transferFormats"] = [];
            for (let item of this.transferFormats)
                data["transferFormats"].push(item);
        }
        return data;
    }
}

export interface IAvailableTransport {
    transport?: string | undefined;
    transferFormats?: string[] | undefined;
}

export class NotificationDto implements INotificationDto {
    rowKey?: string | undefined;
    actionType?: string | undefined;
    documentId?: string | undefined;
    actionDateTime!: Date;
    status?: string | undefined;
    documentType?: string | undefined;
    documentNumber?: string | undefined;
    signedDateTime?: Date | undefined;
    responseDateTime?: Date | undefined;
    isRead!: boolean;
    registrationNumber?: string | undefined;
    cancelReason?: string | undefined;
    updatedDate!: Date;

    constructor(data?: INotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowKey = _data["rowKey"];
            this.actionType = _data["actionType"];
            this.documentId = _data["documentId"];
            this.actionDateTime = _data["actionDateTime"] ? new Date(_data["actionDateTime"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.documentType = _data["documentType"];
            this.documentNumber = _data["documentNumber"];
            this.signedDateTime = _data["signedDateTime"] ? new Date(_data["signedDateTime"].toString()) : <any>undefined;
            this.responseDateTime = _data["responseDateTime"] ? new Date(_data["responseDateTime"].toString()) : <any>undefined;
            this.isRead = _data["isRead"];
            this.registrationNumber = _data["registrationNumber"];
            this.cancelReason = _data["cancelReason"];
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowKey"] = this.rowKey;
        data["actionType"] = this.actionType;
        data["documentId"] = this.documentId;
        data["actionDateTime"] = this.actionDateTime ? this.actionDateTime.toYearMonthDateString() : <any>undefined;
        data["status"] = this.status;
        data["documentType"] = this.documentType;
        data["documentNumber"] = this.documentNumber;
        data["signedDateTime"] = this.signedDateTime ? this.signedDateTime.toYearMonthDateString() : <any>undefined;
        data["responseDateTime"] = this.responseDateTime ? this.responseDateTime.toYearMonthDateString() : <any>undefined;
        data["isRead"] = this.isRead;
        data["registrationNumber"] = this.registrationNumber;
        data["cancelReason"] = this.cancelReason;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toYearMonthDateString() : <any>undefined;
        return data;
    }
}

export interface INotificationDto {
    rowKey?: string | undefined;
    actionType?: string | undefined;
    documentId?: string | undefined;
    actionDateTime: Date;
    status?: string | undefined;
    documentType?: string | undefined;
    documentNumber?: string | undefined;
    signedDateTime?: Date | undefined;
    responseDateTime?: Date | undefined;
    isRead: boolean;
    registrationNumber?: string | undefined;
    cancelReason?: string | undefined;
    updatedDate: Date;
}

export class NotificationListResponseDto implements INotificationListResponseDto {
    paging?: PagingModel | undefined;
    notifications?: NotificationDto[] | undefined;

    constructor(data?: INotificationListResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paging = _data["paging"] ? PagingModel.fromJS(_data["paging"]) : <any>undefined;
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationListResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationListResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paging"] = this.paging ? this.paging.toJSON() : <any>undefined;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

export interface INotificationListResponseDto {
    paging?: PagingModel | undefined;
    notifications?: NotificationDto[] | undefined;
}

export class AuthTicketSigningProcessResultDto implements IAuthTicketSigningProcessResultDto {
    urlToSign?: string | undefined;
    hasSignedAuthTicket!: boolean;

    constructor(data?: IAuthTicketSigningProcessResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.urlToSign = _data["urlToSign"];
            this.hasSignedAuthTicket = _data["hasSignedAuthTicket"];
        }
    }

    static fromJS(data: any): AuthTicketSigningProcessResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthTicketSigningProcessResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["urlToSign"] = this.urlToSign;
        data["hasSignedAuthTicket"] = this.hasSignedAuthTicket;
        return data;
    }
}

export interface IAuthTicketSigningProcessResultDto {
    urlToSign?: string | undefined;
    hasSignedAuthTicket: boolean;
}

export class UserProfileDto implements IUserProfileDto {
    roles?: RoleType[] | undefined;
    company?: CompanyOptions | undefined;

    constructor(data?: IUserProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.company = _data["company"] ? CompanyOptions.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserProfileDto {
    roles?: RoleType[] | undefined;
    company?: CompanyOptions | undefined;
}

export enum RoleType {
    SntReadOnly = "SntReadOnly",
    Admin = "Admin",
    SntOperator = "SntOperator",
    TCOWarehouse = "TCOWarehouse",
    ApUser = "ApUser",
    ArReadOnly = "ArReadOnly",
    ArReadWrite = "ArReadWrite",
    DaoaUsers = "DaoaUsers",
    ApOperator = "ApOperator",
    DataImport = "DataImport",
}

export class CompanyOptions implements ICompanyOptions {
    tin?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    ignoredBalancesStoreExternalId!: number;
    certificateSeries?: string | undefined;
    certificateNum?: string | undefined;

    constructor(data?: ICompanyOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tin = _data["tin"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.ignoredBalancesStoreExternalId = _data["ignoredBalancesStoreExternalId"];
            this.certificateSeries = _data["certificateSeries"];
            this.certificateNum = _data["certificateNum"];
        }
    }

    static fromJS(data: any): CompanyOptions {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tin"] = this.tin;
        data["name"] = this.name;
        data["address"] = this.address;
        data["ignoredBalancesStoreExternalId"] = this.ignoredBalancesStoreExternalId;
        data["certificateSeries"] = this.certificateSeries;
        data["certificateNum"] = this.certificateNum;
        return data;
    }
}

export interface ICompanyOptions {
    tin?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    ignoredBalancesStoreExternalId: number;
    certificateSeries?: string | undefined;
    certificateNum?: string | undefined;
}

export class DocumentBaseDto implements IDocumentBaseDto {
    uuid?: string | undefined;
    action?: string | undefined;

    constructor(data?: IDocumentBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uuid = _data["uuid"];
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): DocumentBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uuid"] = this.uuid;
        data["action"] = this.action;
        return data;
    }
}

export interface IDocumentBaseDto {
    uuid?: string | undefined;
    action?: string | undefined;
}

export class DocumentSignedRequestDto extends DocumentBaseDto implements IDocumentSignedRequestDto {
    files?: DocumentSignedFileDto[] | undefined;

    constructor(data?: IDocumentSignedRequestDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(DocumentSignedFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentSignedRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentSignedRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IDocumentSignedRequestDto extends IDocumentBaseDto {
    files?: DocumentSignedFileDto[] | undefined;
}

export class DocumentSignedFileDto implements IDocumentSignedFileDto {
    downloadurl?: string | undefined;
    signdate?: string | undefined;
    filetitle?: string | undefined;
    fullname?: string | undefined;

    constructor(data?: IDocumentSignedFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downloadurl = _data["downloadurl"];
            this.signdate = _data["signdate"];
            this.filetitle = _data["filetitle"];
            this.fullname = _data["fullname"];
        }
    }

    static fromJS(data: any): DocumentSignedFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentSignedFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downloadurl"] = this.downloadurl;
        data["signdate"] = this.signdate;
        data["filetitle"] = this.filetitle;
        data["fullname"] = this.fullname;
        return data;
    }
}

export interface IDocumentSignedFileDto {
    downloadurl?: string | undefined;
    signdate?: string | undefined;
    filetitle?: string | undefined;
    fullname?: string | undefined;
}

export class EsfUserProfileDataResultDto implements IEsfUserProfileDataResultDto {
    userId!: string;
    usernameSecretName?: string | undefined;
    passwordSecretName?: string | undefined;
    base64AuthCertificateSecretName?: string | undefined;
    base64SignCertificateSecretName?: string | undefined;
    signRSAKeyName?: string | undefined;

    constructor(data?: IEsfUserProfileDataResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.usernameSecretName = _data["usernameSecretName"];
            this.passwordSecretName = _data["passwordSecretName"];
            this.base64AuthCertificateSecretName = _data["base64AuthCertificateSecretName"];
            this.base64SignCertificateSecretName = _data["base64SignCertificateSecretName"];
            this.signRSAKeyName = _data["signRSAKeyName"];
        }
    }

    static fromJS(data: any): EsfUserProfileDataResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EsfUserProfileDataResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["usernameSecretName"] = this.usernameSecretName;
        data["passwordSecretName"] = this.passwordSecretName;
        data["base64AuthCertificateSecretName"] = this.base64AuthCertificateSecretName;
        data["base64SignCertificateSecretName"] = this.base64SignCertificateSecretName;
        data["signRSAKeyName"] = this.signRSAKeyName;
        return data;
    }
}

export interface IEsfUserProfileDataResultDto {
    userId: string;
    usernameSecretName?: string | undefined;
    passwordSecretName?: string | undefined;
    base64AuthCertificateSecretName?: string | undefined;
    base64SignCertificateSecretName?: string | undefined;
    signRSAKeyName?: string | undefined;
}

export class GroupRolesDto implements IGroupRolesDto {
    group?: GroupDescriptionDto2 | undefined;
    roles?: RoleType[] | undefined;

    constructor(data?: IGroupRolesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"] ? GroupDescriptionDto2.fromJS(_data["group"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): GroupRolesDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupRolesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IGroupRolesDto {
    group?: GroupDescriptionDto2 | undefined;
    roles?: RoleType[] | undefined;
}

export class GroupDescriptionDto2 implements IGroupDescriptionDto2 {
    id!: string;
    name?: string | undefined;

    constructor(data?: IGroupDescriptionDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GroupDescriptionDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new GroupDescriptionDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IGroupDescriptionDto2 {
    id: string;
    name?: string | undefined;
}

export class PutGroupRolesDto implements IPutGroupRolesDto {
    groupId!: string;
    roles!: RoleType[];

    constructor(data?: IPutGroupRolesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): PutGroupRolesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PutGroupRolesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IPutGroupRolesDto {
    groupId: string;
    roles: RoleType[];
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}